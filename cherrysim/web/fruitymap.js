var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define("src/engine/locale/Localization", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Localization {
    }
    exports.Localization = Localization;
});
define("src/engine/locale/UnresolvedLocalization", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UnresolvedLocalization extends Localization_1.Localization {
        getLocalizedStringFor(placeholderString) {
            return placeholderString;
        }
    }
    exports.UnresolvedLocalization = UnresolvedLocalization;
});
define("src/engine/rendering/RenderingEnvironment", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RenderingEnvironment {
        constructor() {
            /**
             * True, if the renderer should render in the next frame.
             * This field can be set to true by all objects, if a state change effects the screen,
             * so that a rerendering in the next frame is necessary.
             */
            this._dirty = true;
        }
        // Getters and setters
        set dirty(dirty) {
            this._dirty = dirty;
        }
        get dirty() {
            return this._dirty;
        }
    }
    exports.RenderingEnvironment = RenderingEnvironment;
});
define("src/engine/scene/GameObject", ["require", "exports", "src/engine/locale/UnresolvedLocalization", "src/engine/rendering/RenderingEnvironment"], function (require, exports, UnresolvedLocalization_1, RenderingEnvironment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class of all game objects.
     *
     * Methods can be overridden to handle the different events that may occur at runtime.
     */
    class GameObject {
        // Construction
        constructor(environment) {
            this.environment = environment;
        }
        // Life cycle events
        /**
         * Called, whenever the object has been initialized in the game.
         */
        initialize() {
            // Default: Empty implementation
        }
        /**
         * Called, whenever a new update cycle of the game needs to be performed
         * @param lastFrametime The number of milliseconds this function should simulate.
         */
        update(lastFrametime) {
            // Default: Empty implementation
        }
        /**
         * Called, whenever the object has been destroyed from the game.
         */
        destroy() {
            // Default: Empty implementation
        }
        // Mouse events
        /**
         * Called, whenever the mouse moved into the game canvas.
         * @param x x coordinate given in canvas screen pixels.
         * @param y y coordinate given in canvas screen pixels.
         */
        onMouseIn(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move out of the game canvas.
         * @param x
         * @param y
         */
        onMouseOut(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move started.
         * @param x
         * @param y
         */
        onMouseStart(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move changed.
         * @param x
         * @param y
         */
        onMouseMove(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse move ends.
         * @param x
         * @param y
         */
        onMouseEnd(x, y) {
            return false;
        }
        /**
         * Called, whenever the mouse wheel is used.
         * @param delta delta = -1, on mouse wheel down, delta = 1, on mouse wheel up
         * @param mouseX
         * @param mouseY
         */
        onMouseWheel(delta, mouseX, mouseY) {
            return false;
        }
        // Touch events
        /**
         * Called, whenever the touch or mouse click event started.
         * @param x
         * @param y
         */
        onTouchStart(x, y, touchIndex) {
            return false;
        }
        /**
         * Called, whenever the touch or mouse click moved.
         * @param x
         * @param y
         */
        onTouchMove(x, y, touchIndex) {
            return false;
        }
        /**
         * Called, whenever the touch of mouse click was released.
         * @param x
         * @param y
         */
        onTouchEnd(x, y, touchIndex) {
            return false;
        }
        // Key events
        /**
         * Called, whenever a key was pressed on the keyboard.
         * @param keyCode
         */
        onKeyDown(keyCode) {
            return false;
        }
        /**
         * Called, whenever a key was released on the keyboard.
         */
        onKeyUp(keyCode) {
            return false;
        }
        // Gesture events
        onPanningStart(x, y) {
            return false;
        }
        onPanningMove(x, y) {
            return false;
        }
        onPanningEnd(x, y) {
            return false;
        }
        onPinchingStart(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingStart(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            return false;
        }
        onTap(x, y, numTaps) {
            return false;
        }
        // Localization events
        /**
         * Called, whenever the localization has changed.
         * This method must return false.
         */
        onLocalizationChanged() {
            return false;
        }
        getLocalization() {
            return this.environment.localization;
        }
        getLocalizedStringFor(placeholder) {
            return this.environment.localization.getLocalizedStringFor(placeholder);
        }
        // Package local!
        changeLocalization(localization) {
            this.environment.localization = localization;
        }
        // Resize events
        /**
         * Called, whenever the game canvas has been resized.
         * The new canvas width and height can be obtained using the
         * {@link getCanvasWidthInPx} and {@link getCanvasHeightInPx} methods.
         */
        onResize() {
            // Empty default implementation
        }
        getCanvasWidthInPx() {
            return this.environment.canvasSize.x;
        }
        getCanvasHeightInPx() {
            return this.environment.canvasSize.y;
        }
        getCanvasSizeInPx() {
            return this.environment.canvasSize;
        }
        // Package local
        setCanvasSizeInPx(widthInPx, heightInPx) {
            this.environment.canvasSize.x = widthInPx;
            this.environment.canvasSize.y = heightInPx;
        }
        // Getters and setters
        getEnvironment() {
            return this.environment;
        }
    }
    exports.GameObject = GameObject;
    (function (GameObject) {
        class Environment {
            constructor() {
                // Rendering
                /**
                 * The width and height of the WebGL canvas given in pixels.
                 */
                this.canvasSize = new PIXI.Point(1024, 768);
                /**
                 * The ratio between physical pixels and device-independent pixels (dips) on the device.
                 *
                 * Default: window.devicePixelRatio
                 */
                this.pixelRatio = window.devicePixelRatio;
                /**
                 * The environmental information for the rendering layer.
                 */
                this.renderingEnvironment = new RenderingEnvironment_1.RenderingEnvironment();
                // Locale
                /**
                 * The initial localization for english or german
                 * text translations.
                 * E.g. LocalizationDe or LocalizationEn
                 */
                this.localization = new UnresolvedLocalization_1.UnresolvedLocalization();
            }
        }
        GameObject.Environment = Environment;
    })(GameObject = exports.GameObject || (exports.GameObject = {}));
});
define("src/engine/math/Vector2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Vector2 {
        constructor(x, y) {
            this.v = [x, y];
        }
        static getVector2(point) {
            return new Vector2(point.x, point.y);
        }
        static getPoint(v) {
            return new PIXI.Point(v.getX(), v.getY());
        }
        toPoint() {
            return new PIXI.Point(this.getX(), this.getY());
        }
        static add(v1, v2) {
            return new Vector2(v1.v[0] + v2.v[0], v1.v[1] + v2.v[1]);
        }
        static subtract(v1, v2) {
            return new Vector2(v1.v[0] - v2.v[0], v1.v[1] - v2.v[1]);
        }
        static subtractPoints(p1, p2) {
            return new PIXI.Point(p1.x - p2.x, p1.y - p2.y);
        }
        static multiply(v1, s) {
            return new Vector2(s * v1.v[0], s * v1.v[1]);
        }
        static divide(v1, s) {
            return new Vector2(v1.v[0] / s, v1.v[1] / s);
        }
        static normalize(v1) {
            let result = new Vector2(0, 0);
            let l = v1.getLength();
            for (let i = 0; i < 2; ++i) {
                result.v[i] /= l;
            }
            return result;
        }
        static normalizePoint(p) {
            let result = new PIXI.Point(0, 0);
            let l = Vector2.getLengthOfPoint(p);
            result.x = p.x / l;
            result.y = p.y / l;
            return result;
        }
        static dot(v1, v2) {
            return v1.v[0] * v2.v[0] + v1.v[1] * v2.v[1];
        }
        static crossProduct(v1, v2) {
            return v1.getX() * v2.getY() - v1.getY() * v2.getX();
        }
        static getAngleBetween(v1, v2) {
            let numerator = Vector2.dot(v1, v2);
            let denominator = v1.getLength() * v2.getLength();
            let result = Math.acos(numerator / denominator);
            return result;
        }
        static getLengthOfPoint(p) {
            return Math.sqrt(p.x * p.x + p.y * p.y);
        }
        static getDistanceBetweenPoints(p1, p2) {
            let x = p1.x - p2.x;
            let y = p1.y - p2.y;
            return Math.sqrt(x * x + y * y);
        }
        get(index) {
            return this.v[index];
        }
        set(index, value) {
            this.v[index] = value;
        }
        getX() {
            return this.v[0];
        }
        setX(x) {
            this.v[0] = x;
        }
        getY() {
            return this.v[1];
        }
        setY(y) {
            this.v[1] = y;
        }
        getLength() {
            return Math.sqrt(this.v[0] * this.v[0] +
                this.v[1] * this.v[1]);
        }
        getLengthSqr() {
            return (this.v[0] * this.v[0] +
                this.v[1] * this.v[1]);
        }
        add(v1) {
            this.v[0] += v1.v[0];
            this.v[1] += v1.v[1];
            return this;
        }
        subtract(v1) {
            this.v[0] -= v1.v[0];
            this.v[1] -= v1.v[1];
            return this;
        }
        multiply(s) {
            this.v[0] = this.v[0] * s;
            this.v[1] = this.v[1] * s;
            return this;
        }
        divide(s) {
            this.v[0] = this.v[0] / s;
            this.v[1] = this.v[1] / s;
            return this;
        }
        normalize() {
            let l = this.getLength();
            for (let i = 0; i < 2; ++i) {
                this.v[i] /= l;
            }
            return this;
        }
    }
    exports.Vector2 = Vector2;
});
define("src/engine/general/AABB", ["require", "exports", "src/engine/general/OBB"], function (require, exports, OBB_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Axis aligned bounding box
    class AABB {
        constructor(min, max) {
            this.min = min;
            this.max = max;
        }
        getObb() {
            let topLeft = new PIXI.Point(this.min.x, this.min.y);
            let topRight = new PIXI.Point(this.max.x, this.min.y);
            let bottomLeft = new PIXI.Point(this.min.x, this.max.y);
            let bottomRight = new PIXI.Point(this.max.x, this.max.y);
            return new OBB_1.OBB(topLeft, topRight, bottomLeft, bottomRight);
        }
        intersects(aabb) {
            return !(aabb.max.x < this.min.x || this.max.x < aabb.min.x ||
                aabb.max.y < this.min.y || this.max.y < aabb.min.y);
        }
        innerIntersects(aabb) {
            return !(aabb.max.x <= this.min.x || this.max.x <= aabb.min.x ||
                aabb.max.y <= this.min.y || this.max.y <= aabb.min.y);
        }
        toString() {
            return "minx: " + this.min.x + ", miny: " + this.min.y + "\n" +
                "maxx: " + this.max.x + ", maxy: " + this.max.y + "\n";
        }
        clone() {
            return new AABB(new PIXI.Point(this.min.x, this.min.y), new PIXI.Point(this.max.x, this.max.y));
        }
    }
    exports.AABB = AABB;
});
define("src/engine/general/OBB", ["require", "exports", "src/engine/general/AABB"], function (require, exports, AABB_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Oriented bounding box
    class OBB {
        constructor(topLeft, topRight, bottomLeft, bottomRight) {
            this.topLeft = topLeft;
            this.topRight = topRight;
            this.bottomLeft = bottomLeft;
            this.bottomRight = bottomRight;
        }
        getAabb() {
            let minX = Math.min(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
            let maxX = Math.max(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
            let minY = Math.min(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
            let maxY = Math.max(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
            let aabb = new AABB_1.AABB(new PIXI.Point(minX, minY), new PIXI.Point(maxX, maxY));
            return aabb;
        }
        transform(transformMatrix) {
            let transformedTopLeft = transformMatrix.apply(this.topLeft);
            let transformedTopRight = transformMatrix.apply(this.topRight);
            let transformedBottomLeft = transformMatrix.apply(this.bottomLeft);
            let transformedBottomRight = transformMatrix.apply(this.bottomRight);
            let transformedObb = new OBB(transformedTopLeft, transformedTopRight, transformedBottomLeft, transformedBottomRight);
            return transformedObb;
        }
        toString() {
            return "topLeft x: " + this.topLeft.x + ", topLeft y: " + this.topLeft.y + "\n" +
                "topRight x: " + this.topRight.x + ", topRight y: " + this.topRight.y + "\n" +
                "bottomLeft x: " + this.bottomLeft.x + ", bottomLeft y: " + this.bottomLeft.y + "\n" +
                "bottomRight x: " + this.bottomRight.x + ", bottomRight y: " + this.bottomRight.y + "\n";
        }
    }
    exports.OBB = OBB;
});
define("src/engine/rendering/DecoratingObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * <h1>
     * Base class for all decorator render objects.
     * </h1>
     *
     * <p>
     * A decorator encapsulates the internal PIXI render object. All method calls will
     * be delegated to the PIXI object. Method calls that change the rendering state and
     * require a rerendering of the screen will set the dirty flag of the rendering environment to true.
     * If no object set the dirty flag to true, the rendering phase will be skipped to
     * minimize the GPU and CPU utilization (silent rendering loop).
     * </p>
     */
    class DecoratingObject {
        // Construction
        constructor(baseObject, environment) {
            this.baseObject = baseObject;
            this.environment = environment;
        }
        // Getters and setters
        pixi() {
            return this.baseObject;
        }
        setPixi(baseObject) {
            this.baseObject = baseObject;
        }
    }
    exports.DecoratingObject = DecoratingObject;
});
define("src/engine/rendering/utils/Point", ["require", "exports", "src/engine/rendering/DecoratingObject"], function (require, exports, DecoratingObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Point extends DecoratingObject_1.DecoratingObject {
        set x(x) {
            let oldX = this.pixi().x;
            if (oldX !== x) {
                this.pixi().x = x;
                this.environment.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            if (oldY !== y) {
                this.pixi().y = y;
                this.environment.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
    }
    exports.Point = Point;
});
define("src/engine/rendering/objects/DisplayObject", ["require", "exports", "src/engine/rendering/DecoratingObject", "src/engine/rendering/utils/Point"], function (require, exports, DecoratingObject_2, Point_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DisplayObject extends DecoratingObject_2.DecoratingObject {
        // Constructor
        constructor(baseObject, environment) {
            super(baseObject, environment);
            this._pivot = new Point_1.Point(baseObject.pivot, environment);
            this._scale = new Point_1.Point(baseObject.scale, environment);
            this._position = new Point_1.Point(baseObject.position, environment);
        }
        // Decorating methods
        destroy() {
            this.pixi().destroy();
            this.environment.dirty = true;
        }
        setParent(container) {
            this.pixi().setParent(container.pixi());
            this.environment.dirty = true;
        }
        setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
            let oldPositionX = this.pixi().position.x;
            let oldPositionY = this.pixi().position.y;
            let oldScaleX = this.pixi().scale.x;
            let oldScaleY = this.pixi().scale.y;
            let oldRotation = this.pixi().rotation;
            let oldSkewX = this.pixi().skew.x;
            let oldSkewY = this.pixi().skew.y;
            let oldPivotX = this.pixi().pivot.x;
            let oldPivotY = this.pixi().pivot.y;
            this.pixi().setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY);
            if (Math.abs(oldPositionX - x) > DisplayObject.EPSILON ||
                Math.abs(oldPositionY - y) > DisplayObject.EPSILON ||
                Math.abs(oldScaleX - scaleX) > DisplayObject.EPSILON ||
                Math.abs(oldScaleY - scaleY) > DisplayObject.EPSILON ||
                Math.abs(oldRotation - rotation) > DisplayObject.EPSILON ||
                Math.abs(oldSkewX - skewX) > DisplayObject.EPSILON ||
                Math.abs(oldSkewY - skewY) > DisplayObject.EPSILON ||
                Math.abs(oldPivotX - pivotX) > DisplayObject.EPSILON ||
                Math.abs(oldPivotY - pivotY) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        // Decorating getters and setters
        set alpha(alpha) {
            let oldAlpha = this.pixi().alpha;
            this.pixi().alpha = alpha;
            if (Math.abs(oldAlpha - alpha) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get alpha() {
            return this.pixi().alpha;
        }
        set worldAlpha(worldAlpha) {
            let oldWorldAlpha = this.pixi().worldAlpha;
            this.pixi().worldAlpha = worldAlpha;
            if (Math.abs(oldWorldAlpha - worldAlpha) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get worldAlpha() {
            return this.pixi().worldAlpha;
        }
        set visible(visible) {
            let oldVisible = this.pixi().visible;
            if (oldVisible !== visible) {
                this.pixi().visible = visible;
                this.environment.dirty = true;
            }
        }
        get visible() {
            return this.pixi().visible;
        }
        set localTransform(localTransform) {
            let oldLocalTransform = this.pixi().localTransform;
            this.pixi().localTransform = localTransform;
            if (Math.abs(oldLocalTransform.a - localTransform.a) > DisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.b - localTransform.b) > DisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.c - localTransform.c) > DisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.d - localTransform.d) > DisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.tx - localTransform.tx) > DisplayObject.EPSILON ||
                Math.abs(oldLocalTransform.ty - localTransform.ty) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get localTransform() {
            return this.pixi().localTransform;
        }
        set pivot(pivot) {
            let oldPivot = this.pixi().pivot;
            this.pixi().pivot = pivot.pixi();
            if (Math.abs(oldPivot.x - pivot.x) > DisplayObject.EPSILON ||
                Math.abs(oldPivot.y - pivot.y) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get pivot() {
            this._pivot.setPixi(this.pixi().pivot);
            return this._pivot;
        }
        set position(position) {
            let oldPosition = this.pixi().position;
            this.pixi().position = position.pixi();
            if (Math.abs(oldPosition.x - position.x) > DisplayObject.EPSILON ||
                Math.abs(oldPosition.y - position.y) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get position() {
            this._position.setPixi(this.pixi().position);
            return this._position;
        }
        set x(x) {
            let oldX = this.pixi().x;
            this.pixi().x = x;
            if (Math.abs(oldX - x) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            this.pixi().y = y;
            if (Math.abs(oldY - y) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
        set scale(scale) {
            let oldScale = this.pixi().scale;
            this.pixi().scale = scale.pixi();
            if (Math.abs(oldScale.x - scale.x) > DisplayObject.EPSILON ||
                Math.abs(oldScale.y - scale.y) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get scale() {
            this._scale.setPixi(this.pixi().scale);
            return this._scale;
        }
        set rotation(rotation) {
            let oldRotation = this.pixi().rotation;
            this.pixi().rotation = rotation;
            if (Math.abs(oldRotation - rotation) > DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get rotation() {
            return this.pixi().rotation;
        }
        set interactive(interactive) {
            let oldInteractive = this.pixi().interactive;
            if (oldInteractive !== interactive) {
                this.pixi().interactive = interactive;
                this.environment.dirty = true;
            }
        }
        get interactive() {
            return this.pixi().interactive;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    // Constants
    DisplayObject.EPSILON = 0.0001;
    exports.DisplayObject = DisplayObject;
});
define("src/engine/rendering/objects/DisplayObjectContainer", ["require", "exports", "src/engine/rendering/objects/DisplayObject"], function (require, exports, DisplayObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DisplayObjectContainer extends DisplayObject_1.DisplayObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
            this._children = new Array();
            for (let object of baseObject.children) {
                this._children.push(new DisplayObject_1.DisplayObject(object, environment));
            }
        }
        // Decorating methods
        destroy(options) {
            this.pixi().destroy(options);
            this.environment.dirty = true;
        }
        addChild(child) {
            this.pixi().addChild(child.pixi());
            this._children.push(child);
            this.environment.dirty = true;
        }
        removeChild(child) {
            this.pixi().removeChild(child.pixi());
            for (let i = 0; i < this._children.length; i++) {
                let c = this._children[i];
                if (c.pixi() === child.pixi()) {
                    this._children.splice(i, 1);
                }
            }
            this.environment.dirty = true;
        }
        removeChildren() {
            this.pixi().removeChildren();
            this._children = [];
            this.environment.dirty = true;
        }
        getChildAt(index) {
            return this._children[index];
        }
        setChildIndex(child, index) {
            this.pixi().setChildIndex(child.pixi(), index);
            // 1. Remove child, if exists
            for (let i = 0; i < this._children.length; i++) {
                let c = this._children[i];
                if (c.pixi() === child.pixi()) {
                    this._children.splice(i, 1);
                    break;
                }
            }
            // 2. Insert child at index
            this._children.splice(index, 0, child);
            this.environment.dirty = true;
        }
        // Decorating setters and getters
        get children() {
            return this._children;
        }
        set width(width) {
            let oldWidth = this.pixi().width;
            this.pixi().width = width;
            if (Math.abs(oldWidth - width) > DisplayObject_1.DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get width() {
            return this.pixi().width;
        }
        set height(height) {
            let oldHeight = this.pixi().height;
            this.pixi().height = height;
            if (Math.abs(oldHeight - height) > DisplayObject_1.DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get height() {
            return this.pixi().height;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.DisplayObjectContainer = DisplayObjectContainer;
});
define("src/engine/scene/Camera", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/math/Vector2", "src/engine/general/OBB", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_1, Vector2_1, OBB_2, DisplayObjectContainer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Camera extends SceneObject_1.SceneObject {
        constructor(environment, screenWidth = environment.canvasSize.x, screenHeight = environment.canvasSize.y) {
            super(environment);
            // Cached data
            this.transform = new PIXI.Transform();
            this.container = new DisplayObjectContainer_1.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.screenWidth = screenWidth;
            this.screenHeight = screenHeight;
        }
        getView() {
            return this.container;
        }
        // Sets the pivot in world coordinates.
        setPivotX(pivotX) {
            this.container.pivot.x = pivotX;
        }
        // Return the pivot in world coordinates.
        getPivotX() {
            return this.container.pivot.x;
        }
        // Sets the pivot in world coordinates.
        setPivotY(pivotY) {
            this.container.pivot.y = pivotY;
        }
        // Return the pivot in world coordinates.
        getPivotY() {
            return this.container.pivot.y;
        }
        // Sets the camera's x translation in the world system.
        setX(x) {
            this.container.x = -x;
        }
        // Returns the camera's x coordinate in the world system.
        getX() {
            return -this.container.x;
        }
        // Sets the camera's y translation in the world system.
        setY(y) {
            this.container.y = -y;
        }
        // Returns the camera's y coordinate in the world system.
        getY() {
            return -this.container.y;
        }
        setTranslation(point) {
            this.setX(point.x);
            this.setY(point.y);
        }
        // Sets the camera's rotation in radian.
        setRotation(rotation) {
            this.container.rotation = -rotation;
        }
        // Returns the camera's rotation in radian.
        getRotation() {
            return -this.container.rotation;
        }
        // Sets the camera's scale in x direction.
        // scaleX = 2.0 means, the camera zooms out with factor 2
        setScaleX(scaleX) {
            this.container.scale.x = 1.0 / scaleX;
        }
        // Returns the camera's scale in x direction.
        getScaleX() {
            return 1.0 / this.container.scale.x;
        }
        // Sets the camera's scale in y direction.
        setScaleY(scaleY) {
            this.container.scale.y = 1.0 / scaleY;
        }
        // Returns the camera's scale in y direction.
        getScaleY() {
            return 1.0 / this.container.scale.y;
        }
        // Translates the camera with the passed vector in camera coordinates.
        translate(translation) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-translation.x, -translation.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        // Rotates the camera around the focus point (in camera coordinates) without
        // changing the origin of the camera's local coordinate system.
        rotate(rotationAngle, focusPoint) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-focusPoint.x, -focusPoint.y);
            localTransformMatrix = localTransformMatrix.rotate(-rotationAngle);
            localTransformMatrix = localTransformMatrix.translate(focusPoint.x, focusPoint.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        // Scales the camera to/from the focus point given in camera coordinates without
        // changing the origin of the camera's local coordinate system.
        scale(scaleX, scaleY, focusPoint) {
            let localTransformMatrix = this.container.localTransform;
            localTransformMatrix = localTransformMatrix.translate(-focusPoint.x, -focusPoint.y);
            localTransformMatrix = localTransformMatrix.scale(1 / scaleX, 1 / scaleY);
            localTransformMatrix = localTransformMatrix.translate(focusPoint.x, focusPoint.y);
            this.updateLocalTransform(localTransformMatrix);
        }
        updateLocalTransform(localTransformMatrix) {
            this.transform.setFromMatrix(localTransformMatrix);
            this.container.setTransform(this.transform.position.x, this.transform.position.y, this.transform.scale.x, this.transform.scale.y, this.transform.rotation, this.transform.skew.x, this.transform.skew.y, this.transform.pivot.x, this.transform.pivot.y);
        }
        // Maps a point in the world coordinate system to the camera system.
        getImageCoordinateFromWorldPoint(worldPoint) {
            return this.container.pixi().toGlobal(worldPoint, new PIXI.Point());
        }
        // Maps a point in the camera coordinate system to the world system.
        getWorldCoordinateFromImagePoint(imagePoint) {
            return this.container.pixi().toLocal(imagePoint);
        }
        getPixelsInTexels(numPixels) {
            let sourceInTexels = this.getWorldCoordinateFromImagePoint(new PIXI.Point(0, 0));
            let targetInTexels = this.getWorldCoordinateFromImagePoint(new PIXI.Point(numPixels, 0));
            let diffVectorInTexels = new PIXI.Point(targetInTexels.x - sourceInTexels.x, targetInTexels.y - sourceInTexels.y);
            let pixelsInTexels = Vector2_1.Vector2.getLengthOfPoint(diffVectorInTexels);
            return pixelsInTexels;
        }
        // Sets the camera's frustum in world coordinates.
        setFrustum(frustum) {
            // Reference OBB
            let topLeft = new PIXI.Point(0, 0);
            let topRight = new PIXI.Point(this.getScreenWidth(), 0);
            let bottomLeft = new PIXI.Point(0, this.getScreenHeight());
            let bottomRight = new PIXI.Point(this.getScreenWidth(), this.getScreenHeight());
            let referenceObb = new OBB_2.OBB(topLeft, topRight, bottomLeft, bottomRight);
            // Target OBB
            let targetObb = frustum.getObb();
            let referenceDirection = Vector2_1.Vector2.getVector2(referenceObb.bottomRight)
                .subtract(Vector2_1.Vector2.getVector2(referenceObb.bottomLeft));
            let targetDirection = Vector2_1.Vector2.getVector2(frustum.bottomRight)
                .subtract(Vector2_1.Vector2.getVector2(frustum.bottomLeft));
            // Scaling
            let referenceWidth = referenceDirection.getLength();
            let targetWidth = targetDirection.getLength();
            let scaleFactor = referenceWidth / targetWidth;
            let scaleMatrix = new PIXI.Matrix();
            scaleMatrix = scaleMatrix.scale(scaleFactor, scaleFactor);
            referenceObb = referenceObb.transform(scaleMatrix);
            // Rotation
            let angleInRad = Vector2_1.Vector2.getAngleBetween(referenceDirection, targetDirection);
            // Rotation sign
            let crossProduct = Vector2_1.Vector2.crossProduct(targetDirection, referenceDirection);
            let scalarProduct = Vector2_1.Vector2.dot(targetDirection, referenceDirection);
            if (crossProduct < 0) {
                angleInRad = -angleInRad;
            }
            let rotationMatrix = new PIXI.Matrix();
            rotationMatrix = rotationMatrix.rotate(angleInRad);
            referenceObb = referenceObb.transform(rotationMatrix);
            // Translate
            let scaleRotationMatrix = new PIXI.Matrix().scale(scaleFactor, scaleFactor).rotate(angleInRad);
            let transformedTopLeft = scaleRotationMatrix.apply(frustum.topLeft);
            let translationVector = new PIXI.Point(-transformedTopLeft.x, -transformedTopLeft.y);
            // Set Transform
            this.container.setTransform(translationVector.x, translationVector.y, scaleFactor, scaleFactor, angleInRad, 0, 0, 0, 0);
        }
        // Returns the camera's frustum in world coordinates.
        getFrustum() {
            // Transform the frustum from screen space to world space.
            let topLeft = new PIXI.Point(0, 0);
            let topRight = new PIXI.Point(this.screenWidth, 0);
            let bottomLeft = new PIXI.Point(0, this.screenHeight);
            let bottomRight = new PIXI.Point(this.screenWidth, this.screenHeight);
            let topLeftWorld = this.getWorldCoordinateFromImagePoint(topLeft);
            let topRightWorld = this.getWorldCoordinateFromImagePoint(topRight);
            let bottomLeftWorld = this.getWorldCoordinateFromImagePoint(bottomLeft);
            let bottomRightWorld = this.getWorldCoordinateFromImagePoint(bottomRight);
            let frustum = new Camera.Frustum(topLeftWorld, topRightWorld, bottomLeftWorld, bottomRightWorld);
            return frustum;
        }
        getScreenWidth() {
            return this.screenWidth;
        }
        setScreenWidth(screenWidthInPx) {
            this.screenWidth = screenWidthInPx;
        }
        getScreenHeight() {
            return this.screenHeight;
        }
        setScreenHeight(screenHeightInPx) {
            this.screenHeight = screenHeightInPx;
        }
        update(lastFrametime) {
            super.update(lastFrametime);
        }
    }
    exports.Camera = Camera;
    (function (Camera) {
        class Frustum {
            constructor(topLeft, topRight, bottomLeft, bottomRight) {
                this.topLeft = topLeft;
                this.topRight = topRight;
                this.bottomLeft = bottomLeft;
                this.bottomRight = bottomRight;
            }
            getObb() {
                return new OBB_2.OBB(this.topLeft, this.topRight, this.bottomLeft, this.bottomRight);
            }
            static fromObb(obb) {
                let frustum = new Frustum(obb.topLeft, obb.topRight, obb.bottomLeft, obb.bottomRight);
                return frustum;
            }
        }
        Camera.Frustum = Frustum;
    })(Camera = exports.Camera || (exports.Camera = {}));
});
define("src/engine/scene/Scene", ["require", "exports", "src/engine/scene/GameObject", "src/engine/scene/Camera"], function (require, exports, GameObject_1, Camera_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Scene extends GameObject_1.GameObject {
        // Construction
        constructor(environment) {
            super(environment);
            // Rendering
            this.roundPixels = false;
            // Scene objects
            this.camera = null;
            this.camera = new Camera_1.Camera(environment);
            this.setSceneGraph(this.camera);
            this.sceneObjects = new Array();
            this.sceneObjects.push(this.sceneGraph);
        }
        // Initialization
        initialize() {
            super.initialize();
            let sceneObjects = this.getSceneObjects();
            this.initializeSceneObjects(sceneObjects);
        }
        initializeSceneObjects(sceneObjects) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isInitialized()) {
                    sceneObject.setInitialized(true);
                    sceneObject.initialize();
                }
            }
        }
        // Locale
        changeLocalization(localization) {
            super.changeLocalization(localization);
            let sceneObjects = this.getSceneObjects();
            this.setLocalizationOnSceneObjects(sceneObjects, localization);
        }
        setLocalizationOnSceneObjects(sceneObjects, localization) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.changeLocalization(localization);
                sceneObject.onLocalizationChanged();
            }
        }
        onLocalizationChanged() {
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.onLocalizationChanged();
            }
            return false;
        }
        // Destruction
        destroy() {
            super.destroy();
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.destroy();
            }
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            let sceneObjects = this.getSceneObjects();
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isPaused()) {
                    sceneObject.update(lastFrametime);
                }
            }
        }
        // Scene graph modification
        addSceneObject(sceneObject) {
            this.addSceneObjectToParent(sceneObject, this.sceneGraph);
        }
        addSceneObjectToParent(sceneObject, parent) {
            // 1. Check preconditions
            let sceneObjects = this.getSceneObjects();
            if (this.containsSceneObject(sceneObject)) {
                throw new Error("SceneObject could not be inserted, " +
                    "because the scene object is already in scene graph.");
            }
            if (!this.containsSceneObject(parent)) {
                throw new Error("SceneObject could not be inserted, " +
                    "because the parent object is not part of the scene.");
            }
            // 2. Insert into scene graph
            parent.addChild(sceneObject);
            // 3. Update scene graph
            this.updateSceneObjectsList();
            // 4. Notify scene object about parent change.
            sceneObject.onParentChanged();
        }
        setSceneObjectIndex(sceneObject, index) {
            let parent = sceneObject.getParent();
            if (parent == null) {
                throw new Error("The index of the scene object could not be changed, " +
                    "because the scene object does not contain a parent node and " +
                    "thus is not part of the scene graph.");
            }
            parent.setChildIndex(sceneObject, index);
            this.updateSceneObjectsList();
        }
        removeSceneObject(sceneObject) {
            // 1. Check preconditions
            let sceneObjects = this.getSceneObjects();
            if (!this.containsSceneObject(sceneObject)) {
                throw new Error("Scene object could not be removed, " +
                    "because the scene object is not part of the scene graph.");
            }
            // 2. Remove scene object
            let parent = sceneObject.getParent();
            parent.removeChild(sceneObject);
            // 3. Update scene graph
            this.updateSceneObjectsList();
            // 4. Notify scene object
            sceneObject.onParentChanged();
        }
        containsSceneObject(sceneObject) {
            for (let i = 0; i < this.sceneObjects.length; i++) {
                let currentSceneObject = this.sceneObjects[i];
                if (sceneObject.equals(currentSceneObject)) {
                    return true;
                }
            }
            return false;
        }
        // Package local! Should only be called by scene object or scene.
        // Is called, whenever the scene graph changes.
        updateSceneObjectsList() {
            if (this.sceneObjects) {
                this.sceneObjects = this.sceneGraph.getDescendantsAndSelf();
                // Initialize new scene objects
                let addedSceneObjects = this.getAddedSceneObjects(this.sceneObjects);
                this.initializeSceneObjects(addedSceneObjects);
            }
            else {
                this.sceneObjects = this.sceneGraph.getDescendantsAndSelf();
                // Initialize all scene objects
                this.initializeSceneObjects(this.sceneObjects);
            }
        }
        getAddedSceneObjects(allSceneObjects) {
            let newSceneObjects = new Array();
            for (let i = 0; i < allSceneObjects.length; i++) {
                let sceneObject = allSceneObjects[i];
                if (!sceneObject.isInitialized()) {
                    newSceneObjects.push(sceneObject);
                }
            }
            return newSceneObjects;
        }
        getSceneGraph() {
            return this.sceneGraph;
        }
        setSceneGraph(sceneObject) {
            this.sceneGraph = sceneObject;
            this.sceneGraph.setScene(this);
            this.updateSceneObjectsList();
        }
        getSceneObjects() {
            return this.sceneObjects;
        }
        setCamera(camera) {
            this.camera = camera;
            this.camera.setScene(this);
            let children = this.sceneGraph.getChildren();
            this.camera.addChildren(children);
            this.setSceneGraph(this.camera);
        }
        getCamera() {
            return this.camera;
        }
        // Event dispatching
        handleInputEvent(handlerName, values) {
            // Backward traverse through the list of scene objects
            // and delegate the input event to each scene object.
            // If the event has been processed, do not continue.
            // (Chain of responsibility).
            let sceneObjects = this.getSceneObjects();
            for (let i = sceneObjects.length - 1; i >= 0; i--) {
                let sceneObject = sceneObjects[i];
                if (!sceneObject.isPaused()) {
                    let handled = sceneObject[handlerName].apply(sceneObject, values);
                    if (handled) {
                        return true;
                    }
                }
            }
            return false;
        }
        handleResizeEvent(widthInPx, heightInPx) {
            super.setCanvasSizeInPx(widthInPx, heightInPx);
            let sceneObjects = this.getSceneObjects();
            this.setCanvasSizeOnSceneObjects(sceneObjects, widthInPx, heightInPx);
        }
        setCanvasSizeOnSceneObjects(sceneObjects, widthInPx, heightInPx) {
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.setCanvasSizeInPx(widthInPx, heightInPx);
            }
            for (let i = 0; i < sceneObjects.length; i++) {
                let sceneObject = sceneObjects[i];
                sceneObject.onResize();
            }
        }
        // Getters and setters
        setRoundPixels(roundPixels) {
            this.roundPixels = roundPixels;
        }
        isRoundPixels() {
            return this.roundPixels;
        }
    }
    exports.Scene = Scene;
});
define("src/engine/structs/SceneObjectIterator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/structs/SceneObjectListIterator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SceneObjectListIterator {
        constructor(array) {
            this.array = array;
            this.pointer = -1;
        }
        hasNext() {
            return this.pointer + 1 <= this.array.length - 1;
        }
        next() {
            this.pointer++;
            return this.array[this.pointer];
        }
        remove() {
            throw new Error("UnsupportedOperationException");
        }
    }
    exports.SceneObjectListIterator = SceneObjectListIterator;
});
define("src/engine/scene/SceneObject", ["require", "exports", "src/engine/structs/SceneObjectListIterator", "src/engine/scene/GameObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObjectListIterator_1, GameObject_2, DisplayObjectContainer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // A scene object is a game object having a transformation
    // in the scene (position, rotation etc.) and can is part
    // of a hierarchical scene graph.
    class SceneObject extends GameObject_2.GameObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // State
            this.initialized = false;
            this.paused = false;
            //// Scene graph
            // Back reference to the scene, which contains the scene object
            this.scene = null;
            // Back reference to the parent node in the scene graph.
            this.parent = null;
            this.sceneObjectEnvironment = environment;
            this.parent = null;
            this.children = new Array();
        }
        // Is the view that is finally used for rendering.
        // In most cases this equals getView().
        // @Override
        getRenderView() {
            return this.getView();
        }
        // General
        equals(sceneObject) {
            return this === sceneObject;
        }
        // Scene Graph
        getScene() {
            return this.scene;
        }
        setScene(scene) {
            // Set the own scene reference
            this.scene = scene;
            // Set the scene reference to all children recursively.
            for (let i = 0; i < this.getChildren().length; i++) {
                let child = this.getChildren()[i];
                child.setScene(scene);
            }
        }
        onParentChanged() {
            // Empty default implementation.
        }
        getParent() {
            return this.parent;
        }
        // Package local!
        setParent(parent) {
            if (this === parent) {
                throw new Error("Parent node could not be changed," +
                    "because parent node is identical with the node.");
            }
            let parentViewContainer = null;
            if (parent != null) {
                if (!(parent.getView() instanceof DisplayObjectContainer_2.DisplayObjectContainer)) {
                    throw new Error("Parent node could not be changed, " +
                        "because the parent node's view is not a container.");
                }
                else {
                    parentViewContainer = parent.getView();
                }
            }
            let oldParent = this.parent;
            this.parent = parent;
            if (parent != null) {
                // The child should be in the same scene as the parent.
                this.setScene(parent.getScene());
                // Change parent-child relationship in display object scene hierarchy.
                this.getRenderView().setParent(parentViewContainer);
            }
            else {
                this.setScene(null);
                this.getRenderView().setParent(new DisplayObjectContainer_2.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment));
            }
        }
        getChildren() {
            return this.children;
        }
        // Returns all child nodes (recursively) including the node itself.
        // The list is ordered by preorder traversing.
        getDescendantsAndSelf() {
            let descendantsAndSelf = new Array();
            let iterator = new SceneObject.PreorderIterator(this);
            while (iterator.hasNext()) {
                let sceneObject = iterator.next();
                descendantsAndSelf.push(sceneObject);
            }
            return descendantsAndSelf;
        }
        // Package local! Should not be called outside this package.
        // Adds the scene object to the end of the list of all child nodes
        // and changes their parent node to the this node.
        addChild(child) {
            if (child == null) {
                throw new Error("Scene object could not be added as a child node, " +
                    "because scene object is null.");
            }
            if (child === this) {
                throw new Error("Scene object could not be added as child node, " +
                    "because scene object is identical with this node");
            }
            let oldParent = child.getParent();
            if (oldParent != null) {
                oldParent.removeChild(child);
            }
            this.children.push(child);
            child.setParent(this);
            // Both the old parent's scene and the new parent's scene must be updated.
            if (oldParent != null && oldParent.getScene() != null) {
                oldParent.getScene().updateSceneObjectsList();
            }
            if (this != null && this.getScene() != null) {
                this.getScene().updateSceneObjectsList();
            }
        }
        addChildren(children) {
            for (let i = 0; i < children.length; i++) {
                let child = children[i];
                this.addChild(child);
            }
        }
        // Removes the child from the list of all child nodes.
        removeChild(child) {
            if (!this.hasChild(child)) {
                return;
            }
            this.removeChildFromChildren(child);
            child.setParent(null);
            // Parent's scene has changed. Update object list in that scene.
            if (this.scene) {
                this.scene.updateSceneObjectsList();
            }
        }
        removeChildFromChildren(child) {
            let indexOfChild = this.getChildIndex(child);
            if (indexOfChild > -1) {
                this.children.splice(indexOfChild, 1);
            }
        }
        hasChild(child) {
            let indexOfChild = this.getChildIndex(child);
            if (indexOfChild === -1) {
                return false;
            }
            else {
                return true;
            }
        }
        setChildIndex(child, index) {
            if (!this.hasChild(child)) {
                throw new Error("Index of child could not be changed, " +
                    "because the object is not child of this node.");
            }
            if (index < 0 || index > this.children.length) {
                throw new Error("Index of child could not be changed, " +
                    "because the index is out of bounds.");
            }
            let container = null;
            if (!(this.getView() instanceof DisplayObjectContainer_2.DisplayObjectContainer)) {
                throw new Error("Parent node could not be changed, " +
                    "because the parent node's view is not a container.");
            }
            else {
                container = this.getView();
            }
            let oldIndex = this.getChildIndex(child);
            if (index > oldIndex) {
                index--;
            }
            // Change the view container's scene graph.
            container.setChildIndex(child.getRenderView(), index);
            // Change the scene graph respectively.
            this.removeChildFromChildren(child);
            this.addChildAtIndex(index, child);
            // Scene has changed. Update object list in that scene.
            if (this.scene !== null) {
                this.scene.updateSceneObjectsList();
            }
        }
        addChildAtIndex(index, child) {
            // Inserts the item at index 'index'.
            this.children.splice(index, 0, child);
        }
        getChildIndex(child) {
            for (let i = 0; i < this.children.length; i++) {
                let currentChild = this.children[i];
                if (currentChild.equals(child)) {
                    return i;
                }
            }
            return -1;
        }
        addAfterObject(object, afterObject) {
            let index = this.getChildIndex(afterObject);
            if (index > -1) {
                this.addChild(object);
                this.setChildIndex(object, index + 1);
            }
        }
        // Getters and setters
        isInitialized() {
            return this.initialized;
        }
        setInitialized(initialized) {
            this.initialized = initialized;
        }
        isPaused() {
            return this.paused;
        }
        setPaused(paused) {
            this.paused = paused;
        }
        getEnvironment() {
            return this.sceneObjectEnvironment;
        }
    }
    exports.SceneObject = SceneObject;
    (function (SceneObject) {
        class Environment extends GameObject_2.GameObject.Environment {
        }
        SceneObject.Environment = Environment;
        class PreorderIterator {
            constructor(sceneObject) {
                // The iterator stack contains iterators
                // for all scene objects that iterator over the
                // object's children.
                this.iteratorStack = new Array();
                // Check precondition
                if (sceneObject == null) {
                    throw new Error("Preorder iterator could not be created for scene object null.");
                }
                // Wrap the root node in a list, so that
                // it is possible to iterator over the root itself.
                let wrapperList = new Array();
                wrapperList.push(sceneObject);
                this.iteratorStack.push(new SceneObjectListIterator_1.SceneObjectListIterator(wrapperList));
            }
            hasNext() {
                // A next element is always given, when at least
                // one iterator has a next element on the stack.
                for (let i = 0; i < this.iteratorStack.length; i++) {
                    let iterator = this.iteratorStack[i];
                    if (iterator.hasNext()) {
                        return true;
                    }
                }
                return false;
            }
            next() {
                // If user calls next although hasNext returns false,
                // we throw an exception.
                if (!this.hasNext()) {
                    throw new Error("Calling next although hasNext returns false is not allowed.");
                }
                // Take the iterator on top of the stack and
                // check if it has a next element.
                let currentIterator = this.iteratorStack[this.iteratorStack.length - 1];
                if (currentIterator.hasNext()) {
                    // If currentIterator has next element, return element.
                    // Moreover, the iterator of this element will be pushed to the stack.
                    let sceneObject = currentIterator.next();
                    let nextIterator = new SceneObjectListIterator_1.SceneObjectListIterator(sceneObject.getChildren());
                    this.iteratorStack.push(nextIterator);
                    return sceneObject;
                }
                else {
                    // If currentIterator has no next element,
                    // remove it from the stack and call this method
                    // recursively.
                    this.iteratorStack.pop();
                    return this.next();
                }
            }
            remove() {
                // Removing objects using iterator is not supported.
                throw new Error("UnsupportedOperationException");
            }
        }
        SceneObject.PreorderIterator = PreorderIterator;
    })(SceneObject = exports.SceneObject || (exports.SceneObject = {}));
});
define("src/engine/animation/Interpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/engine/animation/Animation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Can be used to interpolate arbitrary numeric values.
    // The type of interpolation is given by an interpolator object.
    class Animation {
        constructor(interpolator) {
            this.observers = new Array();
            this.interpolator = interpolator;
            this.isAnimating = false;
            this.elapsedTimeInMs = 0;
            this.startValue = 0;
            this.endValue = 0;
            this.durationInMs = 0;
            this.delayInMs = 0;
            this.lastValue = 0;
        }
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObservers() {
            this.observers = new Array();
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index >= 0) {
                this.observers.splice(index, 1);
            }
        }
        start(startValue, endValue, durationInMs, delayInMs) {
            this.isAnimating = true;
            this.elapsedTimeInMs = 0;
            this.startValue = startValue;
            this.endValue = endValue;
            this.durationInMs = durationInMs;
            this.delayInMs = delayInMs;
            this.notifyObserversAboutAnimationStart();
        }
        notifyObserversAboutAnimationStart() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidStart(this);
            }
        }
        stop() {
            this.isAnimating = false;
            this.notifyObserversAboutAnimationStop();
        }
        notifyObserversAboutAnimationStop() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidStop(this);
            }
        }
        // Returns the current interpolation value
        getValue(lastFrametimeInMs) {
            let timeProgress = 0;
            if (this.elapsedTimeInMs < this.delayInMs) {
                timeProgress = 0;
            }
            else {
                timeProgress = (this.elapsedTimeInMs - this.delayInMs) / this.durationInMs;
            }
            let interpolationValue = this.getEnsuredInterpolationValue(timeProgress);
            let range = this.endValue - this.startValue;
            let value = this.startValue + interpolationValue * range;
            if (timeProgress >= 1.0 && this.isAnimating) {
                this.stop();
                this.notifyObserversAboutAnimationFinish();
            }
            this.updateElapsedTimeInMs(lastFrametimeInMs);
            this.lastValue = value;
            return value;
        }
        updateElapsedTimeInMs(lastFrametimeInMs) {
            this.elapsedTimeInMs += lastFrametimeInMs;
        }
        getEnsuredInterpolationValue(timeProgress) {
            timeProgress = this.getEnsuredTimeProgress(timeProgress);
            return this.interpolator.getInterpolationValue(timeProgress);
        }
        getEnsuredTimeProgress(timeProgress) {
            if (timeProgress < 0) {
                timeProgress = 0;
            }
            else if (timeProgress > 1) {
                timeProgress = 1;
            }
            return timeProgress;
        }
        notifyObserversAboutAnimationFinish() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.animationDidFinish(this);
            }
        }
        getLastValue() {
            return this.lastValue;
        }
        // Getters and setters
        getInterpolator() {
            return this.interpolator;
        }
        isCurrentlyAnimating() {
            return this.isAnimating;
        }
        getStartValue() {
            return this.startValue;
        }
        getEndValue() {
            return this.endValue;
        }
        getDurationInMs() {
            return this.durationInMs;
        }
        setElapsedTimeInMs(elapsedTimeInMs) {
            this.elapsedTimeInMs = elapsedTimeInMs;
        }
        getElapsedTimeInMs() {
            return this.elapsedTimeInMs;
        }
    }
    exports.Animation = Animation;
});
define("src/map/view/world/objects/WorldCamera", ["require", "exports", "src/engine/scene/Camera", "src/engine/general/AABB", "src/engine/animation/Animation", "src/engine/general/OBB"], function (require, exports, Camera_2, AABB_2, Animation_1, OBB_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // A camera that can be animated through procedural (dynamics)
    // and explicit (kinematics) animations. The camera's movement
    // is constrained to the dimensions of a world.
    class WorldCamera extends Camera_2.Camera {
        // Initialization
        constructor(config, environment, screenWidth = environment.canvasSize.x, screenHeight = environment.canvasSize.y) {
            super(environment, screenWidth, screenHeight);
            //// State
            // True, if borders should be enabled.
            this.bordersCurrentlyEnabled = true;
            //// Dynamics
            // Translation
            this.translationVelocity = new PIXI.Point();
            // Scale
            this.scaleVelocity = 1;
            this.scaleFocusPoint = new PIXI.Point();
            // Rotation
            this.rotationVelocity = 0;
            this.rotationFocusPoint = new PIXI.Point();
            // Cached data for performance optimization
            this.lastWorldTransform = null;
            this.lastWorldDimensions = null;
            this.canvasDimensionsChanged = true;
            this.config = config;
        }
        // Configuration
        setWorldDimensions(aabb) {
            // Set the world of reference
            this.worldDimensions = new AABB_2.AABB(new PIXI.Point(aabb.min.x, aabb.min.y), new PIXI.Point(aabb.max.x, aabb.max.y));
        }
        // Should be called whenever the world has been increased or decreased.
        setWorldDimensionsToFitChildren() {
            // Set the world of reference
            this.worldDimensions = new AABB_2.AABB(new PIXI.Point(0, 0), new PIXI.Point(this.container.width, this.container.height));
        }
        showWholeWorld() {
            // Camera should display whole scene at the beginning.
            let worldAabb = this.getCurrentWorldBordersInImageCoordinates();
            let worldObb = worldAabb.getObb();
            let frustum = Camera_2.Camera.Frustum.fromObb(worldObb);
            this.setFrustum(frustum);
        }
        // Dynamics
        addTranslationImpulse(translation) {
            this.translationVelocity = translation;
        }
        addRotationImpulse(rotationAngle, focusPoint) {
            this.rotationVelocity = rotationAngle;
            this.rotationFocusPoint = focusPoint;
        }
        addScaleImpulse(scale, focusPoint) {
            this.scaleVelocity = scale;
            this.scaleFocusPoint = focusPoint;
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.isKinematicsRunning()) {
                this.updateKinematics(lastFrametime);
            }
            else {
                this.updateDynamics();
            }
        }
        isKinematicsRunning() {
            return this.frustumBottomLeftAnimationX != null
                && this.frustumTopLeftAnimationX.isCurrentlyAnimating();
        }
        updateKinematics(lastFrametime) {
            let topLeft = new PIXI.Point();
            topLeft.x = this.frustumTopLeftAnimationX.getValue(lastFrametime);
            topLeft.y = this.frustumTopLeftAnimationY.getValue(lastFrametime);
            let topRight = new PIXI.Point();
            topRight.x = this.frustumTopRightAnimationX.getValue(lastFrametime);
            topRight.y = this.frustumTopRightAnimationY.getValue(lastFrametime);
            let bottomLeft = new PIXI.Point();
            bottomLeft.x = this.frustumBottomLeftAnimationX.getValue(lastFrametime);
            bottomLeft.y = this.frustumBottomLeftAnimationY.getValue(lastFrametime);
            let bottomRight = new PIXI.Point();
            bottomRight.x = this.frustumBottomRightAnimationX.getValue(lastFrametime);
            bottomRight.y = this.frustumBottomRightAnimationY.getValue(lastFrametime);
            let targetObb = new OBB_3.OBB(topLeft, topRight, bottomLeft, bottomRight);
            this.setFrustum(Camera_2.Camera.Frustum.fromObb(targetObb));
        }
        updateDynamics() {
            this.updateMovement();
            this.resolveCollisions();
        }
        updateMovement() {
            let scaled = this.updateScale();
            let moved = this.updateTranslation();
            let rotated = this.updateRotation();
            return scaled || moved || rotated;
        }
        updateScale() {
            if (this.scaleSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 8.0;
            this.scaleVelocity = this.scaleVelocity - ((this.scaleVelocity - 1) / smoothness);
            this.scale(this.scaleVelocity, this.scaleVelocity, this.scaleFocusPoint);
            return true;
        }
        scaleSpeedIsNearZero() {
            return Math.abs(this.scaleVelocity - 1) < 0.00001;
        }
        updateTranslation() {
            if (this.translationSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 1.075;
            this.translationVelocity.x /= smoothness;
            this.translationVelocity.y /= smoothness;
            this.translate(this.translationVelocity);
            return true;
        }
        translationSpeedIsNearZero() {
            return Math.abs(this.translationVelocity.x) < 0.01 && Math.abs(this.translationVelocity.y) < 0.01;
        }
        updateRotation() {
            if (this.rotationSpeedIsNearZero()) {
                return false;
            }
            let smoothness = 1.075;
            this.rotationVelocity /= smoothness;
            this.rotate(this.rotationVelocity, this.rotationFocusPoint);
            return true;
        }
        rotationSpeedIsNearZero() {
            return Math.abs(this.rotationVelocity) < 0.001;
        }
        resolveCollisions() {
            if (this.config.bordersEnabled) {
                if (this.bordersCurrentlyEnabled) {
                    if (this.cameraTransformationHasChanged() || this.worldBordersHaveChanged() || this.canvasDimensionsHaveChanged()) {
                        let frustumAabb = this.getFrustumInImageCoordinates();
                        let worldAabb = this.getCurrentWorldBordersInImageCoordinates();
                        this.resolveInterpenetrations(worldAabb, frustumAabb);
                    }
                }
            }
        }
        cameraTransformationHasChanged() {
            const worldTransform = this.getView().pixi().worldTransform;
            if (this.lastWorldTransform == null ||
                worldTransform.a !== this.lastWorldTransform.a ||
                worldTransform.b !== this.lastWorldTransform.b ||
                worldTransform.c !== this.lastWorldTransform.c ||
                worldTransform.d !== this.lastWorldTransform.d ||
                worldTransform.tx !== this.lastWorldTransform.tx ||
                worldTransform.ty !== this.lastWorldTransform.ty) {
                this.lastWorldTransform = worldTransform.clone();
                return true;
            }
            else {
                return false;
            }
        }
        worldBordersHaveChanged() {
            if (this.lastWorldDimensions == null ||
                this.worldDimensions.min.x !== this.lastWorldDimensions.min.x ||
                this.worldDimensions.min.y !== this.lastWorldDimensions.min.y ||
                this.worldDimensions.max.x !== this.lastWorldDimensions.max.x ||
                this.worldDimensions.max.y !== this.lastWorldDimensions.max.y) {
                this.lastWorldDimensions = this.worldDimensions.clone();
                return true;
            }
            else {
                return false;
            }
        }
        canvasDimensionsHaveChanged() {
            if (this.canvasDimensionsChanged) {
                this.canvasDimensionsChanged = false;
                return true;
            }
            else {
                return false;
            }
        }
        getFrustumInImageCoordinates() {
            // It may happen, that the frustum itself is inside a container.
            // Thus, we have to transform the frustum AABB to the real image space.
            // Get frustum
            let frustumAabb = new AABB_2.AABB(new PIXI.Point(0, 0), new PIXI.Point(this.getScreenWidth(), this.getScreenHeight()));
            if (this.getParent() != null) {
                // Transform frustum to real image space.
                let topLeftInImage = this.getParent().getView().pixi().toGlobal(new PIXI.Point(frustumAabb.min.x, frustumAabb.min.y), new PIXI.Point());
                let topRightInImage = this.getParent().getView().pixi().toGlobal(new PIXI.Point(frustumAabb.max.x, frustumAabb.min.y), new PIXI.Point());
                let bottomLeftInImage = this.getParent().getView().pixi().toGlobal(new PIXI.Point(frustumAabb.min.x, frustumAabb.max.y), new PIXI.Point());
                let bottomRightInImage = this.getParent().getView().pixi().toGlobal(new PIXI.Point(frustumAabb.max.x, frustumAabb.max.y), new PIXI.Point());
                let frustumInImageSpace = new OBB_3.OBB(topLeftInImage, topRightInImage, bottomLeftInImage, bottomRightInImage);
                // Get AABB of frustum.
                let frustumAabbInImageSpace = frustumInImageSpace.getAabb();
                return frustumAabbInImageSpace;
            }
            else {
                return frustumAabb;
            }
        }
        getDefaultWorldBordersInWorldCoordinates() {
            let worldAabb = new AABB_2.AABB(this.worldDimensions.min, this.worldDimensions.max);
            let worldAabbWithAspectRatioFit = this.getWorldAabbToFitScreenAspectRatio(worldAabb);
            return worldAabbWithAspectRatioFit.getObb();
        }
        // Returns the world's oriented bounding box in world coordinates based on
        // the cameras current orientation.
        getCurrentWorldBordersInWorldCoordinates() {
            let worldAabbInImageCoordinates = this.getCurrentWorldBordersInImageCoordinates();
            let topLeft = this.getWorldCoordinateFromImagePoint(new PIXI.Point(worldAabbInImageCoordinates.min.x, worldAabbInImageCoordinates.min.y));
            let topRight = this.getWorldCoordinateFromImagePoint(new PIXI.Point(worldAabbInImageCoordinates.max.x, worldAabbInImageCoordinates.min.y));
            let bottomLeft = this.getWorldCoordinateFromImagePoint(new PIXI.Point(worldAabbInImageCoordinates.min.x, worldAabbInImageCoordinates.max.y));
            let bottomRight = this.getWorldCoordinateFromImagePoint(new PIXI.Point(worldAabbInImageCoordinates.max.x, worldAabbInImageCoordinates.max.y));
            let worldObbInWorldCoordinates = new OBB_3.OBB(topLeft, topRight, bottomLeft, bottomRight);
            return worldObbInWorldCoordinates;
        }
        getCurrentWorldBordersInImageCoordinates() {
            let worldDimensionsInImage = this.getWorldDimensionsInImageSpace();
            let worldAabb = worldDimensionsInImage.getAabb();
            worldAabb = this.getWorldAabbToFitScreenAspectRatio(worldAabb);
            return worldAabb;
        }
        getWorldDimensionsInImageSpace() {
            let topLeftInImage = this.getImageCoordinateFromWorldPoint(new PIXI.Point(this.worldDimensions.min.x, this.worldDimensions.min.y));
            let topRightInImage = this.getImageCoordinateFromWorldPoint(new PIXI.Point(this.worldDimensions.max.x, this.worldDimensions.min.y));
            let bottomLeftInImage = this.getImageCoordinateFromWorldPoint(new PIXI.Point(this.worldDimensions.min.x, this.worldDimensions.max.y));
            let bottomRightInImage = this.getImageCoordinateFromWorldPoint(new PIXI.Point(this.worldDimensions.max.x, this.worldDimensions.max.y));
            let worldInImageSpace = new OBB_3.OBB(topLeftInImage, topRightInImage, bottomLeftInImage, bottomRightInImage);
            return worldInImageSpace;
        }
        getWorldAabbToFitScreenAspectRatio(worldAabb) {
            let worldAspectRatio = (worldAabb.max.x - worldAabb.min.x) / (worldAabb.max.y - worldAabb.min.y);
            let screenAspectRatio = this.getScreenWidth() / this.getScreenHeight();
            if (worldAspectRatio > screenAspectRatio) {
                let targetWidth = worldAabb.max.x - worldAabb.min.x;
                let targetHeight = targetWidth / screenAspectRatio;
                let currentHeight = worldAabb.max.y - worldAabb.min.y;
                worldAabb.min.y = worldAabb.min.y - (targetHeight - currentHeight) / 2;
                worldAabb.max.y = worldAabb.max.y + (targetHeight - currentHeight) / 2;
            }
            else {
                let targetHeight = worldAabb.max.y - worldAabb.min.y;
                let targetWidth = targetHeight * screenAspectRatio;
                let currentWidth = worldAabb.max.x - worldAabb.min.x;
                worldAabb.min.x = worldAabb.min.x - (targetWidth - currentWidth) / 2;
                worldAabb.max.x = worldAabb.max.x + (targetWidth - currentWidth) / 2;
            }
            return worldAabb;
        }
        resolveInterpenetrations(worldAabb, frustumAabb) {
            worldAabb = this.resolveScalingConstraintViolations(worldAabb, frustumAabb);
            this.resolveTranslationConstraintViolations(worldAabb, frustumAabb);
        }
        resolveScalingConstraintViolations(worldAabb, frustumAabb) {
            // Resolve scale constraint violations by zooming the frustum's AABB to fit the world's AABB.
            let frustumWidth = frustumAabb.max.x - frustumAabb.min.x;
            let frustumHeight = frustumAabb.max.y - frustumAabb.min.y;
            let worldWidth = worldAabb.max.x - worldAabb.min.x;
            let worldHeight = worldAabb.max.y - worldAabb.min.y;
            if (frustumWidth > worldWidth || frustumHeight > worldHeight) {
                let scalingFactor = 0;
                if (this.config.useSoftBorders) {
                    scalingFactor = this.getSmoothScalingFactor(worldAabb, frustumAabb);
                }
                else {
                    scalingFactor = (worldAabb.max.x - worldAabb.min.x) /
                        (frustumAabb.max.x - frustumAabb.min.x);
                }
                if (scalingFactor !== 1) {
                    let minXOffset = Math.abs(worldAabb.min.x - frustumAabb.min.x);
                    let maxXOffset = Math.abs(frustumAabb.max.x - worldAabb.max.x);
                    let minYOffset = Math.abs(worldAabb.min.y - frustumAabb.min.y);
                    let maxYOffset = Math.abs(frustumAabb.max.y - worldAabb.max.y);
                    let relativeOffsetX = minXOffset / (minXOffset + maxXOffset);
                    let relativeOffsetY = minYOffset / (minYOffset + maxYOffset);
                    let focusPoint = new PIXI.Point(frustumAabb.min.x + frustumWidth * relativeOffsetX, frustumAabb.min.y + frustumHeight * relativeOffsetY);
                    this.scale(scalingFactor, scalingFactor, focusPoint);
                    // Recompute the world AABB for the subsequent interpenetration resolution steps,
                    // because the screen space has changed due to the scaling.
                    worldAabb = this.getCurrentWorldBordersInImageCoordinates();
                }
            }
            return worldAabb;
        }
        getSmoothScalingFactor(worldAabb, frustumAabb) {
            let resistenceForce = 1;
            let scaleDistanceToTarget = (worldAabb.max.x - worldAabb.min.x) / (frustumAabb.max.x - frustumAabb.min.x);
            resistenceForce = 1 - ((1 - scaleDistanceToTarget) * 0.1);
            return resistenceForce;
        }
        resolveTranslationConstraintViolations(worldAabb, frustumAabb) {
            let moveX = 0.0;
            let moveY = 0.0;
            if (frustumAabb.min.x < worldAabb.min.x) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.min.x;
                    let position = frustumAabb.min.x;
                    let velocity = this.translationVelocity.x;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = -(frustumAabb.min.x - worldAabb.min.x);
                }
                moveX += movement;
            }
            if (frustumAabb.max.x > worldAabb.max.x) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.max.x;
                    let position = frustumAabb.max.x;
                    let velocity = this.translationVelocity.x;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = (frustumAabb.max.x - worldAabb.max.x);
                }
                moveX -= movement;
            }
            if (frustumAabb.min.y < worldAabb.min.y) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.min.y;
                    let position = frustumAabb.min.y;
                    let velocity = this.translationVelocity.y;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = -(frustumAabb.min.y - worldAabb.min.y);
                }
                moveY += movement;
            }
            if (frustumAabb.max.y > worldAabb.max.y) {
                let movement = 0;
                if (this.config.useSoftBorders) {
                    let targetPosition = worldAabb.max.y;
                    let position = frustumAabb.max.y;
                    let velocity = this.translationVelocity.y;
                    movement = this.getSmoothMovement(targetPosition, position, velocity);
                }
                else {
                    movement = (frustumAabb.max.y - worldAabb.max.y);
                }
                moveY -= movement;
            }
            this.translate(new PIXI.Point(moveX, moveY));
        }
        getSmoothMovement(targetPosition, position, velocity) {
            // Resistence foce: Tries to recover the drift. Is only active, when user has released finger.
            let resistenceForce = 0;
            let distanceToTarget = Math.abs(position - targetPosition);
            resistenceForce = distanceToTarget * 0.1;
            return resistenceForce;
        }
        /**
         * Retransforms the camera to not collide with the world borders anymore.
         */
        resolveCollisionsWithWorldBorders() {
            let useSoftBordersBackup = this.isUsingSoftBorders();
            this.setUseSoftBorders(false);
            this.resolveCollisions();
            this.setUseSoftBorders(useSoftBordersBackup);
        }
        // Kinematics
        startAnimation(interpolator, endObb, durationInMs, delayInMs) {
            this.frustumTopLeftAnimationX = new Animation_1.Animation(interpolator);
            this.frustumTopLeftAnimationY = new Animation_1.Animation(interpolator);
            this.frustumTopRightAnimationX = new Animation_1.Animation(interpolator);
            this.frustumTopRightAnimationY = new Animation_1.Animation(interpolator);
            this.frustumBottomLeftAnimationX = new Animation_1.Animation(interpolator);
            this.frustumBottomLeftAnimationY = new Animation_1.Animation(interpolator);
            this.frustumBottomRightAnimationX = new Animation_1.Animation(interpolator);
            this.frustumBottomRightAnimationY = new Animation_1.Animation(interpolator);
            let startObb = this.getFrustum().getObb();
            this.frustumTopLeftAnimationX.start(startObb.topLeft.x, endObb.topLeft.x, durationInMs, delayInMs);
            this.frustumTopLeftAnimationY.start(startObb.topLeft.y, endObb.topLeft.y, durationInMs, delayInMs);
            this.frustumTopRightAnimationX.start(startObb.topRight.x, endObb.topRight.x, durationInMs, delayInMs);
            this.frustumTopRightAnimationY.start(startObb.topRight.y, endObb.topRight.y, durationInMs, delayInMs);
            this.frustumBottomLeftAnimationX.start(startObb.bottomLeft.x, endObb.bottomLeft.x, durationInMs, delayInMs);
            this.frustumBottomLeftAnimationY.start(startObb.bottomLeft.y, endObb.bottomLeft.y, durationInMs, delayInMs);
            this.frustumBottomRightAnimationX.start(startObb.bottomRight.x, endObb.bottomRight.x, durationInMs, delayInMs);
            this.frustumBottomRightAnimationY.start(startObb.bottomRight.y, endObb.bottomRight.y, durationInMs, delayInMs);
        }
        // Resizing
        setScreenWidth(screenWidthInPx) {
            super.setScreenWidth(screenWidthInPx);
            this.canvasDimensionsChanged = true;
        }
        setScreenHeight(screenHeightInPx) {
            super.setScreenHeight(screenHeightInPx);
            this.canvasDimensionsChanged = true;
        }
        // Getters and setters
        setBordersEnabled(bordersEnabled) {
            this.bordersCurrentlyEnabled = bordersEnabled;
        }
        isBordersEnabled() {
            return this.bordersCurrentlyEnabled;
        }
        setUseSoftBorders(useSoftBorders) {
            this.config.useSoftBorders = useSoftBorders;
        }
        isUsingSoftBorders() {
            return this.config.useSoftBorders;
        }
        getWorldDimensions() {
            return this.worldDimensions;
        }
    }
    exports.WorldCamera = WorldCamera;
    (function (WorldCamera) {
        class Config {
            constructor() {
                /**
                 * True, if collisions with the map borders are enabled.
                 *
                 * Default: true
                 */
                this.bordersEnabled = true;
                /**
                 * True, if the camera should collide softly with the map borders.
                 *
                 * Default: true
                 */
                this.useSoftBorders = true;
            }
        }
        WorldCamera.Config = Config;
    })(WorldCamera = exports.WorldCamera || (exports.WorldCamera = {}));
});
define("src/map/view/hud/objects/ScrollableContentObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_2, DisplayObjectContainer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ScrollableContentObject extends SceneObject_2.SceneObject {
        constructor(environment) {
            super(environment);
            this.container = new DisplayObjectContainer_3.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
        }
        // @Override
        getView() {
            return this.container;
        }
    }
    exports.ScrollableContentObject = ScrollableContentObject;
});
define("src/map/view/hud/objects/ScrollableObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/world/objects/WorldCamera", "src/map/view/hud/objects/ScrollableContentObject", "src/engine/general/AABB", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_3, WorldCamera_1, ScrollableContentObject_1, AABB_3, DisplayObjectContainer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ScrollableObject extends SceneObject_3.SceneObject {
        // Initialization
        constructor(environment, width, height) {
            super(environment);
            // Configuration
            this.horizontalScrollingEnabled = true;
            this.verticalScrollingEnabled = false;
            // Navigation
            this.panning = false;
            this.currentPosition = new PIXI.Point();
            this.currentPanVelocity = new PIXI.Point();
            // Create scene graph: Container -> Camera -> ContentView
            this.initContainer();
            this.initCamera(width, height);
            this.initContentView();
        }
        initContainer() {
            this.container = new DisplayObjectContainer_4.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
        }
        initCamera(width, height) {
            this.camera = new WorldCamera_1.WorldCamera(new WorldCamera_1.WorldCamera.Config(), this.getEnvironment(), width, height);
            this.camera.setBordersEnabled(true);
            this.camera.setUseSoftBorders(true);
            this.addChild(this.camera);
        }
        initContentView() {
            this.contentObject = new ScrollableContentObject_1.ScrollableContentObject(this.getEnvironment());
            this.camera.addChild(this.contentObject);
            this.updateContentObjectDimensions(new AABB_3.AABB(new PIXI.Point(), new PIXI.Point()));
        }
        // Configuration
        setHorizontalScrollingEnabled(enabled) {
            this.horizontalScrollingEnabled = enabled;
        }
        isHorizontalScrollingEnabled() {
            return this.horizontalScrollingEnabled;
        }
        setVerticalScrollingEnabled(enabled) {
            this.verticalScrollingEnabled = enabled;
        }
        isVerticalScrollingEnabled() {
            return this.verticalScrollingEnabled;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Content based methods
        getContentObject() {
            return this.contentObject;
        }
        // Should be called, whenever the content view has been changed.
        updateContentObjectDimensions(aabb) {
            let minX = Math.min(aabb.min.x, 0);
            let minY = Math.min(aabb.min.y, 0);
            let maxX = Math.max(aabb.max.x, this.camera.getScreenWidth());
            let maxY = Math.max(aabb.max.y, this.camera.getScreenHeight());
            let worldAabb = new AABB_3.AABB(new PIXI.Point(minX, minY), new PIXI.Point(maxX, maxY));
            this.camera.setWorldDimensions(worldAabb);
        }
        // User Event-Handling
        touchPointInsideContainer(x, y) {
            let localTouchPoint = this.getView().pixi().toLocal(new PIXI.Point(x, y));
            let minX = 0;
            let minY = 0;
            let maxX = this.camera.getScreenWidth();
            let maxY = this.camera.getScreenHeight();
            return localTouchPoint.x >= minX && localTouchPoint.x <= maxX &&
                localTouchPoint.y >= minX && localTouchPoint.y <= maxY;
        }
        // Can be used to mark specific areas in the container as not scrollable.
        // Default: Each area is scrollable.
        isInScrollableArea(x, y) {
            // Default implementation: return always true
            return true;
        }
        // @Override
        onPanningStart(x, y) {
            if (this.isInScrollableArea(x, y)) {
                if (this.touchPointInsideContainer(x, y)) {
                    this.panning = true;
                    if (this.isHorizontalScrollingEnabled()) {
                        this.currentPosition.x = x;
                    }
                    if (this.isVerticalScrollingEnabled()) {
                        this.currentPosition.y = y;
                    }
                    this.currentPanTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        // @Override
        onPanningMove(x, y) {
            if (this.panning) {
                // Translation
                let velocityX = 0;
                let velocityY = 0;
                if (this.isHorizontalScrollingEnabled()) {
                    velocityX = -(x - this.currentPosition.x);
                }
                if (this.isVerticalScrollingEnabled()) {
                    velocityX = -(y - this.currentPosition.y);
                }
                this.currentPanVelocity = new PIXI.Point(velocityX, velocityY);
                this.camera.translate(this.currentPanVelocity);
                // Save current position
                if (this.isHorizontalScrollingEnabled()) {
                    this.currentPosition.x = x;
                }
                if (this.isVerticalScrollingEnabled()) {
                    this.currentPosition.y = y;
                }
                // Update timestamp
                this.currentPanTimestampInMs = Date.now();
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.panning) {
                this.panning = false;
                this.addTranslationImpulse(this.currentPanVelocity);
                this.camera.setBordersEnabled(true);
                return true;
            }
            else {
                return false;
            }
        }
        addTranslationImpulse(translation) {
            // Decrease velocity if last pan move event was emitted a long time ago.
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentPanTimestampInMs;
            let referenceTimeDifferenceInMs = 10;
            let weight = Math.min(referenceTimeDifferenceInMs / timeDifferenceInMs, 1);
            translation.x *= weight;
            translation.y *= weight;
            this.camera.addTranslationImpulse(translation);
        }
        // Resizing
        /**
         * Resizes the scrollable object to the specified size
         * @param widthInPx target width in screen pixels.
         * @param heightInPx target height in screen pixels.
         */
        setSize(widthInPx, heightInPx) {
            this.camera.setScreenWidth(widthInPx);
            this.camera.setScreenHeight(heightInPx);
            this.updateContentObjectDimensions(this.camera.getWorldDimensions());
        }
        // Getters and setters
        isPanning() {
            return this.panning;
        }
    }
    exports.ScrollableObject = ScrollableObject;
});
define("src/engine/animation/LinearInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LinearInterpolator {
        getInterpolationValue(timeProgress) {
            return timeProgress;
        }
    }
    exports.LinearInterpolator = LinearInterpolator;
});
define("src/app/relution/view/hud/barLayer/Bar", ["require", "exports", "src/map/view/hud/objects/ScrollableObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, ScrollableObject_1, Animation_2, LinearInterpolator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Bar extends ScrollableObject_1.ScrollableObject {
        // Initialization
        constructor(environment, width, height) {
            super(environment, width, height);
            // View: Animation
            this.autoFadeEnabled = true;
            this.forceVisibleUntil = 0;
            // Controller
            this.mouseInsideBar = false;
            this.initAnimation();
        }
        initAnimation() {
            this.fadeAnimation = new Animation_2.Animation(new LinearInterpolator_1.LinearInterpolator());
            this.animateVisible(false, 1 * 1000);
        }
        // User: Input-Events
        // @Override
        onMouseIn(x, y) {
            this.forceVisibleUntil = Date.now() + Bar.FORCE_VISIBILITY_DURATION_IN_MS;
            this.animateVisible(true, 0);
            return false;
        }
        // @Override
        onMouseOut(x, y) {
            this.animateVisible(false, 0);
            return false;
        }
        // @Override
        onMouseMove(x, y) {
            if (this.touchPointInsideContainer(x, y)) {
                if (!this.mouseInsideBar) {
                    this.animateVisible(true, 0);
                    this.mouseInsideBar = true;
                }
            }
            else {
                if (this.mouseInsideBar) {
                    this.mouseInsideBar = false;
                    this.animateVisible(false, 1 * 1000);
                }
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            let handled = super.onTouchMove(x, y, touchIndex);
            if (!handled) {
                // Prevent touch move events to be handled on lower level layers
                // if user is inside the bar
                if (this.touchPointInsideContainer(x, y)) {
                    return true;
                }
            }
            else {
                return handled;
            }
        }
        // Animation
        animateVisible(visible, delayInMs) {
            this.animateVisibleWihDuration(visible, delayInMs, 200);
        }
        animateVisibleWihDuration(visible, delayInMs, durationInMs) {
            let startValue = this.getView().alpha;
            let endValue = 0;
            if (visible) {
                endValue = 1.0;
            }
            else {
                endValue = 0.0;
            }
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                this.fadeAnimation.stop();
            }
            this.fadeAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.isAutoFadeEnabled()) {
                let nowInMs = Date.now();
                if (this.forceVisibleUntil - nowInMs > 0) {
                    this.updateAlphaWithAnimation(lastFrametime);
                }
                else if (this.forceVisibleUntil !== 0) {
                    this.forceVisibleUntil = 0;
                    if (this.mouseInsideBar) {
                        this.animateVisible(true, 0);
                    }
                    else {
                        this.animateVisible(false, 0);
                    }
                }
                else {
                    this.updateAlphaWithAnimation(lastFrametime);
                }
            }
        }
        updateAlphaWithAnimation(lastFrametime) {
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.fadeAnimation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        // Getters and setters
        isAutoFadeEnabled() {
            return this.autoFadeEnabled;
        }
        setAutoFadeEnabled(enabled) {
            this.autoFadeEnabled = enabled;
        }
    }
    Bar.FORCE_VISIBILITY_DURATION_IN_MS = 2 * 1000;
    exports.Bar = Bar;
});
define("src/map/view/Layer", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_4, Animation_3, LinearInterpolator_2, DisplayObjectContainer_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Layer extends SceneObject_4.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // View: Animation
            this.animationDurationInMs = 200;
            this.inBackground = false;
            // Observation
            this.visiblitityObservers = new Array();
            this.container = new DisplayObjectContainer_5.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.fadeAnimation = new Animation_3.Animation(new LinearInterpolator_2.LinearInterpolator());
        }
        setContainer(container) {
            this.container = container;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Observation
        addVisiblityObserver(observer) {
            this.visiblitityObservers.push(observer);
        }
        removeVisibilityObserver(observer) {
            let index = this.visiblitityObservers.indexOf(observer);
            if (index > -1) {
                this.visiblitityObservers.splice(index, 1);
            }
        }
        notifyObserversAboutVisibilityChange(visible) {
            for (let i = 0; i < this.visiblitityObservers.length; i++) {
                let observer = this.visiblitityObservers[i];
                observer.visibilityChanged(this);
            }
        }
        // Layers
        addLayer(layer) {
            this.addChild(layer);
        }
        addLayerAtIndex(layer, index) {
            this.addLayer(layer);
            this.setLayerAtIndex(layer, index);
        }
        addLayerAfterLayer(layer, afterLayer) {
            this.addAfterObject(layer, afterLayer);
        }
        setLayerAtIndex(layer, index) {
            this.setChildIndex(layer, index);
        }
        removeLayer(layer) {
            this.removeChild(layer);
        }
        hasLayer(layer) {
            return this.hasChild(layer);
        }
        // Animations
        animateVisible(visible, callback) {
            let endValue = 0;
            if (visible) {
                endValue = this.getCurrentMaxAlpha();
            }
            else {
                endValue = 0.0;
            }
            if (callback !== undefined) {
                let fadeAnimation = this.fadeAnimation;
                let observer = {
                    animationDidStart(animation) { },
                    animationDidStop(animation) {
                        fadeAnimation.removeObserver(observer);
                        callback();
                    },
                    animationDidFinish(animation) {
                        fadeAnimation.removeObserver(observer);
                        callback();
                    }
                };
                this.fadeAnimation.addObserver(observer);
            }
            this.animateAlphaToValue(endValue);
        }
        animateAlphaToValue(targetAlpha) {
            let startValue = this.getView().alpha;
            let endValue = targetAlpha;
            let durationInMs = this.animationDurationInMs;
            let delayInMs = 0;
            if (startValue !== endValue) {
                this.fadeAnimation.start(startValue, endValue, durationInMs, delayInMs);
            }
            else {
                this.fadeAnimation.stop();
                this.setAlpha(endValue);
            }
        }
        setAlpha(alpha) {
            let alphaBefore = this.getView().alpha;
            this.getView().alpha = alpha;
            if (alpha === 0 && alphaBefore !== 0) {
                this.notifyObserversAboutVisibilityChange(false);
            }
            else if (alpha === 1 && alphaBefore !== 1) {
                this.notifyObserversAboutVisibilityChange(true);
            }
        }
        toggleVisibility() {
            let visible = !this.isVisible();
            this.animateVisible(visible);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.fadeAnimation.isCurrentlyAnimating()) {
                let currentValue = this.fadeAnimation.getValue(lastFrametime);
                this.setAlpha(currentValue);
            }
        }
        // Getters and setters
        isVisibleInWorld() {
            return this.getView().worldAlpha !== 0 && this.getView().alpha !== 0;
        }
        isVisible() {
            return this.getView().alpha !== 0;
        }
        setVisible(visible) {
            if (visible) {
                this.setAlpha(this.getCurrentMaxAlpha());
            }
            else {
                this.setAlpha(0.0);
            }
        }
        // Changes the max alpha value of this layer.
        setIsInBackground(inBackground) {
            this.inBackground = inBackground;
        }
        isInBackground() {
            return this.inBackground;
        }
        getCurrentMaxAlpha() {
            if (this.isInBackground()) {
                return 0.5;
            }
            else {
                return 1.0;
            }
        }
    }
    exports.Layer = Layer;
});
define("src/map/view/world/World", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class World extends Layer_1.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
            // View: Rendering
            this.lastCameraTransformMatrix = new PIXI.Matrix();
        }
        // Scene initialization
        // @Override
        initialize() {
            super.initialize();
            this.getScene().setRoundPixels(true);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScenePixelAlignment();
        }
        updateScenePixelAlignment() {
            // If world camera does not move, enable pixel alignment mode for this scene.
            let worldCamera = this.getScene().getCamera();
            let transformMatrix = worldCamera.getView().localTransform;
            // We use a hysteresis to to remove jittering.
            let movingThreshold = 0.01;
            let stillnessThreshold = 0.001;
            if (this.matrixDifferenceExceedsThreshold(transformMatrix, this.lastCameraTransformMatrix, movingThreshold)) {
                this.lastCameraTransformMatrix.a = transformMatrix.a;
                this.lastCameraTransformMatrix.b = transformMatrix.b;
                this.lastCameraTransformMatrix.c = transformMatrix.c;
                this.lastCameraTransformMatrix.d = transformMatrix.d;
                this.lastCameraTransformMatrix.tx = transformMatrix.tx;
                this.lastCameraTransformMatrix.ty = transformMatrix.ty;
                this.getScene().setRoundPixels(false);
            }
            else if (!this.matrixDifferenceExceedsThreshold(transformMatrix, this.lastCameraTransformMatrix, stillnessThreshold)) {
                this.getScene().setRoundPixels(true);
            }
        }
        matrixDifferenceExceedsThreshold(m1, m2, threshold) {
            return (Math.abs(m1.a - m2.a) > threshold ||
                Math.abs(m1.b - m2.b) > threshold ||
                Math.abs(m1.c - m2.c) > threshold ||
                Math.abs(m1.d - m2.d) > threshold ||
                Math.abs(m1.tx - m2.tx) > threshold ||
                Math.abs(m1.ty - m2.ty) > threshold);
        }
    }
    exports.World = World;
});
define("src/map/utils/Logger", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Logger {
        static logDebug(message) {
            if (Logger.loggingEnabled) {
                Logger.log("debug", message);
            }
        }
        static logVerbose(message) {
            if (Logger.loggingEnabled) {
                Logger.log("vbose", message);
            }
        }
        static log(level, message) {
            if (Logger.loggingEnabled) {
                Logger.doLog(level + " : " + message);
            }
        }
        static doLog(message) {
            if (Logger.loggingEnabled) {
                let time = new Date();
                let timeString = time.getHours() + ":" + time.getMinutes() + ":" + time.getSeconds();
                let totalMessage = timeString + ": " + message;
                Logger.logToConsole(totalMessage);
                // Logger.logToFile(totalMessage);
            }
        }
        static logLine() {
            if (Logger.loggingEnabled) {
                Logger.logDebug("---------------------------------------");
            }
        }
        static logToConsole(message) {
            if (Logger.loggingEnabled) {
                /* tslint:disable */
                console.log(message);
                /* tslint:enable */
            }
        }
    }
    Logger.loggingEnabled = false;
    exports.Logger = Logger;
});
define("src/app/relution/model/Model", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class for all model classes.
     *
     * To make inheritance work correctly while deserialization and serialization of JSON objects,
     * attach the @ModelTypeInfo and @ModelSubTypes decorator to make the resolution polymorphic.
     *
     * Attach the @ModelProperty to all the data fields that should be considered while
     * serializing or deserializing JSON objects using the {@code RelutionMapModelLoader} class.
     *
     * Use the {@code clazz} attribute in the options passed to your @ModelProperty, if the property
     * refers to a submodel that also extends from this base class.
     *
     * Observation:
     * All observers are notified if they have a corresponding callback handler
     * with the name: "<name>Changed".
     * After each callback "modelChanged" will be called.
     */
    class Model {
        constructor() {
            // Observers
            this.observers = new Array();
        }
        // Metaprogramming
        static getTypeFieldForModelClass(modelClass) {
            for (let i = 0; i < Model.modelClassToTypeFieldBinder.length; i++) {
                let binder = Model.modelClassToTypeFieldBinder[i];
                if (binder.modelClass === modelClass) {
                    return binder.typeField;
                }
            }
            return null;
        }
        static getModelClassForType(typeValue) {
            for (let i = 0; i < Model.modelClassTypeBinder.length; i++) {
                let binder = Model.modelClassTypeBinder[i];
                if (binder.type === typeValue) {
                    return binder.modelClassWrapperFunction();
                }
            }
            return null;
        }
        static getPropertyBindingsForObject(object) {
            let propertyBindings = [];
            for (let classConstructor of Array.from(this.modelClassConstructorToPropertyBinding.keys())) {
                if (object instanceof classConstructor) {
                    propertyBindings.push(this.modelClassConstructorToPropertyBinding.get(classConstructor));
                }
            }
            return propertyBindings;
        }
        // Updating
        /**
         * Updates all model attributes for which getters and setters exist
         * from the given model.
         * @param model The updated model
         */
        update(model) {
            let propertyNames = Object.getOwnPropertyNames(model);
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    if (propertyName.substring(0, 2) !== "__" && propertyName.substring(0, 1) === "_") {
                        let accessor = propertyName.substring(1);
                        this[accessor] = model[accessor];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Failed to update model attribute \"" + propertyName + "\"");
                }
            }
        }
        // Cloning
        /**
         * Clones the object and deeply copies all attributes for which
         * getters and setters exist.
         */
        clone() {
            // 1. Create new object of same type (functions will be copied).
            let newModel = Object.create(this.constructor.prototype);
            // 2. Get all attributes
            let propertyNames = Object.getOwnPropertyNames(this);
            // 3. Flatly copy all non-model attributes
            this.flatCloneNonModelAttributes(newModel, propertyNames);
            // 4. All observers should be removed
            newModel.observers = [];
            // 5. Deeply copy all model attributes.
            this.deepCloneModelAttributes(newModel, propertyNames);
            // Return clone
            return newModel;
        }
        flatCloneNonModelAttributes(newModel, propertyNames) {
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    if (propertyName.substring(0, 2) === "__") {
                        newModel[propertyName] = this[propertyName];
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        newModel[propertyName] = this[propertyName];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("flat cloning non model attributes failed.");
                }
            }
        }
        deepCloneModelAttributes(newModel, propertyNames) {
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    let accessor = null;
                    if (propertyName.substring(0, 2) === "__") {
                        accessor = propertyName.substring(2);
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        accessor = propertyName.substring(1);
                    }
                    try {
                        newModel[accessor] = JSON.parse(JSON.stringify(this[accessor]));
                    }
                    catch (e) {
                        newModel[accessor] = this[accessor];
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Deep cloning model attributes failed.");
                }
            }
        }
        // Equals
        /**
         * Returns true, if all attributes are equal in terms of the "===" operator.
         * @param o the object to compare.
         */
        equals(o) {
            if (o === null || o === undefined) {
                return false;
            }
            let propertyNames = Object.getOwnPropertyNames(o);
            if (propertyNames.length !== Object.getOwnPropertyNames(this).length) {
                return false;
            }
            for (let i = 0; i < propertyNames.length; i++) {
                let propertyName = propertyNames[i];
                try {
                    let accessor = null;
                    if (propertyName.substring(0, 2) === "__") {
                        accessor = propertyName.substring(2);
                    }
                    else if (propertyName.substring(0, 1) === "_") {
                        accessor = propertyName.substring(1);
                    }
                    if (this[accessor] !== o[accessor]) {
                        return false;
                    }
                }
                catch (e) {
                    Logger_1.Logger.logDebug("Failed to compare model attribute \"" + propertyName + "\"");
                }
            }
            return true;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index > -1) {
                this.observers.splice(index, 1);
            }
        }
        isObserver(observer) {
            for (let i = 0; i < this.observers.length; i++) {
                let o = this.observers[i];
                if (o === observer) {
                    return true;
                }
            }
            return false;
        }
        notifyObservers(propertyName) {
            let postfix = "Changed";
            let callbackName = propertyName + postfix;
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (typeof observer["" + callbackName] === "function") {
                    observer["" + callbackName].apply(observer, [this]);
                }
                let generalCallback = "model" + postfix;
                if (typeof observer["" + generalCallback] === "function") {
                    observer["" + generalCallback].apply(observer, [this]);
                }
            }
        }
    }
    // Metadata:
    // Binds the model classes to its type field used for polymorphic deserialization using the @ModelTypeInfo decorator.
    Model.modelClassToTypeFieldBinder = new Array();
    // Binds the model classes to its type value for poylmorphic deserialization.
    Model.modelClassTypeBinder = new Array();
    // Maps a property annotated with @ModelProperty the options object.
    Model.modelClassConstructorToPropertyBinding = new Map();
    exports.Model = Model;
    (function (Model) {
        class ModelClassTypeFieldBinder {
            constructor(modelClass, typeField) {
                this.modelClass = modelClass;
                this.typeField = typeField;
            }
        }
        Model.ModelClassTypeFieldBinder = ModelClassTypeFieldBinder;
    })(Model = exports.Model || (exports.Model = {}));
    // tslint:disable-next-line:max-classes-per-file
    class ModelType {
        constructor(modelClass, type) {
            this.modelClassWrapperFunction = modelClass;
            this.type = type;
        }
    }
    exports.ModelType = ModelType;
    // @ModelTypeInfo
    /**
     * Decorator function to allow polymorphic deserializations of model classes.
     * It binds all classes inheriting from the annotated class to the type field.
     * @param type
     */
    function ModelTypeInfo(type) {
        return function (modelClass) {
            Model.modelClassToTypeFieldBinder.push(new Model.ModelClassTypeFieldBinder(modelClass, type));
        };
    }
    exports.ModelTypeInfo = ModelTypeInfo;
    // @ModelSubTypes
    /**
     * Decorator function to allow polymorphic deserializations of model classes.
     * It maps the sub class's constructor to its corresponding type field value.
     * This decorator requires also the @ModelTypeInfo decorator to be specified.
     * @param modelTypes
     */
    function ModelSubTypes(...modelTypes) {
        return function (modelClass) {
            for (let i = 0; i < modelTypes.length; i++) {
                let modelType = modelTypes[i];
                Model.modelClassTypeBinder.push(modelType);
            }
        };
    }
    exports.ModelSubTypes = ModelSubTypes;
    // @ModelProperty
    /**
     * Decorator functions used for annotating properties in an inheriting model class.
     * All fields annotated with this decorator will be synced.
     */
    function ModelProperty(options = new ModelPropertyOptions()) {
        return (target, propertyKey) => {
            const clazz = target.constructor;
            if (!Model.modelClassConstructorToPropertyBinding.has(clazz)) {
                Model.modelClassConstructorToPropertyBinding.set(clazz, new ModelPropertyBinding());
            }
            let binding = Model.modelClassConstructorToPropertyBinding.get(clazz);
            binding.propertyNameToOption.set(propertyKey, options);
        };
    }
    exports.ModelProperty = ModelProperty;
    class ModelPropertyOptions {
        constructor() {
            /**
             * The class's constructor the property is based on.
             *
             * E.g. private _subModels: Array<SubModel>
             * is based on SubModel.
             *
             * Default: undefined
             */
            this.clazz = undefined;
            /**
             * During serialization and deserialization the property will not be searched
             * in the current JSON node but in the {@code findIn} child node.
             * If this is undefined, the property will be searched in the current JSON node while
             * traversing the the JSON tree.
             *
             * Default: undefined
             */
            this.findIn = undefined;
        }
    }
    exports.ModelPropertyOptions = ModelPropertyOptions;
    class ModelPropertyBinding {
        constructor() {
            this.propertyNameToOption = new Map();
        }
    }
    exports.ModelPropertyBinding = ModelPropertyBinding;
});
define("src/app/relution/model/RelutionMapModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class for all models in the Relution map.
     *
     * All model classes that should be serialized/deserialized using
     * the RelutionMapModelLoader class should inherit from this class,
     * as the UUID identifier is required to match JSON objects and the
     * internal RelutionMap models.
     */
    class RelutionMapModel extends Model_1.Model {
        constructor() {
            // Properties
            super(...arguments);
            /**
             * The model UUID
             */
            this._uuid = null;
        }
        // Getters and setters
        get uuid() {
            return this._uuid;
        }
        set uuid(uuid) {
            this._uuid = uuid;
            this.notifyObservers("uuid");
        }
    }
    __decorate([
        Model_1.ModelProperty()
    ], RelutionMapModel.prototype, "_uuid", void 0);
    exports.RelutionMapModel = RelutionMapModel;
});
define("src/app/relution/model/RelutionMapObjectModel", ["require", "exports", "src/app/relution/model/RelutionMapModel"], function (require, exports, RelutionMapModel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class for all models bound to a RelutionMapObject view.
     */
    class RelutionMapObjectModel extends RelutionMapModel_1.RelutionMapModel {
        constructor() {
            // Meta attributes
            super(...arguments);
            // Internal attributes
            /**
             * Two underscores, as we do not want it to be updated, when
             * the object is synced with a new version of it.
             */
            this.__visible = true;
        }
        // Getters and setters
        get visible() {
            return this.__visible;
        }
        set visible(visible) {
            this.__visible = visible;
            this.notifyObservers("visibility");
        }
        // Derived attributes
        /**
         * If the position is unknown, a view will not be created for this model.
         */
        hasUnknownPosition() {
            return false;
        }
        /**
         * Returns true, if the object is currently on the map.
         */
        isOnMap() {
            return true;
        }
        /**
         * Returns the UUID of the model this model existentially depends on.
         * This equals the value of the property annotated with @ModelProperty.
         * Returns null, if this model does not depend on any other model.
         *
         * Default: null
         */
        get parentUuid() {
            const propertyName = RelutionMapObjectModel.classNameToParentProperty.get(this.constructor.name);
            if (propertyName !== undefined) {
                const accessor = propertyName.substring(1);
                return this[accessor];
            }
            else {
                return null;
            }
        }
        /**
         * Sets the UUID of the model this model existentially depends on to {@code parentUuid}.
         * This equals setting the property annotated with @ModelProperty to {@code parentUuid}..
         */
        set parentUuid(parentUuid) {
            const propertyName = RelutionMapObjectModel.classNameToParentProperty.get(this.constructor.name);
            if (propertyName !== undefined) {
                const accessor = propertyName.substring(1);
                this[accessor] = parentUuid;
            }
        }
    }
    RelutionMapObjectModel.classNameToParentProperty = new Map();
    exports.RelutionMapObjectModel = RelutionMapObjectModel;
    // @ParentModel
    /**
     * Decorator functions used for annotating properties in an inheriting model class.
     * All fields annotated with this decorator will be synced.
     */
    function ParentModel() {
        return (target, propertyKey) => {
            RelutionMapObjectModel.classNameToParentProperty.set(target.constructor.name, propertyKey);
        };
    }
    exports.ParentModel = ParentModel;
});
define("src/app/relution/model/device/DeviceModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapObjectModel_1, Model_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class of all Relution device models.
     */
    let DeviceModel = class DeviceModel extends RelutionMapObjectModel_1.RelutionMapObjectModel {
        /**
         * Base class of all Relution device models.
         */
        constructor() {
            // General
            super(...arguments);
            this._name = "";
            // Details
            this._positionEstimate = null;
            // Properties
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._fixed = "";
            this._onMap = false;
            // Internal attributes
            this._inactive = false;
            this._userCount = 0;
        }
        // Getters and setters
        get name() {
            return this._name;
        }
        set name(name) {
            this._name = name;
            this.notifyObservers("name");
        }
        get status() {
            return this._status;
        }
        set status(status) {
            this._status = status;
            this.notifyObservers("status");
        }
        get platform() {
            return this._platform;
        }
        set platform(platform) {
            this._platform = platform;
            this.notifyObservers("platform");
        }
        get lastConnectionDate() {
            return this._lastConnectionDate;
        }
        set lastConnectionDate(lastConnectionDate) {
            this._lastConnectionDate = lastConnectionDate;
            this.notifyObservers("lastConnectionDate");
        }
        get deviceId() {
            return this._deviceId;
        }
        set deviceId(deviceId) {
            this._deviceId = deviceId;
            this.notifyObservers("deviceId");
        }
        get os() {
            return this._os;
        }
        set os(os) {
            this._os = os;
            this.notifyObservers("os");
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
        get z() {
            return this._z;
        }
        set z(z) {
            this._z = z;
            this.notifyObservers("z");
        }
        get fixed() {
            return this._fixed;
        }
        set fixed(fixed) {
            this._fixed = fixed;
            this.notifyObservers("fixed");
        }
        get onMap() {
            return this._onMap;
        }
        set onMap(onMap) {
            this._onMap = onMap;
            this.notifyObservers("onMap");
            if (this._onMap) {
                // Position has "changed", when device is set to map.
                this.x = this.x;
                this.y = this.y;
            }
        }
        get positionEstimate() {
            return this._positionEstimate;
        }
        set positionEstimate(positionEstimate) {
            this._positionEstimate = positionEstimate;
            this.notifyObservers("positionEstimate");
            // Since some devices use the position estimate field for obtaining the x
            // and y fields, we must call xChanged and yChanged.
            this.notifyObservers("x");
            this.notifyObservers("y");
        }
        get inactive() {
            return this._inactive;
        }
        set inactive(inactive) {
            this._inactive = inactive;
            this.notifyObservers("inactive");
        }
        get userCount() {
            return this._userCount;
        }
        set userCount(userCount) {
            this._userCount = userCount;
            this.notifyObservers("userCount");
        }
        // Derived attributes
        isBleNode() {
            return this._platform == "BLENODE";
        }
        isDumbBeacon() {
            return this._platform == "BEACON";
        }
        isMeshgw() {
            return this._platform == "EDGEROUTER";
        }
        isAsset() {
            return this._platform == "ASSET";
        }
        isAnyKindOfBeacon() {
            return this.isBleNode() || this.isDumbBeacon() || this.isMeshgw();
        }
        // Position
        getPosition() {
            // Take the position set by the user or, if it does not exist,
            // take the estimated position. If no position exist return the
            // coordinate system's origin.
            if (!this.userPositionIsUnknown()) {
                return new PIXI.Point(this._x, this._y);
            }
            else if (!this.positionEstimatePositionIsUnknown()) {
                return new PIXI.Point(this._positionEstimate.x, this._positionEstimate.y);
            }
            else {
                return new PIXI.Point();
            }
        }
        // @Override
        hasUnknownPosition() {
            return this.onMap && this.userPositionIsUnknown() && this.positionEstimatePositionIsUnknown();
        }
        userPositionIsUnknown() {
            if (this.platform == "ASSET" && this._x == 0.5 && this._y == 0.5) {
                return true;
            }
            return ((this._x == 0 && this._y == 0) ||
                (this._x == -1 && this._y == -1) ||
                ("undefined" === typeof this._x) && ("undefined" === typeof this._y));
        }
        positionEstimatePositionIsUnknown() {
            if (this.platform == "ASSET") {
                if (this._positionEstimate != null) {
                    return (this.positionEstimate.x == -1 && this._positionEstimate.y == -1)
                        || (("undefined" === typeof this.positionEstimate.x)) && ("undefined" === typeof this.positionEstimate.y);
                }
                else {
                    return true;
                }
            }
            else {
                if (this._positionEstimate != null) {
                    return ((this._positionEstimate.x == 0 && this._positionEstimate.y == 0)
                        || (this.positionEstimate.x == -1 && this._positionEstimate.y == -1)
                        || (("undefined" === typeof this.positionEstimate.x)) && ("undefined" === typeof this.positionEstimate.y));
                }
                else {
                    return true;
                }
            }
        }
        positionIsOutdoor(p) {
            return (p.x == 0 && p.y == 0) && this.onMap;
        }
        // On Map
        isOnMap() {
            return this.onMap;
        }
    };
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_name", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_status", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_platform", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_lastConnectionDate", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_deviceId", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], DeviceModel.prototype, "_os", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], DeviceModel.prototype, "_positionEstimate", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_x", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_y", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "properties", clazz: Number })
    ], DeviceModel.prototype, "_z", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "properties" })
    ], DeviceModel.prototype, "_fixed", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "properties", clazz: Boolean })
    ], DeviceModel.prototype, "_onMap", void 0);
    DeviceModel = __decorate([
        Model_2.ModelTypeInfo("platform"),
        Model_2.ModelSubTypes(new Model_2.ModelType(() => BleNodeModel, "BLENODE"), new Model_2.ModelType(() => BeaconModel, "BEACON"), new Model_2.ModelType(() => AssetModel, "ASSET"), new Model_2.ModelType(() => MeshGatewayModel, "EDGEROUTER"))
    ], DeviceModel);
    exports.DeviceModel = DeviceModel;
    (function (DeviceModel) {
        class PositionEstimate extends Model_2.Model {
            // Getters and setters
            get floorId() {
                return this._floorId;
            }
            set floorId(floorId) {
                this._floorId = floorId;
            }
            get x() {
                return this._x;
            }
            set x(x) {
                this._x = x;
            }
            get y() {
                return this._y;
            }
            set y(y) {
                this._y = y;
            }
            get accuracy() {
                return this._accuracy;
            }
            set accuracy(accuracy) {
                this._accuracy = accuracy;
            }
            get measurementTimeSec() {
                return this._measurementTimeSec;
            }
            set measurementTimeSec(measurementTimeSec) {
                this._measurementTimeSec = measurementTimeSec;
            }
        }
        __decorate([
            Model_2.ModelProperty()
        ], PositionEstimate.prototype, "_floorId", void 0);
        __decorate([
            Model_2.ModelProperty()
        ], PositionEstimate.prototype, "_x", void 0);
        __decorate([
            Model_2.ModelProperty()
        ], PositionEstimate.prototype, "_y", void 0);
        __decorate([
            Model_2.ModelProperty()
        ], PositionEstimate.prototype, "_accuracy", void 0);
        __decorate([
            Model_2.ModelProperty()
        ], PositionEstimate.prototype, "_measurementTimeSec", void 0);
        DeviceModel.PositionEstimate = PositionEstimate;
    })(DeviceModel = exports.DeviceModel || (exports.DeviceModel = {}));
    exports.DeviceModel = DeviceModel;
    // tslint:disable-next-line:max-classes-per-file
    class BeaconBaseModel extends DeviceModel {
        constructor() {
            // Properties
            super(...arguments);
            // Simulator related attributes
            this._connectionLossCounter = -1;
            this._inConnectionPartner = -1;
            this._inConnectionRssi = -1;
            this._inConnectionHasMasterBit = false;
            this._inConnectionPartnerHasMasterBit = false;
            this._lastSentMessageTimestampMs = 0;
            this._ledOn = false;
        }
        // Getters and setters
        get macAddress() {
            return this._macAddress;
        }
        set macAddress(macAddress) {
            this._macAddress = macAddress;
            this.notifyObservers("macAddress");
        }
        get dBmRX() {
            return this._dBmRX;
        }
        set dBmRX(dBmRX) {
            this._dBmRX = dBmRX;
            this.notifyObservers("dBmRX");
        }
        get dBmTX() {
            return this._dBmTX;
        }
        set dBmTX(dBmTX) {
            this._dBmTX = dBmTX;
            this.notifyObservers("dBmTX");
        }
        get calibratedRssi() {
            return this._calibratedRssi;
        }
        set calibratedRssi(calibratedRssi) {
            this._calibratedRssi = calibratedRssi;
            this.notifyObservers("calibratedRssi");
        }
        get manufacturerId() {
            return this._manufacturerId;
        }
        set manufacturerId(manufacturerId) {
            this._manufacturerId = manufacturerId;
            this.notifyObservers("manufacturerId");
        }
        get connectionLossCounter() {
            return this._connectionLossCounter;
        }
        set connectionLossCounter(connectionLossCounter) {
            this._connectionLossCounter = connectionLossCounter;
            this.notifyObservers("connectionLossCounter");
        }
        get inConnectionPartner() {
            return this._inConnectionPartner;
        }
        set inConnectionPartner(inConnectionPartner) {
            this._inConnectionPartner = inConnectionPartner;
            this.notifyObservers("inConnectionPartner");
        }
        get inConnectionRssi() {
            return this._inConnectionRssi;
        }
        set inConnectionRssi(inConnectionRssi) {
            this._inConnectionRssi = inConnectionRssi;
            this.notifyObservers("inConnectionRssi");
        }
        get inConnectionHasMasterBit() {
            return this._inConnectionHasMasterBit;
        }
        set inConnectionHasMasterBit(inConnectionHasMasterBit) {
            this._inConnectionHasMasterBit = inConnectionHasMasterBit;
            this.notifyObservers("inConnectionHasMasterBit");
        }
        get inConnectionPartnerHasMasterBit() {
            return this._inConnectionPartnerHasMasterBit;
        }
        set inConnectionPartnerHasMasterBit(inConnectionPartnerHasMasterBit) {
            this._inConnectionPartnerHasMasterBit = inConnectionPartnerHasMasterBit;
            this.notifyObservers("inConnectionPartnerHasMasterBit");
        }
        get lastSentAdvertisingMessage() {
            return this._lastSentAdvertisingMessage;
        }
        set lastSentAdvertisingMessage(lastSentAdvertisingMessage) {
            this._lastSentAdvertisingMessage = lastSentAdvertisingMessage;
            this.notifyObservers("lastSentAdvertisingMessage");
        }
        get lastSentMessageTimestampMs() {
            return this._lastSentMessageTimestampMs;
        }
        set lastSentMessageTimestampMs(lastSentMessageTimestampMs) {
            this._lastSentMessageTimestampMs = lastSentMessageTimestampMs;
            this.notifyObservers("lastSentMessageTimestampMs");
        }
        get ledOn() {
            return this._ledOn;
        }
        set ledOn(ledOn) {
            this._ledOn = ledOn;
            this.notifyObservers("ledOn");
        }
    }
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_manufacturerId", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_macAddress", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_dBmRX", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_dBmTX", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BeaconBaseModel.prototype, "_calibratedRssi", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_connectionLossCounter", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_inConnectionPartner", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_inConnectionRssi", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_inConnectionHasMasterBit", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_inConnectionPartnerHasMasterBit", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_lastSentAdvertisingMessage", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_lastSentMessageTimestampMs", void 0);
    __decorate([
        Model_2.ModelProperty()
    ], BeaconBaseModel.prototype, "_ledOn", void 0);
    exports.BeaconBaseModel = BeaconBaseModel;
    // tslint:disable-next-line:max-classes-per-file
    class SmartBeaconBaseModel extends BeaconBaseModel {
        // Getters and setters
        get chipId() {
            return this._chipId;
        }
        set chipId(chipId) {
            this._chipId = chipId;
            this.notifyObservers("chipId");
        }
        get nodeId() {
            return this._nodeId;
        }
        set nodeId(nodeId) {
            this._nodeId = nodeId;
            this.notifyObservers("nodeId");
        }
    }
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], SmartBeaconBaseModel.prototype, "_chipId", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], SmartBeaconBaseModel.prototype, "_nodeId", void 0);
    exports.SmartBeaconBaseModel = SmartBeaconBaseModel;
    // tslint:disable-next-line:max-classes-per-file
    class AssetModel extends SmartBeaconBaseModel {
        // Getters and setters
        get assetId() {
            return this._assetId;
        }
        set assetId(assetId) {
            this._assetId = assetId;
            this.notifyObservers("assetId");
        }
        //@Override
        get onMap() {
            return true;
        }
    }
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], AssetModel.prototype, "_assetId", void 0);
    exports.AssetModel = AssetModel;
    // tslint:disable-next-line:max-classes-per-file
    class BleNodeModel extends SmartBeaconBaseModel {
        // Getters and setters
        get nonConnections() {
            return this._nonConnections;
        }
        set nonConnections(nonConnections) {
            this._nonConnections = nonConnections;
            this.notifyObservers("nonConnections");
        }
        get connections() {
            return this._connections;
        }
        set connections(connections) {
            this._connections = connections;
            this.notifyObservers("connections");
        }
        get uptimeSeconds() {
            return this._uptimeSeconds;
        }
        set uptimeSeconds(uptimeSeconds) {
            this._uptimeSeconds = uptimeSeconds;
            this.notifyObservers("uptimeSeconds");
        }
        get version() {
            return this._version;
        }
        set version(version) {
            this._version = version;
            this.notifyObservers("version");
        }
        get clusterId() {
            return this._clusterId;
        }
        set clusterId(clusterId) {
            this._clusterId = clusterId;
            this.notifyObservers("clusterId");
        }
        get clusterSize() {
            return this._clusterSize;
        }
        set clusterSize(clusterSize) {
            this._clusterSize = clusterSize;
            this.notifyObservers("clusterSize");
        }
        get freeIn() {
            return this._freeIn;
        }
        set freeIn(freeIn) {
            this._freeIn = freeIn;
            this.notifyObservers("freeIn");
        }
        get freeOut() {
            return this._freeOut;
        }
        set freeOut(freeOut) {
            this._freeOut = freeOut;
            this.notifyObservers("freeOut");
        }
    }
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_nonConnections", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_connections", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_uptimeSeconds", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_version", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_clusterId", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_clusterSize", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_freeIn", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], BleNodeModel.prototype, "_freeOut", void 0);
    exports.BleNodeModel = BleNodeModel;
    // tslint:disable-next-line:max-classes-per-file
    class BeaconModel extends BeaconBaseModel {
    }
    exports.BeaconModel = BeaconModel;
    // tslint:disable-next-line:max-classes-per-file
    class MeshGatewayModel extends BleNodeModel {
        // Getters and setters
        get communicationBeacon() {
            return this._communicationBeacon;
        }
        set communicationBeacon(communicationBeacon) {
            this._communicationBeacon = communicationBeacon;
            this.notifyObservers("communicationBeacon");
        }
        get communicationBeaconUuid() {
            return this._communicationBeaconUuid;
        }
        set communicationBeaconUuid(communicationBeaconUuid) {
            this._communicationBeaconUuid = communicationBeaconUuid;
            this.notifyObservers("communicationBeaconUuid");
        }
    }
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], MeshGatewayModel.prototype, "_communicationBeacon", void 0);
    __decorate([
        Model_2.ModelProperty({ findIn: "details" })
    ], MeshGatewayModel.prototype, "_communicationBeaconUuid", void 0);
    exports.MeshGatewayModel = MeshGatewayModel;
});
define("src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FloorplanRelatedLayer extends Layer_2.Layer {
        constructor(environment, floorplanLayer) {
            super(environment);
            this.floorplanLayer = floorplanLayer;
        }
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
    }
    exports.FloorplanRelatedLayer = FloorplanRelatedLayer;
});
define("src/app/relution/model/floor/FloorModel", ["require", "exports", "src/app/relution/model/RelutionMapModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapModel_2, Model_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FloorModel extends RelutionMapModel_2.RelutionMapModel {
        constructor() {
            super(...arguments);
            this.wallplanImageUrl = null;
            this.floorplanOverlayNameToImageUrl = new Map();
            this.floorplanUsesSvg = false;
        }
    }
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "latitude", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "longitude", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "floorBaseInMeter", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "defaultSmartBeaconHeight", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "defaultAssetHeight", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "pixelPerMeter", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "lengthInMeter", void 0);
    __decorate([
        Model_3.ModelProperty()
    ], FloorModel.prototype, "orientation", void 0);
    exports.FloorModel = FloorModel;
});
define("src/map/utils/GraphicsUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GraphicsUtils {
        static getPowerTwoTextureSize(imageWidth, imageHeight) {
            let maxNumberPixels = Math.max(imageWidth, imageHeight);
            let powerTwoSize = 1;
            while (powerTwoSize < maxNumberPixels) {
                powerTwoSize *= 2;
            }
            return powerTwoSize;
        }
    }
    exports.GraphicsUtils = GraphicsUtils;
});
define("src/engine/rendering/objects/GraphicsObject", ["require", "exports", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, DisplayObjectContainer_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GraphicsObject extends DisplayObjectContainer_6.DisplayObjectContainer {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
        }
        // Decorating methods
        beginFill(color, alpha) {
            this.pixi().beginFill(color, alpha);
            this.environment.dirty = true;
        }
        drawRect(x, y, width, height) {
            this.pixi().drawRect(x, y, width, height);
            this.environment.dirty = true;
        }
        drawCircle(x, y, radius) {
            this.pixi().drawCircle(x, y, radius);
            this.environment.dirty = true;
        }
        drawEllipse(x, y, width, height) {
            this.pixi().drawEllipse(x, y, width, height);
            this.environment.dirty = true;
        }
        drawPolygon(path) {
            this.pixi().drawPolygon(path);
            this.environment.dirty = true;
        }
        moveTo(x, y) {
            this.pixi().moveTo(x, y);
            this.environment.dirty = true;
        }
        endFill() {
            this.pixi().endFill();
            this.environment.dirty = true;
        }
        clear() {
            this.pixi().clear();
            this.environment.dirty = true;
        }
        lineStyle(lineWidth, color, alpha) {
            this.pixi().lineStyle(lineWidth, color, alpha);
            this.environment.dirty = true;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.GraphicsObject = GraphicsObject;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/utils/GraphicsUtils", "src/engine/math/Vector2", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, FloorplanRelatedLayer_1, GraphicsUtils_1, Vector2_2, GraphicsObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AbstractFloorplanLayer extends FloorplanRelatedLayer_1.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorModel, texture) {
            super(environment, null);
            this.htmlImageElement = null;
            this.initModel(floorModel);
            this.initView(texture);
        }
        initModel(floorModel) {
            this.model = floorModel;
        }
        initView(texture) {
            this.initHtmlImageElement(texture);
            this.initBackgroundView();
        }
        initHtmlImageElement(texture) {
            // Set html image element
            this.htmlImageElement = texture.baseTexture.source;
            let powerTwoTextureSize = GraphicsUtils_1.GraphicsUtils.getPowerTwoTextureSize(this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight);
            this.htmlImageElement.width = powerTwoTextureSize;
            this.htmlImageElement.height = powerTwoTextureSize;
        }
        initBackgroundView() {
            // The background view is needed to span the view container as big as the floor size.
            this.backgroundView = new GraphicsObject_1.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.beginFill(0x000000, 0);
            this.backgroundView.drawRect(0, 0, 1, 1);
            this.backgroundView.endFill();
            // Scaling
            this.backgroundView.width = this.getFloorSize().x;
            this.backgroundView.height = this.getFloorSize().y;
            // Scene graph
            this.getView().addChild(this.backgroundView);
        }
        // View
        getFloorSize() {
            let width = this.htmlImageElement.naturalWidth;
            let height = this.htmlImageElement.naturalHeight;
            return new PIXI.Point(width, height);
        }
        getCurrentFloorSizeInScreenPx() {
            let camera = this.getScene().getCamera();
            let floorSizeInTx = this.getFloorSize();
            let widthInTx = floorSizeInTx.x;
            let heightInTx = floorSizeInTx.y;
            let point1InWorld = new PIXI.Point(0, 0);
            let point2InWorld = new PIXI.Point(widthInTx, 0);
            let point3InWorld = new PIXI.Point(0, heightInTx);
            let point1InScreen = camera.getImageCoordinateFromWorldPoint(point1InWorld);
            let point2InScreen = camera.getImageCoordinateFromWorldPoint(point2InWorld);
            let point3InScreen = camera.getImageCoordinateFromWorldPoint(point3InWorld);
            let widthInPx = Vector2_2.Vector2.getLengthOfPoint(new PIXI.Point(point1InScreen.x - point2InScreen.x, point1InScreen.y - point2InScreen.y));
            let heightInPx = Vector2_2.Vector2.getLengthOfPoint(new PIXI.Point(point1InScreen.x - point3InScreen.x, point1InScreen.y - point3InScreen.y));
            return new PIXI.Point(widthInPx, heightInPx);
        }
        // Model updating
        getModel() {
            return this.model;
        }
    }
    exports.AbstractFloorplanLayer = AbstractFloorplanLayer;
});
define("src/map/utils/Language", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Language {
        // Options
        static setOptions(object, defaultOptions, options) {
            if (options) {
                for (let i in options) {
                    if (options.hasOwnProperty(i)) {
                        defaultOptions[i] = options[i];
                    }
                }
            }
            object.options = defaultOptions;
        }
        // Metaprogramming
        static getGetters(prototype) {
            return Object.keys(prototype).filter((name) => {
                return typeof Object.getOwnPropertyDescriptor(prototype, name)["get"] === "function";
            });
        }
        static getSetters(prototype) {
            return Object.keys(prototype).filter((name) => {
                return typeof Object.getOwnPropertyDescriptor(prototype, name)["set"] === "function";
            });
        }
    }
    exports.Language = Language;
});
define("src/map/view/world/layers/tileLayer/Tile", ["require", "exports", "src/engine/general/AABB"], function (require, exports, AABB_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Tile {
        constructor() {
            this.expired = false;
            this.replacingTiles = new Array();
            this.loaded = false;
            this.loadedCallbacks = new Array();
            this.id = Tile.lastId;
            Tile.lastId++;
        }
        equals(tile) {
            return this.id === tile.id;
        }
        getAabb(tileSizeInPx) {
            let tileSize = (tileSizeInPx * this.depthIndex);
            let tileMinWorldX = this.columnIndex * tileSize;
            let tileMinWorldY = this.rowIndex * tileSize;
            let tileMaxWorldX = tileMinWorldX + tileSize;
            let tileMaxWorldY = tileMinWorldY + tileSize;
            let tileAabb = new AABB_4.AABB(new PIXI.Point(tileMinWorldX, tileMinWorldY), new PIXI.Point(tileMaxWorldX, tileMaxWorldY));
            return tileAabb;
        }
        addLoadedCallback(loadedCallback) {
            this.loadedCallbacks.push(loadedCallback);
            if (this.loaded) {
                this.notifyCallbacksAboutLoaded();
            }
        }
        markAsLoaded() {
            this.loaded = true;
            this.notifyCallbacksAboutLoaded();
        }
        notifyCallbacksAboutLoaded() {
            for (let i = 0; i < this.loadedCallbacks.length; i++) {
                let loadedCallback = this.loadedCallbacks[i];
                loadedCallback();
            }
        }
        // Getters and setters
        getLogDepthIndex() {
            return Math.log(this.depthIndex) / Math.log(2);
        }
    }
    Tile.lastId = 0;
    exports.Tile = Tile;
});
define("src/map/view/world/layers/tileLayer/TileResponse", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileResponse {
        // Initialization
        constructor(tile, tileLoader) {
            this.tile = tile;
            this.tileLoader = tileLoader;
        }
        // Drawing
        drawTileOnCanvas() {
            return this.tileLoader.drawTileOnCanvas(this);
        }
        // Getters and setters
        getTile() {
            return this.tile;
        }
    }
    exports.TileResponse = TileResponse;
});
define("src/map/view/world/layers/tileLayer/TileLoader", ["require", "exports", "src/map/utils/Language"], function (require, exports, Language_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileLoader {
        // Initialization
        constructor(options) {
            Language_1.Language.setOptions(this, new TileLoader.Options(), options);
            this.createWhiteCanvas();
        }
        createWhiteCanvas() {
            this.emptyCanvas = document.createElement("canvas");
            let textureSize = this.options.tileSizeInPx;
            this.emptyCanvas.width = textureSize;
            this.emptyCanvas.height = textureSize;
            let ctx = this.emptyCanvas.getContext("2d");
            ctx.beginPath();
            ctx.rect(0, 0, this.emptyCanvas.width, this.emptyCanvas.height);
            ctx.fillStyle = "white";
            ctx.fill();
        }
        drawEmptyTileOnCanvas() {
            return this.emptyCanvas;
        }
        // Getters and setters
        getTileSizeInPx() {
            return this.options.tileSizeInPx;
        }
    }
    exports.TileLoader = TileLoader;
    (function (TileLoader) {
        class Options {
            constructor() {
                this.tileSizeInPx = 256;
            }
        }
        TileLoader.Options = Options;
    })(TileLoader = exports.TileLoader || (exports.TileLoader = {}));
});
define("src/map/view/world/layers/tileLayer/TilePainter", ["require", "exports", "src/engine/general/AABB"], function (require, exports, AABB_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TilePainter {
        // Initialization
        constructor(htmlImageElement, tileSizeInPx) {
            // Painting: Paint base
            this.htmlImageElement = null;
            this.htmlImageSrc = "";
            this.drawBordersAroundTiles = false;
            this.htmlImageElement = htmlImageElement;
            this.tileSizeInPx = tileSizeInPx;
        }
        // Drawing API
        drawCanvasForTile(tile) {
            let imageAabb = this.getImageAabb();
            let tileAabb = tile.getAabb(this.tileSizeInPx);
            let tileWidth = tileAabb.max.x - tileAabb.min.x;
            let tileHeight = tileAabb.max.y - tileAabb.min.y;
            let imageWidth = imageAabb.max.x - imageAabb.min.x;
            let imageHeight = imageAabb.max.y - imageAabb.min.y;
            if (tileAabb.innerIntersects(imageAabb)) {
                let canvas = this.createCanvas();
                let clippedMinX = Math.max(imageAabb.min.x, tileAabb.min.x);
                let clippedMinY = Math.max(imageAabb.min.y, tileAabb.min.y);
                let clippedMaxX = Math.min(imageAabb.max.x, tileAabb.max.x);
                let clippedMaxY = Math.min(imageAabb.max.y, tileAabb.max.y);
                let sx = clippedMinX;
                let sy = clippedMinY;
                let swidth = clippedMaxX - clippedMinX;
                let sheight = clippedMaxY - clippedMinY;
                let x = imageAabb.min.x <= tileAabb.min.x ? 0
                    : (imageAabb.min.x - tileAabb.min.x) * (this.tileSizeInPx / tileWidth);
                let y = imageAabb.min.y <= tileAabb.min.y ? 0
                    : (imageAabb.min.y - tileAabb.min.y) * (this.tileSizeInPx / tileHeight);
                let width = canvas.width * swidth / tileWidth;
                let height = canvas.height * sheight / tileHeight;
                let ctx = canvas.getContext("2d");
                ctx.drawImage(this.htmlImageElement, sx, sy, swidth, sheight, x, y, width, height);
                if (this.drawBordersAroundTiles) {
                    canvas.style.border = "1px solid #000000";
                    ctx.strokeRect(0, 0, canvas.width, canvas.height);
                }
                return canvas;
            }
            else {
                // Let the canvas be white.
                return null;
            }
        }
        getImageAabb() {
            let minWorldX = 0;
            let minWorldY = 0;
            let maxWorldX = this.htmlImageElement.naturalWidth;
            let maxWorldY = this.htmlImageElement.naturalHeight;
            return new AABB_5.AABB(new PIXI.Point(minWorldX, minWorldY), new PIXI.Point(maxWorldX, maxWorldY));
        }
        createCanvas() {
            let canvas = document.createElement("canvas");
            const textureSize = this.tileSizeInPx;
            canvas.width = textureSize;
            canvas.height = textureSize;
            return canvas;
        }
    }
    exports.TilePainter = TilePainter;
});
define("src/map/view/world/layers/tileLayer/LocalTileLoader", ["require", "exports", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/view/world/layers/tileLayer/TilePainter", "src/map/view/world/layers/tileLayer/TileResponse"], function (require, exports, TileLoader_1, TilePainter_1, TileResponse_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LocalTileLoader extends TileLoader_1.TileLoader {
        // Initialization
        constructor(source, options) {
            super(options);
            if (source instanceof HTMLImageElement) {
                this.htmlImageElement = source;
                this.initTilePainter();
            }
            else if (typeof source === "string") {
                let texture = PIXI.loader.resources["" + source].texture;
                this.htmlImageElement = texture.baseTexture.source;
                this.initTilePainter();
            }
            else {
                throw new Error("source has wrong type");
            }
        }
        initTilePainter() {
            this.tilePainter = new TilePainter_1.TilePainter(this.htmlImageElement, this.getTileSizeInPx());
        }
        // World dimensions
        // @Override
        getWorldWidth() {
            return this.htmlImageElement.naturalWidth;
        }
        // @Override
        getWorldHeight() {
            return this.htmlImageElement.naturalHeight;
        }
        // Tile loading
        loadTile(tile, responseCallback) {
            // Since the image is already loaded (local), we can immediately call the response callback.
            let tileResponse = new TileResponse_1.TileResponse(tile, this);
            responseCallback(tileResponse);
            return null;
        }
        cancelTile(tileImage) {
            // Tile loading cannot be canceled, because tiles are not loaded...
        }
        // Tile drawing
        drawTileOnCanvas(tileResponse) {
            let tile = tileResponse.getTile();
            let canvas = this.tilePainter.drawCanvasForTile(tile);
            if (!canvas) {
                canvas = this.drawEmptyTileOnCanvas();
            }
            return canvas;
        }
    }
    exports.LocalTileLoader = LocalTileLoader;
});
define("src/map/view/world/layers/tileLayer/TileReplacement", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileReplacement {
        constructor() {
            this.oldTiles = new Array();
            this.newTiles = new Array();
        }
    }
    exports.TileReplacement = TileReplacement;
});
define("src/map/view/world/layers/tileLayer/TileEngine", ["require", "exports", "src/engine/scene/GameObject", "src/map/view/world/layers/tileLayer/Tile", "src/map/view/world/layers/tileLayer/TileReplacement"], function (require, exports, GameObject_3, Tile_1, TileReplacement_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileEngine extends GameObject_3.GameObject {
        // Initialization
        constructor(config, environment, worldCamera, tileSizeInPx) {
            super(environment);
            this.lastPivot = new PIXI.Point();
            this.lastScale = new PIXI.Point();
            this.lastOrientation = 0;
            this.lastPosition = new PIXI.Point();
            this.currentVisibleTiles = new Array();
            this.lastVisibleTiles = new Array();
            this.tileReplacements = new Array();
            this.tilesToAdd = new Array();
            this.tilesToRemove = new Array();
            // Observers
            this.observers = new Array();
            this.config = config;
            this.worldCamera = worldCamera;
            this.tileSizeInPx = tileSizeInPx;
        }
        // Observation
        addTileEngineObserver(observer) {
            this.observers.push(observer);
        }
        onLoadTiles(tiles) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onLoadTiles(tiles);
            }
        }
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onReplaceTiles(tileReplacements);
            }
        }
        onUnloadTiles(tiles) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onUnloadTiles(tiles);
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.hasFrustumChanged()) {
                this.updateLastFrustum();
                this.updateCurrentlyVisibleTiles();
                if (this.tileVisibilityChanged()) {
                    this.updateTileReplacements();
                    this.updateTilesToAdd();
                    this.updateTilesToRemove();
                    if (this.tileReplacements.length !== 0) {
                        this.onReplaceTiles(this.tileReplacements);
                    }
                    if (this.tilesToAdd.length !== 0) {
                        this.onLoadTiles(this.tilesToAdd);
                    }
                    if (this.tilesToRemove.length !== 0) {
                        this.onUnloadTiles(this.tilesToRemove);
                    }
                    this.lastVisibleTiles = this.currentVisibleTiles;
                }
            }
        }
        hasFrustumChanged() {
            return this.lastPivot.x !== this.worldCamera.getPivotX() ||
                this.lastPivot.y !== this.worldCamera.getPivotY() ||
                this.lastScale.x !== this.worldCamera.getScaleX() ||
                this.lastScale.y !== this.worldCamera.getScaleY() ||
                this.lastOrientation !== this.worldCamera.getRotation() ||
                this.lastPosition.x !== this.worldCamera.getX() ||
                this.lastPosition.y !== this.worldCamera.getY();
        }
        updateLastFrustum() {
            this.lastPivot.x = this.worldCamera.getPivotX();
            this.lastScale.x = this.worldCamera.getScaleX();
            this.lastScale.y = this.worldCamera.getScaleY();
            this.lastOrientation = this.worldCamera.getRotation();
            this.lastPosition.x = this.worldCamera.getX();
            this.lastPosition.y = this.worldCamera.getY();
        }
        updateCurrentlyVisibleTiles() {
            // 1. Identify quadtree depth
            let depth = this.getQuadtreeDepth();
            // 2. Add new tiles
            let collidingTiles = [];
            let frustum = this.worldCamera.getFrustum();
            let frustumAabb = frustum.getObb().getAabb();
            let minColumn = Math.floor(frustumAabb.min.x / (this.tileSizeInPx * depth));
            let maxColumn = Math.floor(frustumAabb.max.x / (this.tileSizeInPx * depth));
            let minRow = Math.floor(frustumAabb.min.y / (this.tileSizeInPx * depth));
            let maxRow = Math.floor(frustumAabb.max.y / (this.tileSizeInPx * depth));
            for (let i = minColumn; i <= maxColumn; i++) {
                for (let j = minRow; j <= maxRow; j++) {
                    let columnIndex = i;
                    let rowIndex = j;
                    let depthIndex = depth;
                    let tile = this.getCurrentlyVisibleTile(columnIndex, rowIndex, depthIndex);
                    // Reuse tiles that were visible before to save performance
                    // and to ensure that the tile Id does not change until it will be removed.
                    if (!tile) {
                        tile = new Tile_1.Tile();
                        tile.columnIndex = i;
                        tile.rowIndex = j;
                        tile.depthIndex = depth;
                    }
                    collidingTiles.push(tile);
                }
            }
            // 4. Update currently visible tiles.
            this.currentVisibleTiles = collidingTiles;
        }
        getQuadtreeDepth() {
            // If scaleFactor = 1, we have achieved the quadtree's bottom layer.
            // So zooming further in does not increase the resolution.
            let depth = this.worldCamera.getScaleX();
            depth = Math.max(1, depth);
            depth = this.getNearestPowerOfTwo(depth);
            return depth;
        }
        getNearestPowerOfTwo(n) {
            let powerTwoSize = 1;
            while (powerTwoSize < n) {
                powerTwoSize *= 2;
            }
            if (this.config.loadTilesForRetinaDisplay) {
                powerTwoSize = Math.max(1, powerTwoSize / 2);
            }
            else {
                powerTwoSize = Math.max(1, powerTwoSize);
            }
            return powerTwoSize;
        }
        getCurrentlyVisibleTile(columnIndex, rowIndex, depthIndex) {
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let tile = this.currentVisibleTiles[i];
                if (tile.columnIndex === columnIndex && tile.rowIndex === rowIndex && tile.depthIndex === depthIndex) {
                    return tile;
                }
            }
            return null;
        }
        tileVisibilityChanged() {
            // Early out
            if (this.currentVisibleTiles.length !== this.lastVisibleTiles.length) {
                return true;
            }
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    return true;
                }
            }
            return false;
        }
        arrayContainsTile(tileArray, tile) {
            for (let i = 0; i < tileArray.length; i++) {
                let lastVisibleTile = tileArray[i];
                if (lastVisibleTile.equals(tile)) {
                    return true;
                }
            }
            return false;
        }
        updateTileReplacements() {
            this.tileReplacements = [];
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                // If tile was not visible before
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    let overlappingTiles = this.getOverlappingTilesForTile(currentVisibleTile, this.lastVisibleTiles);
                    // Iterate over all tiles that will cover the new tile
                    for (let j = 0; j < overlappingTiles.length; j++) {
                        let overlappingTile = overlappingTiles[j];
                        // The overlapping tile must be removed in this update cycle.
                        if (!this.arrayContainsTile(this.currentVisibleTiles, overlappingTile)) {
                            overlappingTile.expired = true;
                            overlappingTile.replacingTiles.push(currentVisibleTile);
                            this.addReplacementTuple(overlappingTile, currentVisibleTile);
                        }
                    }
                }
            }
            return this.tileReplacements;
        }
        getOverlappingTilesForTile(tile, tileArray) {
            let overlappingTiles = new Array();
            for (let i = 0; i < tileArray.length; i++) {
                let potentialOverlappingTile = tileArray[i];
                if (this.tileOverlapsTile(potentialOverlappingTile, tile)) {
                    overlappingTiles.push(potentialOverlappingTile);
                }
            }
            return overlappingTiles;
        }
        tileOverlapsTile(tile1, tile2) {
            // Solution 1: Exploiting quadtree properties
            // To save performance, we exploit the mathematical properties of the quadtree
            // instead of checking tile intersections.
            if (tile1.depthIndex === tile2.depthIndex) {
                return false;
            }
            let lowerTile = tile1.depthIndex < tile2.depthIndex ? tile1 : tile2;
            let higherTile = tile1.depthIndex < tile2.depthIndex ? tile2 : tile1;
            let depthFactor = higherTile.depthIndex / lowerTile.depthIndex;
            let lowerTileMinRow = higherTile.rowIndex * depthFactor;
            let lowerTileMaxRow = lowerTileMinRow + 1;
            let lowerTileMinCol = higherTile.columnIndex * depthFactor;
            let lowerTileMaxCol = lowerTileMinCol + 1;
            return (lowerTile.rowIndex === lowerTileMinRow || lowerTile.rowIndex === lowerTileMaxRow)
                && (lowerTile.columnIndex === lowerTileMinCol || lowerTile.columnIndex === lowerTileMaxCol);
            /*
            // Solution 2. Intersection test
            let tile1Aabb = tile1.getAabb(this.tileSizeInPx);
            let tile2Aabb = tile2.getAabb(this.tileSizeInPx);
            return tile1Aabb.innerIntersects(tile2Aabb);
            */
        }
        addReplacementTuple(oldTile, newTile) {
            let tileReplacement = this.getTileReplacementForTuple(oldTile, newTile);
            if (tileReplacement == null) {
                tileReplacement = new TileReplacement_1.TileReplacement();
                this.tileReplacements.push(tileReplacement);
            }
            if (!this.arrayContainsTile(tileReplacement.newTiles, newTile)) {
                tileReplacement.newTiles.push(newTile);
            }
            if (!this.arrayContainsTile(tileReplacement.oldTiles, oldTile)) {
                tileReplacement.oldTiles.push(oldTile);
            }
        }
        getTileReplacementForTuple(oldTile, newTile) {
            for (let i = 0; i < this.tileReplacements.length; i++) {
                let tileReplacement = this.tileReplacements[i];
                if (this.arrayContainsTile(tileReplacement.oldTiles, oldTile)
                    || this.arrayContainsTile(tileReplacement.newTiles, newTile)) {
                    return tileReplacement;
                }
            }
            return null;
        }
        tileIsInReplacements(tile) {
            for (let i = 0; i < this.tileReplacements.length; i++) {
                let tileReplacement = this.tileReplacements[i];
                if (this.arrayContainsTile(tileReplacement.newTiles, tile)
                    || this.arrayContainsTile(tileReplacement.oldTiles, tile)) {
                    return true;
                }
            }
            return false;
        }
        updateTilesToAdd() {
            this.tilesToAdd = [];
            for (let i = 0; i < this.currentVisibleTiles.length; i++) {
                let currentVisibleTile = this.currentVisibleTiles[i];
                if (!this.arrayContainsTile(this.lastVisibleTiles, currentVisibleTile)) {
                    // Do not add to tilesToAdd list if tile will be replaced
                    if (!this.tileIsInReplacements(currentVisibleTile)) {
                        this.tilesToAdd.push(currentVisibleTile);
                    }
                }
            }
            return this.tilesToAdd;
        }
        updateTilesToRemove() {
            this.tilesToRemove = [];
            for (let i = 0; i < this.lastVisibleTiles.length; i++) {
                let lastVisibleTile = this.lastVisibleTiles[i];
                if (!this.arrayContainsTile(this.currentVisibleTiles, lastVisibleTile)) {
                    if (!this.tileIsInReplacements(lastVisibleTile)) {
                        lastVisibleTile.expired = true;
                        this.tilesToRemove.push(lastVisibleTile);
                    }
                }
            }
            return this.tilesToRemove;
        }
        // Getters and setters
        setTileSizeInPx(tileSizeInPx) {
            this.tileSizeInPx = tileSizeInPx;
        }
        getTileSizeInPx() {
            return this.tileSizeInPx;
        }
    }
    exports.TileEngine = TileEngine;
    (function (TileEngine) {
        class Config {
            constructor() {
                /**
                 * True, if the double number of tiles should be loaded and shrinked
                 * to make the tiles look more crispy on retina displays.
                 *
                 * Default: false
                 */
                this.loadTilesForRetinaDisplay = false;
            }
        }
        TileEngine.Config = Config;
    })(TileEngine = exports.TileEngine || (exports.TileEngine = {}));
});
define("src/engine/rendering/texture/BaseTexture", ["require", "exports", "src/engine/rendering/DecoratingObject"], function (require, exports, DecoratingObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BaseTexture extends DecoratingObject_3.DecoratingObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
        }
        // Decorating methods
        loadSource(source) {
            this.pixi().loadSource(source);
            this.environment.dirty = true;
        }
        // Decorating getters and setters
        set mipmap(mipmap) {
            let oldMipmap = this.pixi().mipmap;
            if (oldMipmap !== mipmap) {
                this.pixi().mipmap = mipmap;
                this.environment.dirty = true;
            }
        }
        get mipmap() {
            return this.pixi().mipmap;
        }
        set width(width) {
            let oldWidth = this.pixi().width;
            if (oldWidth !== width) {
                this.pixi().width = width;
                this.environment.dirty = true;
            }
        }
        get width() {
            return this.pixi().width;
        }
        set height(height) {
            let oldHeight = this.pixi().height;
            if (oldHeight !== height) {
                this.pixi().height = height;
                this.environment.dirty = true;
            }
        }
        get height() {
            return this.pixi().height;
        }
    }
    exports.BaseTexture = BaseTexture;
});
define("src/engine/rendering/texture/Texture", ["require", "exports", "src/engine/rendering/texture/BaseTexture", "src/engine/rendering/DecoratingObject"], function (require, exports, BaseTexture_1, DecoratingObject_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Texture extends DecoratingObject_4.DecoratingObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
            this._baseTexture = new BaseTexture_1.BaseTexture(baseObject.baseTexture, environment);
        }
        // Decorating methods
        destroy(destroyBase) {
            this.pixi().destroy(destroyBase);
            this.environment.dirty = true;
        }
        // Decorating getters and setters
        set width(width) {
            let oldWidth = this.pixi().width;
            if (oldWidth !== width) {
                this.pixi().width = width;
                this.environment.dirty = true;
            }
        }
        get width() {
            return this.pixi().width;
        }
        set height(height) {
            let oldHeight = this.pixi().height;
            if (oldHeight !== height) {
                this.pixi().height = height;
                this.environment.dirty = true;
            }
        }
        get height() {
            return this.pixi().height;
        }
        set baseTexture(baseTexture) {
            let oldBaseTexture = this.pixi().baseTexture;
            if (oldBaseTexture !== baseTexture.pixi()) {
                this.pixi().baseTexture = baseTexture.pixi();
                this.environment.dirty = true;
            }
        }
        get baseTexture() {
            this._baseTexture.setPixi(this.pixi().baseTexture);
            return this._baseTexture;
        }
    }
    exports.Texture = Texture;
});
define("src/engine/rendering/utils/ObservablePoint", ["require", "exports", "src/engine/rendering/DecoratingObject"], function (require, exports, DecoratingObject_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ObservablePoint extends DecoratingObject_5.DecoratingObject {
        set x(x) {
            let oldX = this.pixi().x;
            if (oldX !== x) {
                this.pixi().x = x;
                this.environment.dirty = true;
            }
        }
        get x() {
            return this.pixi().x;
        }
        set y(y) {
            let oldY = this.pixi().y;
            if (oldY !== y) {
                this.pixi().y = y;
                this.environment.dirty = true;
            }
        }
        get y() {
            return this.pixi().y;
        }
    }
    exports.ObservablePoint = ObservablePoint;
});
define("src/engine/rendering/objects/SpriteObject", ["require", "exports", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/texture/Texture", "src/engine/rendering/utils/ObservablePoint", "src/engine/rendering/objects/DisplayObject"], function (require, exports, DisplayObjectContainer_7, Texture_1, ObservablePoint_1, DisplayObject_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SpriteObject extends DisplayObjectContainer_7.DisplayObjectContainer {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
            this._texture = new Texture_1.Texture(this.pixi().texture, environment);
            this._anchor = new ObservablePoint_1.ObservablePoint(this.pixi().anchor, environment);
        }
        // Decorating getters and setters
        set texture(texture) {
            let oldTexture = this.pixi().texture;
            if (oldTexture !== texture.pixi()) {
                this.pixi().texture = texture.pixi();
                this.environment.dirty = true;
            }
        }
        get texture() {
            this._texture.setPixi(this.pixi().texture);
            return this._texture;
        }
        set tint(tint) {
            let oldTint = this.pixi().tint;
            if (oldTint !== tint) {
                this.pixi().tint = tint;
                this.environment.dirty = true;
            }
        }
        get tint() {
            return this.pixi().tint;
        }
        set filters(filters) {
            this.pixi().filters = filters;
            this.environment.dirty = true;
        }
        get filters() {
            return this.pixi().filters;
        }
        set anchor(anchor) {
            let oldAnchor = this.pixi().anchor;
            this.pixi().anchor = anchor.pixi();
            if (Math.abs(oldAnchor.x - anchor.x) > DisplayObject_2.DisplayObject.EPSILON ||
                Math.abs(oldAnchor.y - anchor.y) > DisplayObject_2.DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        get anchor() {
            this._anchor.setPixi(this.pixi().anchor);
            return this._anchor;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.SpriteObject = SpriteObject;
});
define("src/map/view/world/layers/tileLayer/TileObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/SpriteObject"], function (require, exports, SceneObject_5, Animation_4, LinearInterpolator_3, SpriteObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileObject extends SceneObject_5.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // Model
            this.tile = null;
            this.lastTile = null;
            this.initView();
            this.initAnimation();
        }
        initView() {
            this.tileSprite = new SpriteObject_1.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
        }
        initAnimation() {
            this.animation = new Animation_4.Animation(new LinearInterpolator_3.LinearInterpolator());
        }
        reset() {
            this.lastTile = this.tile;
            this.tile = null;
            this.tileSprite.alpha = 0.0;
            this.animation.stop();
            this.animation.removeObservers();
        }
        // View
        getView() {
            return this.tileSprite;
        }
        // Animation
        animateVisible(visible, stoppedCallback) {
            let startValue = this.getView().alpha;
            let endValue = visible ? 1.0 : 0.0;
            let durationInMs = 250;
            let delayInMs = 0;
            this.animation.removeObservers();
            if (stoppedCallback) {
                this.animation.addObserver({
                    animationDidStart: (animation) => { },
                    animationDidStop: (animation) => { stoppedCallback(animation); },
                    animationDidFinish: (animation) => { },
                });
            }
            this.animation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.animation.isCurrentlyAnimating()) {
                let currentAlpha = this.animation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        // Getters and setters
        setTile(tile) {
            this.tile = tile;
        }
        getTile() {
            return this.tile;
        }
        setLastTile(lastTile) {
            this.lastTile = lastTile;
        }
        getLastTile() {
            return this.lastTile;
        }
    }
    exports.TileObject = TileObject;
});
define("src/map/view/world/layers/tileLayer/TileLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/tileLayer/TileEngine", "src/map/view/world/layers/tileLayer/TileObject", "src/map/utils/Logger", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/texture/Texture", "src/engine/rendering/texture/BaseTexture"], function (require, exports, Layer_3, TileEngine_1, TileObject_1, Logger_2, GraphicsObject_2, Texture_2, BaseTexture_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileLayer extends Layer_3.Layer {
        // Initialization
        constructor(config, environment, tileLoader) {
            super(environment);
            this.updateIntervalInMs = 1;
            this.reservedFrametimeForTextureLoadingInPercent = 10;
            // Updating: Ready-to-load queue
            this.readyToLoadQueue = new Array();
            this.readyToLoadQueueChanged = false;
            this.lastRequestStartTimeMs = 0;
            // Updating: Loading queue
            this.loadingQueue = new Array();
            // Updating: Texture loading queue
            this.textureLoadingQueue = new Array();
            this.textureLoadingQueueChanged = false;
            this.screenCenterInWorld = null;
            this.lastTextureLoadingTimestampInMs = 0;
            this.newTextureCreated = false;
            this.config = config;
            this.tileLoader = tileLoader;
            this.initBackgroundView();
        }
        initBackgroundView() {
            // The background view is needed to span the view container as big as the tile layer is.
            this.backgroundView = new GraphicsObject_2.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.beginFill(0x000000, 0);
            this.backgroundView.drawRect(0, 0, 1, 1);
            this.backgroundView.endFill();
            // Scaling
            this.backgroundView.width = this.tileLoader.getWorldWidth();
            this.backgroundView.height = this.tileLoader.getWorldHeight();
            // Scene graph
            this.getView().addChild(this.backgroundView);
        }
        // @Override
        initialize() {
            super.initialize();
            this.initTileEngine();
            this.initTileObjectPool();
            this.initVisibleTileObjects();
        }
        initTileEngine() {
            let worldCamera = this.getScene().getCamera();
            this.tileEngine = new TileEngine_1.TileEngine(this.config.tileEngine, this.getEnvironment(), worldCamera, this.tileLoader.getTileSizeInPx());
            this.tileEngine.addTileEngineObserver(this);
        }
        initTileObjectPool() {
            // Pool Size
            // We define the pool size to be the triple amount of tiles visible in the screen,
            // to ensure that blending effects with overlapping tiles are also possible.
            // This is because when the camera switches from one depth layer to the next,
            // the lower layer shows 2*maxVisibleTilesInScreen tiles and the layer above 1*maxVisibleTilesInScreen.
            let screenWidth = window.screen.width;
            let screenHeight = window.screen.height;
            let tileSizeInPx = this.tileEngine.getTileSizeInPx();
            let maxVisibleTilesInScreen = ((screenWidth / tileSizeInPx) + 2) * (((screenHeight / tileSizeInPx) + 2));
            let poolSize = this.config.texturePoolSizeFactor * maxVisibleTilesInScreen;
            // Init pool
            this.tileObjectPool = new Array();
            for (let i = 0; i < poolSize; i++) {
                this.addTileObjectToPool();
            }
        }
        addTileObjectToPool() {
            let tileObject = this.createInitialTileObject();
            this.tileObjectPool.push(tileObject);
            this.addChild(tileObject);
        }
        createInitialTileObject() {
            let tileObject = new TileObject_1.TileObject(this.getEnvironment());
            let canvas = this.tileLoader.drawEmptyTileOnCanvas();
            let baseTexture = new BaseTexture_2.BaseTexture(new PIXI.BaseTexture(), this.getEnvironment().renderingEnvironment);
            // Mipmapping is disabled, because texSubImage2D causes weird blending effects
            // while zooming, when mipmapping is enabled.
            baseTexture.mipmap = false;
            let texture = new Texture_2.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            tileObject.getView().texture = new Texture_2.Texture(texture.pixi(), this.getEnvironment().renderingEnvironment);
            return tileObject;
        }
        initVisibleTileObjects() {
            this.visibleTileObjects = new Array();
        }
        // Event-Handling: Loading Tiles
        // @Override
        onLoadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.loadTile(tile);
            }
        }
        loadTile(tile) {
            this.loadTileAsync(tile, function (loadedTile, tileObject) {
                if (tileObject != null && tileObject.getTile() != null && loadedTile.id === tileObject.getTile().id) {
                    tileObject.getView().alpha = 1;
                }
            });
        }
        loadTileAsync(tile, completionCallback) {
            // Load tile object into GPU asynchronously
            let asyncLoadRequest = new TileLayer.AsyncLoadRequest(tile, completionCallback);
            // We use a FIFO data structure to sequentially handle the asynchronous loading requests.
            // To ensure that large queues will be handled in a minimum amount of time, we make use
            // of the expiration mechanism offered in the tile engine. Therefore, in large scale zooming
            // scenarios rapid tile replacements will lead to lots of tile expirations even before
            // they have been handled. Thus, the load requests referring to expired tiles will be skipped
            // in a minimum amount of time.
            this.readyToLoadQueue.push(asyncLoadRequest);
            this.readyToLoadQueueChanged = true;
        }
        // Event-Handling: Replacing Tiles
        // @Override
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < tileReplacements.length; i++) {
                const tileReplacement = tileReplacements[i];
                const oldTiles = tileReplacement.oldTiles;
                const newTiles = tileReplacement.newTiles;
                this.replaceTiles(oldTiles, newTiles);
            }
        }
        replaceTiles(oldTiles, newTiles) {
            let that = this;
            let numNewTilesLoaded = 0;
            let onTileLoaded = function (tile, tileObject) {
                // @Synchronized-Start
                numNewTilesLoaded++;
                if (numNewTilesLoaded === newTiles.length) {
                    // If some tiles have not been loaded due to expiration, we
                    // consider this replacement set to be cancelled. Therefore
                    // we unload all tiles that have benn loaded yet and will soon
                    // be replaced by other tiles. However, if all tiles have been loaded
                    // we ignore the expired flag of all tiles and complete the loading
                    // process by blending them over with the old tiles.
                    let visibleNewTileObjects = that.getVisibleTileObjectsForTiles(newTiles);
                    if (visibleNewTileObjects.length !== newTiles.length) {
                        for (let i = 0; i < newTiles.length; i++) {
                            let newTile = newTiles[i];
                            if (newTile.replacingTiles.length > 0) {
                                that.unloadTile(newTile);
                            }
                        }
                        visibleNewTileObjects = that.getVisibleTileObjectsForTiles(newTiles);
                    }
                    that.blendTileObjects(oldTiles, newTiles, visibleNewTileObjects);
                }
                // @Synchronized-End
            };
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                this.loadTileAsync(newTile, onTileLoaded);
            }
        }
        blendTileObjects(oldTiles, newTiles, animatingNewTileObjects) {
            // Animation Finished callback
            let that = this;
            let numAnimationsFinished = 0;
            let onAnimationEndCallback = function () {
                // @Synchronized-Start
                numAnimationsFinished++;
                if (numAnimationsFinished === animatingNewTileObjects.length) {
                    that.unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles);
                }
                // @Synchronized-End
            };
            let onAnimationStopped = function (animation) {
                // Will be called, when the animation has finished or when it has been cancelled,
                // which happens when the tile object is moved to the object pool.
                animation.removeObservers();
                onAnimationEndCallback();
            };
            if (animatingNewTileObjects.length > 0) {
                // Blend in new tile objects.
                for (let i = 0; i < animatingNewTileObjects.length; i++) {
                    let newTileObject = animatingNewTileObjects[i];
                    newTileObject.animateVisible(true, onAnimationStopped);
                }
            }
            else {
                // This case may happen if all new tiles have been unloaded before being
                // animated. In this case we do not need to blend them, because all
                // of them are already in the object pool or in reuse. Thus we
                // just unload the old tile objects.
                that.unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles);
            }
        }
        unloadOldTilesWhenFullRegionIsCoveredByNewerTiles(oldTiles, newTiles) {
            let replacingTiles = this.getReplacingTiles(newTiles);
            let that = this;
            let numReplacingTilesLoaded = 0;
            let replacingTileLoadedCallback = function () {
                numReplacingTilesLoaded++;
                if (numReplacingTilesLoaded === replacingTiles.length) {
                    that.informReplacedTilesAboutLoadedTiles(newTiles);
                    that.unloadTiles(oldTiles);
                }
            };
            // If the tiles have really been loaded or if we do
            // not have to wait until tiles of other layers fully
            // cover the region, we finish the loading process by
            // informing depending layers about the load completion
            // and unload the old tiles. Otherwise, we unload the
            // old tiles only until until the region has been
            // completely covered by tiles that will be replace our new tiles.
            if (this.tilesAreVisible(newTiles) || replacingTiles.length === 0) {
                this.informReplacedTilesAboutLoadedTiles(newTiles);
                this.unloadTiles(oldTiles);
            }
            else {
                // 1. Since the new tiles will be definitely replaced by
                // tiles of a newer layer, we can unload all of its tiles now
                // to prevent the algorithm to load lots of textures in
                // the GPU when the camera touches lots of layers
                // in a short period of time, which leads to a great
                // object pool expansion.
                this.unloadTiles(newTiles);
                // 2. Now wait until the region is fully covered
                // by newer tiles. Then inform the depending layers
                // about the load completion. This will ensure that
                // the upper most layer will be unloaded and only
                // the bottom most layer will be visible.
                for (let i = 0; i < replacingTiles.length; i++) {
                    let replacingTile = replacingTiles[i];
                    replacingTile.addLoadedCallback(replacingTileLoadedCallback);
                }
            }
        }
        getReplacingTiles(newTiles) {
            let replacingTiles = new Array();
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                if (newTile.replacingTiles != null) {
                    for (let j = 0; j < newTile.replacingTiles.length; j++) {
                        let replacingTile = newTile.replacingTiles[j];
                        replacingTiles.push(replacingTile);
                    }
                }
            }
            return replacingTiles;
        }
        tilesAreVisible(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                let tileObject = this.getVisibleTileObjectForTile(tile);
                if (tileObject == null) {
                    return false;
                }
            }
            return true;
        }
        informReplacedTilesAboutLoadedTiles(newTiles) {
            for (let i = 0; i < newTiles.length; i++) {
                let newTile = newTiles[i];
                newTile.markAsLoaded();
            }
        }
        unloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        // Event-Handling: Unloading Tiles
        // @Override
        onUnloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                const tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        unloadTile(tile) {
            // Unload tile object, (if already/yet exists)
            let tileObject = this.getVisibleTileObjectForTile(tile);
            if (tileObject != null) {
                this.unloadTileObject(tileObject);
            }
        }
        unloadTileObject(tileObject) {
            let index = this.visibleTileObjects.indexOf(tileObject);
            if (index > -1) {
                this.visibleTileObjects.splice(index, 1);
            }
            else {
                Logger_2.Logger.logVerbose("A tile object unload was requested, " +
                    "although the object was not visible before!");
            }
            this.tileObjectPool.push(tileObject);
            tileObject.reset();
        }
        // Helper methods
        getVisibleTileObjectsForTiles(tiles) {
            let tileObjects = new Array();
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                let tileObject = this.getVisibleTileObjectForTile(tile);
                if (tileObject != null) {
                    tileObjects.push(tileObject);
                }
            }
            return tileObjects;
        }
        getVisibleTileObjectForTile(tile) {
            for (let i = 0; i < this.visibleTileObjects.length; i++) {
                let tileObject = this.visibleTileObjects[i];
                let currentTile = tileObject.getTile();
                if (tile.equals(currentTile)) {
                    return tileObject;
                }
            }
            return null;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            // 1. TileEngine: Find intersections of camera and tiles in quadtree.
            this.tileEngine.update(lastFrametime);
            // 2. Reprioritize ready-to-load queue.
            this.reprioritizeReadyToLoadQueue();
            // 3. Handle ready-to-load queue
            this.handleReadyToLoadQueue();
            // 4. Abort expired tile loading requests
            this.abortExpiredRequests();
            // 5. Reprioritize texture loading queue
            this.reprioritizeTextureLoadingQueue();
            // 6. Handle texture loading queue
            this.handleTextureLoadingQueue();
        }
        // Updating: Repriorization ready-to-load queue
        reprioritizeReadyToLoadQueue() {
            if (this.readyToLoadQueueChanged) {
                this.readyToLoadQueueChanged = false;
                this.reprioritizeAsyncLoadRequestQueue(this.readyToLoadQueue);
            }
        }
        reprioritizeAsyncLoadRequestQueue(queue) {
            // The load requests that are near to the screen center will be prioritized higher.
            if (queue.length > 0) {
                this.precomputeScreenCenterInWorld();
                let currentStartIndex = 0;
                let currentDepthIndex = queue[0].tile.depthIndex;
                for (let i = 0; i < queue.length; i++) {
                    let asyncLoadRequest = queue[i];
                    if (currentDepthIndex !== asyncLoadRequest.tile.depthIndex) {
                        this.reprioritizeSubQueue(queue, currentStartIndex, i);
                        currentStartIndex = i;
                        currentDepthIndex = asyncLoadRequest.tile.depthIndex;
                    }
                }
                this.reprioritizeSubQueue(queue, currentStartIndex, queue.length);
            }
        }
        precomputeScreenCenterInWorld() {
            let worldCamera = this.getScene().getCamera();
            let screenCenterInImage = new PIXI.Point(worldCamera.getScreenWidth() / 2, worldCamera.getScreenHeight() / 2);
            this.screenCenterInWorld = this.getView().pixi().toLocal(screenCenterInImage);
        }
        reprioritizeSubQueue(queue, startIndex, endIndex) {
            // Copy shallow subqueue
            let subQueue = queue.slice(startIndex, endIndex);
            // Sort subqueue
            let that = this;
            subQueue.sort(function (request1, request2) {
                let distanceToScreenCenter1 = that.getDistanceToScreenCenter(request1.tile);
                let distanceToScreenCenter2 = that.getDistanceToScreenCenter(request2.tile);
                return distanceToScreenCenter1 - distanceToScreenCenter2;
            });
            // Remove unsorted queue
            queue.splice(startIndex, endIndex - startIndex);
            // Insert sorted queue
            this.insertToQueue(queue, startIndex, subQueue);
        }
        getDistanceToScreenCenter(tile) {
            if ("squaredDistanceToScreenCenter" in tile) {
                return tile.squaredDistanceToScreenCenter;
            }
            else {
                let tileSizeInPx = this.tileEngine.getTileSizeInPx();
                let tileX = tile.columnIndex * tileSizeInPx * tile.depthIndex;
                let tileY = tile.rowIndex * tileSizeInPx * tile.depthIndex;
                let screenCenterInWorld = this.screenCenterInWorld;
                let diffX = screenCenterInWorld.x - tileX;
                let diffY = screenCenterInWorld.y - tileY;
                let squaredDistanceToScreenCenter = diffX * diffX + diffY * diffY;
                tile.squaredDistanceToScreenCenter = squaredDistanceToScreenCenter;
                return squaredDistanceToScreenCenter;
            }
        }
        insertToQueue(queue, startIndex, subQueue) {
            Array.prototype.splice.apply(queue, [startIndex, 0].concat(subQueue));
            return queue;
        }
        // Updating: Handle ready-to-load queue
        handleReadyToLoadQueue() {
            // Throttle asynchronous load requests on the client side.
            // Otherwise the server may throttle us (much heavier).
            const accumulatedTimeSinceLastRequestInMs = Date.now() - this.lastRequestStartTimeMs;
            const timeDiffBetweenLoadRequestsInMs = this.updateIntervalInMs;
            if (accumulatedTimeSinceLastRequestInMs > timeDiffBetweenLoadRequestsInMs) {
                // Remove expired requests to be sure that the first
                // element is definitely unexpired.
                this.removeExpiredRequestsFromReadyToLoadQueue();
                if (this.readyToLoadQueue.length > 0) {
                    this.lastRequestStartTimeMs = Date.now();
                    // Remove load request from ready-to-load queue.
                    let asyncLoadRequest = this.readyToLoadQueue[0];
                    this.readyToLoadQueue.splice(0, 1);
                    // Add to loading queue
                    this.loadingQueue.push(asyncLoadRequest);
                    // Start loading
                    this.startLoadingTile(asyncLoadRequest);
                }
            }
        }
        removeExpiredRequestsFromReadyToLoadQueue() {
            for (let i = 0; i < this.readyToLoadQueue.length; i++) {
                let request = this.readyToLoadQueue[i];
                if (request.tile.expired) {
                    this.readyToLoadQueue.splice(i, 1);
                    i--;
                    request.completionCallback(request.tile, null);
                }
            }
        }
        startLoadingTile(request) {
            let tile = request.tile;
            request.tileRequest = this.tileLoader.loadTile(tile, (tileResponse) => {
                // On completion, remove request from loading queue and
                // add to texture loading queue.
                let index = this.loadingQueue.indexOf(request);
                if (index > -1) {
                    this.loadingQueue.splice(index, 1);
                    request.tileResponse = tileResponse;
                    this.textureLoadingQueue.push(request);
                    this.textureLoadingQueueChanged = true;
                }
                else {
                    Logger_2.Logger.logVerbose("Removing asynchronous load request "
                        + "from loading queue not possible!");
                }
            });
        }
        // Updating: Handle expired load requests
        abortExpiredRequests() {
            for (let i = 0; i < this.loadingQueue.length; i++) {
                let request = this.loadingQueue[i];
                if (request.tile.expired) {
                    this.loadingQueue.splice(i, 1);
                    i--;
                    this.tileLoader.cancelTile(request.tileRequest);
                    request.completionCallback(request.tile, null);
                }
            }
        }
        // Updating: Repriorization texture loading queue
        reprioritizeTextureLoadingQueue() {
            if (this.textureLoadingQueueChanged) {
                this.textureLoadingQueueChanged = false;
                this.reprioritizeAsyncLoadRequestQueue(this.textureLoadingQueue);
            }
        }
        // Updating: Handle texture loading queue
        handleTextureLoadingQueue() {
            // We reduce the amount of tile loads to a certain fraction of frame time
            // to keep zooming smooth.
            let now = Date.now();
            const targetFrametimeInMs = (1.0 / 60) * 1000;
            if (now - this.lastTextureLoadingTimestampInMs > targetFrametimeInMs) {
                // We reserve 10% of CPU time per frame for texture loading.
                let reservedTimeForTileLoadingInMs = targetFrametimeInMs * (this.reservedFrametimeForTextureLoadingInPercent / 100);
                let beforeInMs = Date.now();
                this.newTextureCreated = false;
                while (this.textureLoadingQueue.length > 0
                    && Date.now() - beforeInMs < reservedTimeForTileLoadingInMs && !this.newTextureCreated) {
                    let asyncLoadRequest = this.textureLoadingQueue[0];
                    this.textureLoadingQueue.splice(0, 1);
                    this.loadTextureToGpu(asyncLoadRequest);
                }
                this.lastTextureLoadingTimestampInMs = Date.now();
            }
        }
        loadTextureToGpu(asyncLoadRequest) {
            let tile = asyncLoadRequest.tile;
            let tileResponse = asyncLoadRequest.tileResponse;
            let completionCallback = asyncLoadRequest.completionCallback;
            let tileObject = null;
            // First check if tile object has not been expired before.
            // If it has been expired, we skip the loading procedure and
            // pass the callback a null pointer.
            if (!tile.expired) {
                // If tile is still in cache/object pool, reuse it, otherwise load it.
                tileObject = this.getTileObjectInPoolForTile(tile);
                if (tileObject != null) {
                    tileObject = this.removeTileObjectInPool(tileObject);
                }
                else {
                    tileObject = this.pullOldestTileObjectFromPool();
                    this.loadTileObjectFromTileReponse(tileObject, tileResponse);
                }
                this.visibleTileObjects.push(tileObject);
                this.initTileObject(tileObject, tile);
            }
            // Completion callback
            if (completionCallback != null) {
                completionCallback(tile, tileObject);
            }
        }
        getTileObjectInPoolForTile(tile) {
            for (let i = 0; i < this.tileObjectPool.length; i++) {
                let tileObject = this.tileObjectPool[this.tileObjectPool.length - 1 - i];
                let lastTile = tileObject.getLastTile();
                if (lastTile != null
                    && tile.columnIndex === lastTile.columnIndex
                    && tile.rowIndex === lastTile.rowIndex
                    && tile.depthIndex === lastTile.depthIndex) {
                    return tileObject;
                }
            }
            return null;
        }
        removeTileObjectInPool(tileObject) {
            let index = this.tileObjectPool.indexOf(tileObject);
            if (index > -1) {
                this.tileObjectPool.splice(index, 1);
            }
            else {
                Logger_2.Logger.logVerbose("Removing tile object from pool failed, " +
                    "because object is not in pool anymore!");
            }
            return tileObject;
        }
        pullOldestTileObjectFromPool() {
            // Increase the pool size by creating new tile objects if necessary.
            if (this.tileObjectPool.length === 0) {
                this.addTileObjectToPool();
                // Since new textures will be loaded to the GPU in the rendering phase
                // and not in the loadSource method of BaseTexture, we mark this
                // frame as completed and will not allow other textures to be loaded
                // in this frame to preserve smooth zooming.
                this.newTextureCreated = true;
                Logger_2.Logger.logVerbose("Added tile object to pool.");
                Logger_2.Logger.logVerbose("Current pool size: " + this.tileObjectPool.length);
                Logger_2.Logger.logVerbose("Current visible tiles size: " + this.visibleTileObjects.length);
            }
            // Pull oldest tile object
            let tileObject = this.tileObjectPool[0];
            this.tileObjectPool.splice(0, 1);
            return tileObject;
        }
        loadTileObjectFromTileReponse(tileObject, tileResponse) {
            // Get base texture
            let baseTexture = tileObject.getView().texture.baseTexture;
            // Drawing
            let canvas = tileResponse.drawTileOnCanvas();
            // Updates texture using gl.texSubImage2D
            // Thus, texture objects in OpenGL will be reused, so no
            // create and destroy operations are necessary.
            // After conducting some benchmark tests, however, we did not
            // experience significant performance improvements compared
            // to gl.texImage2D.
            baseTexture.loadSource(canvas);
        }
        initTileObject(tileObject, tile) {
            // Set tile
            tileObject.setTile(tile);
            // Position
            let tileSizeInPx = this.tileEngine.getTileSizeInPx();
            tileObject.getView().x = tile.columnIndex * tileSizeInPx * tile.depthIndex;
            tileObject.getView().y = tile.rowIndex * tileSizeInPx * tile.depthIndex;
            // Scale
            tileObject.getView().scale.x = tile.depthIndex;
            tileObject.getView().scale.y = tile.depthIndex;
            // Alpha
            tileObject.getView().alpha = 0;
            // Z-ordering. Is efficient because internally pixi uses linked lists
            // for saving the children of a display object.
            this.getView().removeChild(tileObject.getView());
            this.getView().addChild(tileObject.getView());
        }
    }
    exports.TileLayer = TileLayer;
    (function (TileLayer) {
        class Config {
            constructor() {
                /**
                 * Determines the number of textures reserved for the tile layer.
                 * More specifically, this factor will be multiplied by the maximum
                 * number of tiles possible to display on the canvas.
                 *
                 * Default: 3
                 */
                this.texturePoolSizeFactor = 3;
                /**
                 * The tile engine configuration
                 */
                this.tileEngine = new TileEngine_1.TileEngine.Config();
            }
        }
        TileLayer.Config = Config;
        class AsyncLoadRequest {
            constructor(tile, completionCallback) {
                this.tile = tile;
                this.tileResponse = null;
                this.completionCallback = completionCallback;
            }
        }
        TileLayer.AsyncLoadRequest = AsyncLoadRequest;
    })(TileLayer = exports.TileLayer || (exports.TileLayer = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/map/view/world/layers/tileLayer/LocalTileLoader", "src/map/view/world/layers/tileLayer/TileLayer"], function (require, exports, AbstractFloorplanLayer_1, LocalTileLoader_1, TileLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileBasedFloorplanLayer extends AbstractFloorplanLayer_1.AbstractFloorplanLayer {
        // Initialization
        constructor(config, environment, floorModel, texture) {
            super(environment, floorModel, texture);
            this.config = config;
            this.initTileLoader();
            this.initTileLayer();
        }
        initTileLoader() {
            this.tileLoader = new LocalTileLoader_1.LocalTileLoader(this.htmlImageElement, {
                tileSizeInPx: this.config.tileSizeInPx
            });
        }
        initTileLayer() {
            this.tileLayer = new TileLayer_1.TileLayer(this.config.tileLayer, this.getEnvironment(), this.tileLoader);
            this.addChild(this.tileLayer);
        }
    }
    exports.TileBasedFloorplanLayer = TileBasedFloorplanLayer;
    (function (TileBasedFloorplanLayer) {
        class Config {
            constructor() {
                /**
                 * The tile size (in texels)
                 *
                 * Default: 256
                 */
                this.tileSizeInPx = 256;
                /**
                 * The configuration of the tile layer
                 */
                this.tileLayer = new TileLayer_1.TileLayer.Config();
            }
        }
        TileBasedFloorplanLayer.Config = Config;
    })(TileBasedFloorplanLayer = exports.TileBasedFloorplanLayer || (exports.TileBasedFloorplanLayer = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/map/utils/GraphicsUtils", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture", "src/engine/rendering/texture/BaseTexture"], function (require, exports, AbstractFloorplanLayer_2, GraphicsUtils_2, SpriteObject_2, Texture_3, BaseTexture_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ImageBasedFloorplanLayer extends AbstractFloorplanLayer_2.AbstractFloorplanLayer {
        // Initialization
        constructor(environment, floorModel, texture) {
            super(environment, floorModel, texture);
            this.initImageBasedView();
        }
        initImageBasedView() {
            this.initSprite();
            this.initCanvas();
            this.loadTextureFromCanvas();
        }
        initSprite() {
            this.floorplanImage = new SpriteObject_2.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.floorplanImage);
        }
        initCanvas() {
            this.createCanvas();
            this.drawImageToCanvas();
        }
        createCanvas() {
            this.canvas = document.createElement("canvas");
            let powerTwoTextureSize = GraphicsUtils_2.GraphicsUtils.getPowerTwoTextureSize(this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight);
            this.canvas.width = powerTwoTextureSize;
            this.canvas.height = powerTwoTextureSize;
            return this.canvas;
        }
        drawImageToCanvas() {
            let ctx = this.canvas.getContext("2d");
            ctx.drawImage(this.htmlImageElement, 0, 0, this.htmlImageElement.naturalWidth, this.htmlImageElement.naturalHeight, 0, 0, this.canvas.width, this.canvas.height);
        }
        loadTextureFromCanvas() {
            let baseTexture = new BaseTexture_3.BaseTexture(new PIXI.BaseTexture(this.canvas), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_3.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            texture.baseTexture.mipmap = true;
            this.floorplanImage.texture = new Texture_3.Texture(texture.pixi(), this.getEnvironment().renderingEnvironment);
            this.floorplanImage.width = this.htmlImageElement.naturalWidth;
            this.floorplanImage.height = this.htmlImageElement.naturalHeight;
        }
        getSize() {
            return new PIXI.Point(this.floorplanImage.width, this.floorplanImage.height);
        }
    }
    exports.ImageBasedFloorplanLayer = ImageBasedFloorplanLayer;
});
define("src/map/utils/SystemUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SystemUtils {
        static getOperatingSystem() {
            let os = SystemUtils.OperatingSystem.UNKNOWN;
            if (window.navigator.userAgent.indexOf("Windows NT 10.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_10;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.2") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_8;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.1") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_7;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 6.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_VISTA;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 5.1") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_XP;
            }
            else if (window.navigator.userAgent.indexOf("Windows NT 5.0") !== -1) {
                os = SystemUtils.OperatingSystem.WINDOWS_2000;
            }
            else if (window.navigator.userAgent.indexOf("Mac") !== -1) {
                os = SystemUtils.OperatingSystem.MAC;
            }
            else if (window.navigator.userAgent.indexOf("X11") !== -1) {
                os = SystemUtils.OperatingSystem.UNIX;
            }
            else if (window.navigator.userAgent.indexOf("Linux") !== -1) {
                os = SystemUtils.OperatingSystem.LINUX;
            }
            return os;
        }
        static isRetinaDisplay() {
            let retina = (window.devicePixelRatio || ((window.screen).deviceXDPI / (window.screen).logicalXDPI)) > 1;
            return retina;
        }
        static getBrowser() {
            if (this.isOpera()) {
                return SystemUtils.Browser.OPERA;
            }
            else if (this.isFirefox()) {
                return SystemUtils.Browser.FIREFOX;
            }
            else if (this.isSafari()) {
                return SystemUtils.Browser.SAFARI;
            }
            else if (this.isIE()) {
                return SystemUtils.Browser.IE;
            }
            else if (this.isChrome()) {
                return SystemUtils.Browser.CHROME;
            }
            else {
                return SystemUtils.Browser.UNKNOWN;
            }
        }
        static isOpera() {
            return (!!window['opr'] && !!window['opr'].addons) || !!window['opera'] || navigator.userAgent.indexOf(' OPR/') >= 0;
        }
        static isFirefox() {
            //noinspection TypeScriptUnresolvedVariable
            return typeof InstallTrigger !== 'undefined';
        }
        static isSafari() {
            return /constructor/i.test(window['HTMLElement']) || ((p) => {
                return p.toString() === "[object SafariRemoteNotification]";
            })(!window['safari'] || window['safari'].pushNotification);
        }
        static isIE() {
            return /*@cc_on!@*/ false || !!window.document['documentMode'];
        }
        static isChrome() {
            return !!window['chrome'] && !!window['chrome'].webstore;
        }
    }
    exports.SystemUtils = SystemUtils;
    (function (SystemUtils) {
        let OperatingSystem;
        (function (OperatingSystem) {
            OperatingSystem[OperatingSystem["WINDOWS_10"] = 0] = "WINDOWS_10";
            OperatingSystem[OperatingSystem["WINDOWS_8"] = 1] = "WINDOWS_8";
            OperatingSystem[OperatingSystem["WINDOWS_7"] = 2] = "WINDOWS_7";
            OperatingSystem[OperatingSystem["WINDOWS_VISTA"] = 3] = "WINDOWS_VISTA";
            OperatingSystem[OperatingSystem["WINDOWS_XP"] = 4] = "WINDOWS_XP";
            OperatingSystem[OperatingSystem["WINDOWS_2000"] = 5] = "WINDOWS_2000";
            OperatingSystem[OperatingSystem["MAC"] = 6] = "MAC";
            OperatingSystem[OperatingSystem["UNIX"] = 7] = "UNIX";
            OperatingSystem[OperatingSystem["LINUX"] = 8] = "LINUX";
            OperatingSystem[OperatingSystem["UNKNOWN"] = 9] = "UNKNOWN";
        })(OperatingSystem = SystemUtils.OperatingSystem || (SystemUtils.OperatingSystem = {}));
        let Browser;
        (function (Browser) {
            Browser[Browser["OPERA"] = 0] = "OPERA";
            Browser[Browser["FIREFOX"] = 1] = "FIREFOX";
            Browser[Browser["SAFARI"] = 2] = "SAFARI";
            Browser[Browser["IE"] = 3] = "IE";
            Browser[Browser["EDGE"] = 4] = "EDGE";
            Browser[Browser["CHROME"] = 5] = "CHROME";
            Browser[Browser["UNKNOWN"] = 6] = "UNKNOWN";
        })(Browser = SystemUtils.Browser || (SystemUtils.Browser = {}));
    })(SystemUtils = exports.SystemUtils || (exports.SystemUtils = {}));
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", "src/map/utils/SystemUtils", "src/engine/math/Vector2"], function (require, exports, FloorplanRelatedLayer_2, TileBasedFloorplanLayer_1, ImageBasedFloorplanLayer_1, SystemUtils_1, Vector2_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FloorplanLayer extends FloorplanRelatedLayer_2.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, floorModel, texture) {
            super(environment, null);
            this.config = config;
            this.initFloorplanLayerImpl(floorModel, texture);
        }
        initFloorplanLayerImpl(floorModel, texture) {
            // For testing purposes, we enable the tile engine only for Windows 7 and Chrome.
            if (this.floorplanIsBig(floorModel) || this.platformHasMipmappingProblems()) {
                this.floorplanLayerImpl = new TileBasedFloorplanLayer_1.TileBasedFloorplanLayer(this.config.tileBasedFloorplanLayer, this.getEnvironment(), floorModel, texture);
            }
            else {
                this.floorplanLayerImpl = new ImageBasedFloorplanLayer_1.ImageBasedFloorplanLayer(this.getEnvironment(), floorModel, texture);
            }
            this.addChild(this.floorplanLayerImpl);
        }
        floorplanIsBig(floorModel) {
            let widthInTx = floorModel.pixelPerMeter * floorModel.lengthInMeter;
            return widthInTx > 8192;
        }
        platformHasMipmappingProblems() {
            return SystemUtils_1.SystemUtils.getOperatingSystem() === SystemUtils_1.SystemUtils.OperatingSystem.WINDOWS_7
                && SystemUtils_1.SystemUtils.getBrowser() === SystemUtils_1.SystemUtils.Browser.CHROME;
        }
        // View
        getFloorSize() {
            return this.floorplanLayerImpl.getFloorSize();
        }
        // Coordinate transformations
        // Screen pixels -> Relative texels
        getRelativeWorldCoordsFromScreenPixels(pointInScreenPx) {
            let camera = this.getScene().getCamera();
            let pointInWorldTx = camera.getWorldCoordinateFromImagePoint(pointInScreenPx);
            let pointInRelativeWorldCoords = this.getRelativeCoordinatesFromTexels(pointInWorldTx);
            return pointInRelativeWorldCoords;
        }
        // Relative texels -> screen pixels
        getScreenPixelsFromRelativeCoords(pointInRelativeCoords) {
            let pointInWorldTx = this.getTexelsFromRelativeCoordinates(pointInRelativeCoords);
            let pointInScreenPx = this.getScreenPixelsFromTexels(pointInWorldTx);
            return pointInScreenPx;
        }
        // World texels -> Relative texels
        getRelativeCoordinatesFromTexels(pointInTexels) {
            let floorSize = this.getFloorSize();
            let xRelative = pointInTexels.x / floorSize.x;
            let yRelative = pointInTexels.y / floorSize.y;
            let pointRelative = new PIXI.Point(xRelative, yRelative);
            return pointRelative;
        }
        // Relative texels -> World texels
        getTexelsFromRelativeCoordinates(pointInRelativeCoords) {
            let floorSize = this.getFloorSize();
            let xInTx = pointInRelativeCoords.x * floorSize.x;
            let yInTx = pointInRelativeCoords.y * floorSize.y;
            let pointInTx = new PIXI.Point(xInTx, yInTx);
            return pointInTx;
        }
        // World texels -> screen pixels
        getScreenPixelsFromTexels(pointInWorldTx) {
            let camera = this.getScene().getCamera();
            return camera.getImageCoordinateFromWorldPoint(pointInWorldTx);
        }
        // Screen pixels -> World texels
        getTexelsFromScreenPixels(pointInPx) {
            let camera = this.getScene().getCamera();
            return camera.getWorldCoordinateFromImagePoint(pointInPx);
        }
        // World texels -> Centimeter
        getCmFromTexels(distanceInTx) {
            let cmPerTexel = (1.0 / this.getModel().pixelPerMeter) * 100.0;
            let distanceInCm = distanceInTx * cmPerTexel;
            return distanceInCm;
        }
        // Screen pixels -> World texels
        getTexelWidthFromPixelWidth(pixelWidth) {
            let v1 = this.getTexelsFromScreenPixels(new PIXI.Point(pixelWidth, 0));
            let v2 = this.getTexelsFromScreenPixels(new PIXI.Point(0, 0));
            let texelWidth = Vector2_3.Vector2.getLengthOfPoint(new PIXI.Point(v2.x - v1.x, v2.y - v1.y));
            return texelWidth;
        }
        // Centimeter -> World texels
        getTexelsFromCm(distanceInCm) {
            let texelsPerCm = this.getModel().pixelPerMeter / 100.0;
            let distanceInTx = distanceInCm * texelsPerCm;
            return distanceInTx;
        }
        // Centimeter -> Screen pixels
        getPixelsFromCm(widthInCm) {
            return (widthInCm / 100) * this.getModel().pixelPerMeter;
        }
        getCurrentFloorSizeInScreenPx() {
            return this.floorplanLayerImpl.getCurrentFloorSizeInScreenPx();
        }
        // Model updating
        getModel() {
            return this.floorplanLayerImpl.getModel();
        }
    }
    exports.FloorplanLayer = FloorplanLayer;
    (function (FloorplanLayer) {
        class Config {
            constructor() {
                /**
                 * Configuration of the tile based floorplan layer.
                 */
                this.tileBasedFloorplanLayer = new TileBasedFloorplanLayer_1.TileBasedFloorplanLayer.Config();
            }
        }
        FloorplanLayer.Config = Config;
    })(FloorplanLayer = exports.FloorplanLayer || (exports.FloorplanLayer = {}));
});
define("src/map/utils/DeviceUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceUtils {
        static isMobileDevice() {
            return PIXI.utils.isMobile.any;
        }
        static getPhysicalPixelsFromLogical(logicalPixels) {
            return logicalPixels;
        }
    }
    exports.DeviceUtils = DeviceUtils;
});
define("src/map/view/world/objects/WorldObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_6, Animation_5, LinearInterpolator_4, DisplayObjectContainer_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WorldObject extends SceneObject_6.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            // View: Animation
            this.visibilityAnimationDurationInMs = 200;
            this.initWorldObjectViews();
        }
        initWorldObjectViews() {
            this.renderView = new DisplayObjectContainer_8.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.mainView = new DisplayObjectContainer_8.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.renderView.addChild(this.mainView);
            this.visibilityAnimation = new Animation_5.Animation(new LinearInterpolator_4.LinearInterpolator());
        }
        // View
        // @Override
        getView() {
            return this.mainView;
        }
        // @Override
        getRenderView() {
            return this.renderView;
        }
        // Visibility
        animateInvisible() {
            let startValue = this.renderView.alpha;
            let endValue = 0.0;
            let durationInMs = this.visibilityAnimationDurationInMs;
            let delayInMs = 0;
            this.visibilityAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        setInvisible() {
            this.visibilityAnimation.stop();
            this.renderView.alpha = 0.0;
        }
        animateVisible() {
            let startValue = this.renderView.alpha;
            let endValue = 1.0;
            let durationInMs = this.visibilityAnimationDurationInMs;
            let delayInMs = 0;
            this.visibilityAnimation.start(startValue, endValue, durationInMs, delayInMs);
            // Resume the scene object, if it was invisible before.
            this.setPaused(false);
        }
        setVisible() {
            this.visibilityAnimation.stop();
            this.renderView.alpha = 1.0;
        }
        // Update
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateVisibilityAnimation(lastFrametime);
        }
        updateVisibilityAnimation(lastFrametime) {
            if (this.visibilityAnimation.isCurrentlyAnimating()) {
                let currentValue = this.visibilityAnimation.getValue(lastFrametime);
                let oldAlpha = this.renderView.alpha;
                this.renderView.alpha = currentValue;
                if (oldAlpha > 0 && currentValue === 0) {
                    // Disable update of this scene object, since it
                    // is not visible anymore. Setting it visible will
                    // resume the scene object.
                    this.setPaused(true);
                }
            }
        }
    }
    exports.WorldObject = WorldObject;
});
define("src/app/relution/view/world/RelutionMapAttributeObject", ["require", "exports", "src/map/view/world/objects/WorldObject"], function (require, exports, WorldObject_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Binds the object's lifetime to the lifetime of zero or more Relution map objects.
     *
     * @export
     * @class RelutionMapAttributeObject
     * @extends {WorldObject}
     */
    class RelutionMapAttributeObject extends WorldObject_1.WorldObject {
        // Initialization
        constructor(environment, object, ...args) {
            super(environment);
            // Model
            this.dependentObjects = new Array();
            if (object !== undefined) {
                this.addObjectDependencies(object, ...args);
                this.syncObjectVisibilityWithoutAnimation();
            }
        }
        // Destruction
        // @Override
        destroy() {
            this.removeObjectDependencies();
            super.destroy();
        }
        // Object dependencies
        addObjectDependencies(object, ...args) {
            this.addObjectDependency(object);
            for (let i = 0; i < args.length; i++) {
                let argObject = args[i];
                this.addObjectDependency(argObject);
            }
        }
        // Adds object dependencies at runtime
        // @Override
        addObjectDependency(object) {
            this.dependentObjects.push(object);
            object.getModel().addObserver(this);
            this.syncObjectVisibilityWithAnimation();
        }
        // @Override
        removeObjectDependency(object) {
            let index = this.dependentObjects.indexOf(object);
            if (index > -1) {
                this.dependentObjects.splice(index, 1);
                object.getModel().removeObserver(this);
                this.syncObjectVisibilityWithAnimation();
            }
        }
        removeObjectDependencies() {
            while (this.dependentObjects.length > 0) {
                this.removeObjectDependency(this.dependentObjects[0]);
            }
        }
        // Model Event-Handling
        // @Override
        visibilityChanged(model) {
            this.syncObjectVisibilityWithAnimation();
        }
        syncObjectVisibilityWithAnimation() {
            // Fade out visibility wrapper if at least one dependent object is invisible.
            if (this.atLeastOneDependentObjectIsInvisible()) {
                this.animateInvisible();
            }
            else {
                this.animateVisible();
            }
        }
        syncObjectVisibilityWithoutAnimation() {
            if (this.atLeastOneDependentObjectIsInvisible()) {
                this.setInvisible();
            }
            else {
                this.setVisible();
            }
        }
        atLeastOneDependentObjectIsInvisible() {
            for (let i = 0; i < this.dependentObjects.length; i++) {
                let object = this.dependentObjects[i];
                if (!object.getModel().visible) {
                    return true;
                }
            }
            return false;
        }
        // Getters and setters
        dependsOnObject(object) {
            for (let i = 0; i < this.dependentObjects.length; i++) {
                let dependentObject = this.dependentObjects[i];
                if (object.getModel().uuid === dependentObject.getModel().uuid) {
                    return true;
                }
            }
            return false;
        }
        getDependentObjects() {
            return this.dependentObjects;
        }
    }
    exports.RelutionMapAttributeObject = RelutionMapAttributeObject;
});
define("src/map/utils/DateUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DateUtils {
        static getTimeSince(date) {
            if (typeof date !== "object") {
                date = new Date(date);
            }
            let passedMs = new Date() - date;
            return DateUtils.getFormattedTimeDifference(passedMs);
        }
        static getFormattedTimeDifference(timeDifferenceInMs) {
            let seconds = Math.floor(timeDifferenceInMs / 1000);
            let intervalType;
            let interval = Math.floor(seconds / 31536000);
            if (interval >= 1) {
                intervalType = "year";
            }
            else {
                interval = Math.floor(seconds / 2592000);
                if (interval >= 1) {
                    intervalType = "month";
                }
                else {
                    interval = Math.floor(seconds / 86400);
                    if (interval >= 1) {
                        intervalType = "day";
                    }
                    else {
                        interval = Math.floor(seconds / 3600);
                        if (interval >= 1) {
                            intervalType = "hour";
                        }
                        else {
                            interval = Math.floor(seconds / 60);
                            if (interval >= 1) {
                                intervalType = "minute";
                            }
                            else {
                                interval = seconds;
                                intervalType = "second";
                            }
                        }
                    }
                }
            }
            if (interval > 1 || interval === 0) {
                intervalType += "s";
            }
            let result = [];
            result.push(interval);
            result.push(intervalType);
            return result;
        }
        static getFormattedTime(timeInMs) {
            // Create a date object with the current time
            let now = new Date(timeInMs);
            // Create an array with the current month, day and time
            let date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
            // Create an array with the current hour, minute and second
            let time = [now.getHours(), now.getMinutes(), now.getSeconds()];
            // Determine AM or PM suffix based on the hour
            let suffix = (time[0] < 12) ? "AM" : "PM";
            // Convert hour from military time
            time[0] = (time[0] < 12) ? time[0] : time[0] - 12;
            // If hour is 0, set it to 12
            time[0] = time[0] || 12;
            // If seconds and minutes are less than 10, add a zero
            for (let i = 1; i < 3; i++) {
                if (time[i] < 10) {
                    time[i] = "0" + time[i];
                }
            }
            // Return the formatted string
            return date.join("/") + " " + time.join(":") + " " + suffix;
        }
    }
    exports.DateUtils = DateUtils;
});
define("src/app/relution/view/world/RelutionMapObject", ["require", "exports", "src/engine/general/AABB", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject", "src/map/utils/DateUtils"], function (require, exports, AABB_6, DeviceUtils_1, RelutionMapAttributeObject_1, DateUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * All objects in the Relution map's world that are editable, selectable
     * and contain a reference to a Relution model, should inherit from this
     * base class.
     *
     * @export
     * @class RelutionMapObject
     * @extends {WorldObject}
     */
    class RelutionMapObject extends RelutionMapAttributeObject_1.RelutionMapAttributeObject {
        // Construction
        constructor(config, environment, floorplanLayer, model, dependingObject, ...args) {
            super(environment, dependingObject, ...args);
            // Observation
            this.observers = new Array();
            // State
            this.editModeActive = false;
            this.mouseOver = false;
            this.mouseAboveEditPoint = false;
            this.selected = false;
            this.floorplanLayer = floorplanLayer;
            this.model = model;
            this.config = config;
            this.initRelutionMapObjectView();
        }
        initRelutionMapObjectView() {
            this.setEditModeActive(this.config.editModeActive);
            this.model.visible = this.config.visible;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index >= 0) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Model-binding
        updateModel(model) {
            this.model = model;
            this.onModelUpdated(model);
        }
        // Map insertion
        /**
         * Returns true, if the object's model can change its state from onMap=true
         * to onMap=false and, thus, may be removed from the map.
         * Default: false
         *
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        isMovableToStock() {
            return false;
        }
        isOnMap() {
            if (this.getDependentObjects().length > 0) {
                // Inner object case
                return this.getDependentObjects()[0].isOnMap();
            }
            else {
                // Root object
                return this.model.isOnMap();
            }
        }
        // Mouse over
        isMouseOver() {
            return this.mouseOver;
        }
        setMouseOver(mouseOver) {
            if (this.mouseOverStateWillChange(mouseOver)) {
                this.mouseOver = mouseOver;
                this.redraw();
            }
        }
        mouseOverStateWillChange(newMouseOver) {
            return this.mouseOver !== newMouseOver;
        }
        // Mouse above edit point
        isMouseAboveEditPoint() {
            return this.mouseAboveEditPoint;
        }
        setMouseAboveEditPoint(mouseAboveEditPoint) {
            if (this.mouseAboveEditPointStateWillChange(mouseAboveEditPoint)) {
                this.mouseAboveEditPoint = mouseAboveEditPoint;
                this.redraw();
            }
        }
        mouseAboveEditPointStateWillChange(newMouseAboveEditPointState) {
            return this.mouseAboveEditPoint !== newMouseAboveEditPointState;
        }
        // Popup info
        /**
         * Returns the content of the popup view that is displayed,
         * whenever the user hovers the map object.
         *
         * By default, this method returns an empty string.
         */
        getPopupInfo() {
            return "";
        }
        /**
         * Returns true, if popup infos are supported.
         *
         * Default: true
         */
        isPopupInfoSupported() {
            return true;
        }
        /**
         * Returns the time as a localized formatted string.
         * @param timeInMs
         */
        getLocalizedTimeSinceString(timeInMs) {
            let timeSince = DateUtils_1.DateUtils.getTimeSince(timeInMs);
            let interval = timeSince[0];
            let intervalType = timeSince[1];
            let timeSinceString = ""
                + this.getLocalizedStringFor("popup_time_unit_prefix")
                + "" + interval + " " + this.getLocalizedStringFor("popup_time_unit_" + intervalType)
                + this.getLocalizedStringFor("popup_time_unit_postfix");
            return timeSinceString;
        }
        // Editing
        /**
         * Returns true, if the edit mode is enabled.
         *
         * @abstract
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        isEditModeActive() {
            return this.editModeActive;
        }
        setEditModeActive(editModeActive) {
            this.editModeActive = editModeActive;
        }
        /**
         * Returns true, if the point (x,y) given in screen coordinates is
         * close to an area that should be visualized as editable, e.g.
         * the bottom right corner of a rectangle.
         * Default behavior: No point on the object is editable.
         * @param x
         * @param y
         */
        pointIsCloseToEditableArea(x, y) {
            return false;
        }
        /**
         * Event handler called when the user started editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditStart(x, y) {
            // Nothing to do
        }
        /**
         * Event handler called, when the user moves the mouse cursor while editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditMove(x, y) {
            // Nothing to do
        }
        /**
         * Event handler called, when the user stopped moving the mouse cursor while editing the object.
         * Default behavior: Editing will be ignored.
         * @param x
         * @param y
         */
        onEditStop(x, y) {
            // Nothing to do
        }
        // Moving
        /**
         * Returns true, if the object is movable.
         *
         * Default: true
         */
        isMovable() {
            return true;
        }
        /**
         * Event handler called, when the user started moving the object.
         * @param x
         * @param y
         */
        onMoveStarted(x, y) {
            // Empty default implementation
        }
        /**
         * Event handler called, when the user moves the mouse cursor while moving the object.
         * @param x
         * @param y
         */
        onMoveChanged(x, y) {
            // Empty default implementation
        }
        /**
         * Event handler called, when the user stopped moving the mouse cursor while moving the object.
         * @param x
         * @param y
         */
        onMoveStopped(x, y) {
            // Empty default implementation
        }
        // Selection
        isSelectable() {
            // By default, a Relution map object is selectable.
            return true;
        }
        isSelected() {
            return this.selected;
        }
        setSelected(selected) {
            let selectedBefore = this.selected;
            this.selected = selected;
            this.redraw();
            if (this.selected && !selectedBefore) {
                this.notifyObservers("onObjectSelected", [this]);
            }
            else if (!this.selected && selectedBefore) {
                this.notifyObservers("onObjectUnselected", [this]);
            }
        }
        // Intersection
        intersectsAabb(aabb) {
            let objectAabb = this.getAabbInImageCoordinates();
            return aabb.intersects(objectAabb);
        }
        /**
         * Returns true, if the point (x,y), given in screen pixels,
         * intersects the object.
         *
         * @abstract
         * @param {number} x
         * @param {number} y
         * @returns {boolean}
         * @memberof RelutionMapObject
         */
        intersectsPointInScreenPx(x, y) {
            let aabb = this.getAabbInImageCoordinates();
            return ((x >= aabb.min.x) && (x <= aabb.max.x) &&
                (y >= aabb.min.y) && (y <= aabb.max.y));
        }
        // Dimensions
        /**
         * Returns the object's axis-aligned-bounding-box
         *
         * @returns {AABB}
         * @memberof RelutionMapObject
         */
        getAabbInImageCoordinates() {
            let bounds = this.getAabbReferenceView().pixi().getBounds();
            // On mobile devices, we increase the bounds if necessary,
            // because tapping is more difficult than clicking.
            let aabb = null;
            if (DeviceUtils_1.DeviceUtils.isMobileDevice()) {
                let minPixels = DeviceUtils_1.DeviceUtils.getPhysicalPixelsFromLogical(40);
                let width = bounds.width;
                let height = bounds.height;
                let xAddition = Math.max((minPixels - width) / 2, 0);
                let yAddition = Math.max((minPixels - height) / 2, 0);
                aabb = new AABB_6.AABB(new PIXI.Point(bounds.x - xAddition, bounds.y - yAddition), new PIXI.Point(bounds.x + width + xAddition, bounds.y + height + yAddition));
            }
            else {
                aabb = new AABB_6.AABB(new PIXI.Point(bounds.x, bounds.y), new PIXI.Point(bounds.x + bounds.width, bounds.y + bounds.height));
            }
            return aabb;
        }
        /**
         * Returns the reference view used for AABB computation.
         * This method can be overridden, if the reference view is not
         * the same as returned by {@link getView}.
         */
        getAabbReferenceView() {
            return this.getView();
        }
        // Getters and setters
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
        getModel() {
            return this.model;
        }
    }
    // Metadata
    RelutionMapObject.viewModelClassMappings = new Array();
    exports.RelutionMapObject = RelutionMapObject;
    (function (RelutionMapObject) {
        class Config {
            constructor() {
                /**
                 * True, if the edit mode should be enabled by default.
                 *
                 * Default: True
                 */
                this.editModeActive = true;
                /**
                 * True, if the Relution map object should be visible by default.
                 *
                 * Default: true
                 */
                this.visible = true;
            }
        }
        RelutionMapObject.Config = Config;
    })(RelutionMapObject = exports.RelutionMapObject || (exports.RelutionMapObject = {}));
    class RelutionViewModelMapping {
        constructor(viewClass, modelClass) {
            this.viewClass = null;
            this.modelClass = null;
            this.viewClass = viewClass;
            this.modelClass = modelClass;
        }
    }
    exports.RelutionViewModelMapping = RelutionViewModelMapping;
    /**
     * Decorator that maps Relution map object classes to its corresponding model classes.
     * @param modelClass
     */
    function RelutionModelBinding(modelClass) {
        return function (viewClass) {
            RelutionMapObject.viewModelClassMappings.push(new RelutionViewModelMapping(viewClass, modelClass));
        };
    }
    exports.RelutionModelBinding = RelutionModelBinding;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, RelutionMapObject_1, DisplayObjectContainer_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Device extends RelutionMapObject_1.RelutionMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // View: Dimensions
            this.maxDeviceSizeInMeter = 1.0;
            this.minDeviceSizeInPixels = 10;
            // View: State
            this.invalidated = false;
            this.initDeviceModel(model);
            this.initDeviceView();
        }
        initDeviceModel(model) {
            this.deviceModel = model;
            this.deviceModel.addObserver(this);
        }
        initDeviceView() {
            this.initContainer();
            this.updateVisibilityWithoutAnimation();
        }
        initContainer() {
            this.container = new DisplayObjectContainer_9.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.container);
            // Position
            this.updateViewPositionFromModelPosition();
        }
        // Resetting
        reset() {
            // Empty default implementation
        }
        updateViewPositionFromModelPosition() {
            let modelPosition = this.getModel().getPosition();
            this.getView().x = modelPosition.x * this.getFloorplanLayer().getFloorSize().x;
            this.getView().y = modelPosition.y * this.getFloorplanLayer().getFloorSize().y;
            if (this.getModel().positionIsOutdoor(modelPosition)) {
                this.getView().visible = false;
            }
            else {
                this.getView().visible = true;
            }
        }
        getMaxDeviceSizeInMeter() {
            return this.maxDeviceSizeInMeter;
        }
        setMaxDeviceSizeInMeter(maxDeviceSizeInMeter) {
            this.maxDeviceSizeInMeter = maxDeviceSizeInMeter;
        }
        getMinDeviceSizeInPixels() {
            return this.minDeviceSizeInPixels;
        }
        setMinDeviceSizeInPixels(minDeviceSizeInPixels) {
            this.minDeviceSizeInPixels = minDeviceSizeInPixels;
        }
        // View: Visibility
        updateVisibilityWithoutAnimation() {
            if (this.getModel().visible) {
                this.setVisible();
            }
            else {
                this.setInvisible();
            }
        }
        updateVisibilityWithAnimation() {
            if (this.getModel().visible) {
                this.animateVisible();
            }
            else {
                this.animateInvisible();
            }
        }
        // Model
        // @Override
        onModelUpdated(model) {
            this.deviceModel.update(model);
        }
        // Model Event handling
        updateModelPositionFromViewPosition() {
            // We prestore its position, because changing the
            // models values might call observers directly modifying
            // the view coordinates.
            let viewX = this.getView().x;
            let viewY = this.getView().y;
            this.getModel().x = viewX / this.getFloorSize().x;
            this.getModel().y = viewY / this.getFloorSize().y;
            if (this.getModel().positionIsOutdoor(this.getModel().getPosition())) {
                this.getView().visible = false;
            }
            else {
                this.getView().visible = true;
            }
        }
        updateModelPositionFromViewPositionAndConsiderWorldConstraints() {
            let viewX = this.getView().x;
            let viewY = this.getView().y;
            this.getModel().x = Math.max(0, Math.min(1, viewX / this.getFloorSize().x));
            this.getModel().y = Math.max(0, Math.min(1, viewY / this.getFloorSize().y));
        }
        // @Override
        xChanged(deviceModel) {
            // Do not update beacon position, if beacon is in stock
            if (this.deviceModel.onMap) {
                this.updateViewPositionFromModelPosition();
            }
        }
        // @Override
        yChanged(deviceModel) {
            // Do not update beacon position, if beacon is in stock
            if (this.deviceModel.onMap) {
                this.updateViewPositionFromModelPosition();
            }
        }
        // @Override
        visibilityChanged(deviceModel) {
            this.updateVisibilityWithAnimation();
        }
        // Name
        // @Override
        getName() {
            return this.getModel().deviceId;
        }
        // Popup info
        // @Override
        getPopupInfo() {
            let content;
            // General device information
            content = this.getLocalizedStringFor("popup_device_name") + ": "
                + this.getModel().name;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_serial") + ": "
                + this.getModel().deviceId;
            // Device specific information
            content += this.getDeviceSpecificPopupInfo();
            return content;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (!this.isFreezed()) {
                this.updateTransform();
            }
        }
        updateTransform() {
            this.updateScale();
            this.updateRotation();
            this.invalidated = false;
        }
        updateScale() {
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.getView().scale.x = scaleFactor;
                this.getView().scale.y = scaleFactor;
                let maxDeviceSizeInMeter = this.getMaxDeviceSizeInMeter();
                let deviceSizeInScreenPixels = this.getDeviceSizeInScreenPixels();
                let deviceSizeInTexels = deviceSizeInScreenPixels * scaleFactor;
                let deviceSizeInMeter = this.getTexelSizeInMeter(deviceSizeInTexels);
                if (deviceSizeInMeter >= maxDeviceSizeInMeter) {
                    // Max beacon size in meter:
                    // Device should only scale if it does not cover
                    // more than maxDeviceSize meters of world space.
                    let maxScaleCorrection = maxDeviceSizeInMeter / deviceSizeInMeter;
                    // Min device size in pixels.
                    // However, devices should not be display too small.
                    // Hence, we define a minimum device size in pixels.
                    let newDeviceSizeInScreenPixels = deviceSizeInScreenPixels * maxScaleCorrection;
                    let minDeviceSizeInPx = this.getMinDeviceSizeInPixels();
                    if (newDeviceSizeInScreenPixels < minDeviceSizeInPx) {
                        let minScaleCorrection = minDeviceSizeInPx / deviceSizeInScreenPixels;
                        this.getView().scale.x = this.getView().scale.x * minScaleCorrection;
                        this.getView().scale.y = this.getView().scale.y * minScaleCorrection;
                    }
                    else {
                        this.getView().scale.x = this.getView().scale.x * maxScaleCorrection;
                        this.getView().scale.y = this.getView().scale.y * maxScaleCorrection;
                    }
                }
            }
        }
        getDeviceSizeInScreenPixels() {
            let bounds = this.getView().pixi().getBounds();
            return bounds.width;
        }
        getTexelSizeInMeter(sizeInTexels) {
            let sizeInMeter = sizeInTexels / this.getFloorplanLayer().getModel().pixelPerMeter;
            return sizeInMeter;
        }
        getSizeInPx(sizeInMeter) {
            let sizeInPx = sizeInMeter * this.getFloorplanLayer().getModel().pixelPerMeter;
            return sizeInPx;
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            if (this.getView().rotation !== orientation || this.invalidated) {
                this.getView().rotation = orientation;
            }
        }
        invalidate() {
            this.invalidated = true;
            if (this.getScene() != null) {
                this.updateTransform();
            }
        }
        // Selection
        // @Override
        isSelectable() {
            // By default, all devices are selectable.
            return true;
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            // Destroy without removing texture
            this.getView().destroy(false);
        }
        // Getters and setters
        getModel() {
            return this.deviceModel;
        }
        getFloorSize() {
            return new PIXI.Point(this.getFloorplanLayer().getFloorSize().x, this.getFloorplanLayer().getFloorSize().y);
        }
        isFreezed() {
            return this.freezed;
        }
        // Freezed means that the beacon does
        // not do anything in its update method.
        setFreezed(freezed) {
            this.freezed = freezed;
        }
        isInactive() {
            return this.inactive;
        }
        setInactive(inactive) {
            this.inactive = inactive;
            this.redraw();
        }
        isHighlighted() {
            return this.highlighted;
        }
        setHighlighted(highlighted) {
            this.highlighted = highlighted;
            this.redraw();
        }
    }
    exports.Device = Device;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/map/utils/DeviceUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/RelutionMapObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/utils/Point", "src/engine/rendering/texture/Texture"], function (require, exports, Device_1, DeviceUtils_2, DeviceModel_1, RelutionMapObject_2, SpriteObject_3, Point_2, Texture_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Beacon_1;
    let Beacon = Beacon_1 = class Beacon extends Device_1.Device {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.initBeaconModel(model, floorplanLayer);
            this.initView();
        }
        initBeaconModel(model, floorplanLayer) {
            this.lastUpdateInMs = Date.now();
        }
        initView() {
            this.spriteView = new SpriteObject_3.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.loadTexture("beacon_white");
            this.getView().addChild(this.spriteView);
            this.setMinViewDeviceSize();
            this.setMaxViewSize();
            this.reset();
        }
        // @Override
        setMinViewDeviceSize() {
            this.setMinDeviceSizeInPixels(10);
        }
        // @Override
        setMaxViewSize() {
            this.setMaxDeviceSizeInMeter(1.0);
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return Beacon_1.BEACON_SIZE_IN_PX;
        }
        // Resets the device to its initial state.
        // @Override
        reset() {
            super.reset();
            this.setEditModeActive(false);
            this.userMovesBeacon = false;
            this.setFreezed(false);
            this.updateSpriteTexture();
            this.updateSpritePivot();
            this.updateSpriteSize();
            this.getView().scale = new Point_2.Point(new PIXI.Point(1, 1), this.getEnvironment().renderingEnvironment);
            // Retransform object, after its dimensions have changed.
            this.invalidate();
        }
        redraw() {
            this.updateSpriteTexture();
        }
        updateSpriteTexture() {
            if (this.isSelected()) {
                this.spriteView.tint = Beacon_1.SElECTED_COLOR;
            }
            else if (this.isHighlighted()) {
                this.spriteView.tint = Beacon_1.HIGHLIGHTED_COLOR;
            }
            else {
                if (this.getModel().isBleNode() || this.getModel().isMeshgw()) {
                    if (this.isDisconnected()) {
                        this.spriteView.tint = Beacon_1.DISCONNECTED_COLOR;
                    }
                    else if (this.isInactive()) {
                        this.spriteView.tint = Beacon_1.INACTIVE_COLOR;
                    }
                    else {
                        this.spriteView.tint = Beacon_1.NORMAL_COLOR;
                    }
                }
                else {
                    this.spriteView.tint = Beacon_1.DUMB_COLOR;
                }
            }
        }
        // @Override
        getTextureName() {
            return "beacon_white";
        }
        updateSpritePivot() {
            this.spriteView.pivot.x = this.spriteView.texture.baseTexture.width / 2;
            this.spriteView.pivot.y = this.spriteView.texture.baseTexture.height / 2;
        }
        loadTexture(textureName) {
            let texture = PIXI.loader.resources["" + textureName].texture;
            texture.baseTexture.mipmap = true;
            this.spriteView.texture = new Texture_4.Texture(texture, this.getEnvironment().renderingEnvironment);
        }
        updateSpriteSize() {
            let beaconSize = this.getTargetDeviceSizeInPx();
            this.spriteView.width = beaconSize;
            this.spriteView.height = beaconSize;
        }
        // View
        getSpriteView() {
            return this.spriteView;
        }
        // @Override
        getWidth() {
            return this.spriteView.width;
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastConnectionDateString(this);
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_version") + ": "
                + this.getModel().os;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_node_id") + ": "
                + this.getModel().nodeId;
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_user_count") + ": "
                + this.getModel().userCount;
            return content;
        }
        getLocalizedLastConnectionDateString(device) {
            return this.getLocalizedTimeSinceString(device.getModel().lastConnectionDate);
        }
        // Stock movability
        // @Override
        isMovableToStock() {
            // A beacon is movable to stock.
            return true;
        }
        // Input Event-Handling
        // @Override
        onMoveStarted(x, y) {
            if (this.intersectsPointInScreenPx(x, y)) {
                if (this.isEditModeActive()) {
                    this.userMovesBeacon = true;
                    let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
                    let viewPositionInTx = this.getView().position;
                    this.movingPointInDeviceLocalTx = new PIXI.Point(mouseInTx.x - viewPositionInTx.x, mouseInTx.y - viewPositionInTx.y);
                    this.notifyObservers("onObjectMoveStarted", [this, x, y]);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        // @Override
        onMoveChanged(x, y) {
            if (this.userMovesBeacon) {
                let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
                this.getView().x = mouseInTx.x - this.movingPointInDeviceLocalTx.x;
                this.getView().y = mouseInTx.y - this.movingPointInDeviceLocalTx.y;
                this.updateModelPositionFromViewPosition();
                this.notifyObservers("onObjectMoveChanged", [this, x, y]);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onMoveStopped(x, y) {
            if (this.userMovesBeacon) {
                this.userMovesBeacon = false;
                this.movingPointInDeviceLocalTx = null;
                this.updateModelPositionFromViewPositionAndConsiderWorldConstraints();
                this.notifyObservers("onObjectMoveStopped", [this, x, y]);
                return true;
            }
            else {
                return false;
            }
        }
        // Model updating
        addToMap() {
            // Set beacon model to be on the map.
            this.getModel().onMap = true;
            // Update the view position.
            this.updateViewPositionFromModelPosition();
        }
        removeFromMap() {
            this.getModel().onMap = false;
        }
        // Selection
        // @Override
        isSelectable() {
            // A beacon is only selectable, if it is on the map and not in the stock.
            return this.isOnMap();
        }
        // Getters and setters
        // @Override
        getModel() {
            return super.getModel();
        }
        isUserMovingBeacon() {
            return this.userMovesBeacon;
        }
        setUserMovesBeacon(userMovesBeacon) {
            this.userMovesBeacon = userMovesBeacon;
        }
        isInactive() {
            return this.getModel().inactive;
        }
        isDisconnected() {
            return this.getModel().status === "INACTIVE";
        }
    };
    // Constants
    Beacon.NORMAL_COLOR = 0x95b507;
    Beacon.SElECTED_COLOR = 0x95b5ff;
    Beacon.HIGHLIGHTED_COLOR = 0x95b5ff;
    Beacon.INACTIVE_COLOR = 0xb5b5b5;
    Beacon.DUMB_COLOR = 0xffffff;
    Beacon.DISCONNECTED_COLOR = 0xf0ad4e;
    // View
    Beacon.BEACON_SIZE_IN_PX = DeviceUtils_2.DeviceUtils.getPhysicalPixelsFromLogical(15);
    Beacon = Beacon_1 = __decorate([
        RelutionMapObject_2.RelutionModelBinding(DeviceModel_1.BleNodeModel)
    ], Beacon);
    exports.Beacon = Beacon;
    (function (Beacon) {
        let Mode;
        (function (Mode) {
            Mode[Mode["NONE"] = 0] = "NONE";
            Mode[Mode["SELECTION"] = 1] = "SELECTION";
            Mode[Mode["EDITABLE"] = 2] = "EDITABLE";
        })(Mode = Beacon.Mode || (Beacon.Mode = {}));
    })(Beacon = exports.Beacon || (exports.Beacon = {}));
    exports.Beacon = Beacon;
});
define("src/engine/animation/EaseOut", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Can be used as a decorator for arbitrary interpolators
    class EaseOut {
        constructor(baseInterpolator) {
            this.baseInterpolator = baseInterpolator;
        }
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let alpha = 10;
            let easedT = 1 - Math.pow(1 - t, alpha);
            return this.baseInterpolator.getInterpolationValue(easedT);
        }
    }
    exports.EaseOut = EaseOut;
});
define("src/engine/rendering/objects/text/TextStyle", ["require", "exports", "src/engine/rendering/DecoratingObject"], function (require, exports, DecoratingObject_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TextStyle extends DecoratingObject_6.DecoratingObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
        }
        // Decorating methods
        set fill(fill) {
            let oldFill = this.pixi().fill;
            if (oldFill !== fill) {
                this.pixi().fill = fill;
                // As the fill field may be saved in a different format (e.g. hex string), we must check
                // for modification again (this time definitely with the same format).
                if (this.pixi().fill !== oldFill) {
                    this.environment.dirty = true;
                }
            }
        }
        get fill() {
            return this.pixi().fill;
        }
    }
    exports.TextStyle = TextStyle;
});
define("src/engine/rendering/objects/TextObject", ["require", "exports", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/text/TextStyle"], function (require, exports, SpriteObject_4, TextStyle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TextObject extends SpriteObject_4.SpriteObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
            this._textStyle = new TextStyle_1.TextStyle(this.pixi().style, environment);
        }
        // Decorating methods
        destroy(options) {
            this.pixi().destroy(options);
            this.environment.dirty = true;
        }
        set text(text) {
            let oldText = this.pixi().text;
            if (oldText !== text) {
                this.pixi().text = text;
                this.environment.dirty = true;
            }
        }
        get text() {
            return this.pixi().text;
        }
        set style(style) {
            this.pixi().style = style.pixi();
            this.environment.dirty = true;
        }
        get style() {
            this._textStyle.setPixi(this.pixi().style);
            return this._textStyle;
        }
        updateText(respectDirty) {
            this.pixi().updateText(respectDirty);
            this.environment.dirty = true;
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.TextObject = TextObject;
});
define("src/app/relution/view/hud/barLayer/beaconBar/BeaconItem", ["require", "exports", "src/engine/scene/SceneObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/map/utils/DeviceUtils", "src/engine/animation/Animation", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_7, Beacon_2, DeviceUtils_3, Animation_6, EaseOut_1, LinearInterpolator_5, TextObject_1, DisplayObjectContainer_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconItem extends SceneObject_7.SceneObject {
        // Initialization
        constructor(environment, beacon) {
            super(environment);
            // View: Size
            this.itemWidth = 0;
            this.itemHeight = 0;
            this.pivotX = 0;
            this.pivotY = 0;
            this.initView(beacon);
        }
        initView(beacon) {
            this.beacon = beacon;
            this.createSerialNumberView();
            this.initDimensions();
            this.initContainer();
            this.initBeaconView(beacon);
            this.initSerialNumberView();
            this.initResetAnimation();
        }
        createSerialNumberView() {
            let fontSize = DeviceUtils_3.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let serialNumber = this.beacon.getModel().deviceId;
            this.serialNumberView = new TextObject_1.TextObject(new PIXI.Text("" + serialNumber, { fontFamily: "Arial", fontSize: fontSize, fill: 0x374203, align: "center" }), this.getEnvironment().renderingEnvironment);
            this.serialNumberView.texture.baseTexture.mipmap = false;
        }
        initDimensions() {
            // this.itemWidth = DeviceUtils.getPhysicalPixelsFromLogical(64);
            let horizontalPadding = DeviceUtils_3.DeviceUtils.getPhysicalPixelsFromLogical(5);
            this.itemWidth = this.serialNumberView.width + horizontalPadding * 2;
            this.itemHeight = BeaconItem.ITEM_HEIGHT;
            this.pivotX = this.getItemWidth() / 2;
            this.pivotY = this.getItemHeight() * (1.0 / 3);
        }
        initContainer() {
            this.container = new DisplayObjectContainer_10.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            // Pivot
            this.container.pivot.x = this.pivotX;
            this.container.pivot.y = this.pivotY;
        }
        initBeaconView(beacon) {
            this.addChild(beacon);
            // Scale
            this.beacon.getView().width = Beacon_2.Beacon.BEACON_SIZE_IN_PX;
            this.beacon.getView().height = Beacon_2.Beacon.BEACON_SIZE_IN_PX;
            // Position
            this.beacon.getView().x = this.pivotX;
            this.beacon.getView().y = this.pivotY;
        }
        initSerialNumberView() {
            // Pivot
            this.serialNumberView.pivot.x = this.serialNumberView.width / 2;
            this.serialNumberView.pivot.y = this.serialNumberView.height / 2;
            // Position
            this.serialNumberView.x = this.pivotX;
            let beaconBottomY = (this.beacon.getView().y + Beacon_2.Beacon.BEACON_SIZE_IN_PX / 2);
            this.serialNumberView.y = beaconBottomY + ((this.getItemHeight() - beaconBottomY) / 2);
            this.container.addChild(this.serialNumberView);
        }
        initResetAnimation() {
            let interpolator = new EaseOut_1.EaseOut(new LinearInterpolator_5.LinearInterpolator());
            this.resetXAnimation = new Animation_6.Animation(interpolator);
            this.resetYAnimation = new Animation_6.Animation(interpolator);
        }
        startResetAnimation() {
            let startXValue = this.getView().x;
            let startYValue = this.getView().y;
            let endPosition = this.getTargetPosition();
            let endXValue = endPosition.x;
            let endYValue = endPosition.y;
            let durationInMs = 500;
            let delayInMs = 0;
            this.resetXAnimation.start(startXValue, endXValue, durationInMs, delayInMs);
            this.resetYAnimation.start(startYValue, endYValue, durationInMs, delayInMs);
        }
        stopResetAnimation() {
            this.resetXAnimation.stop();
            this.resetYAnimation.stop();
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.resetXAnimation.isCurrentlyAnimating()) {
                let currentX = this.resetXAnimation.getValue(lastFrametime);
                let currentY = this.resetYAnimation.getValue(lastFrametime);
                this.getView().x = currentX;
                this.getView().y = currentY;
            }
        }
        // View
        resetPosition() {
            let targetPosition = this.getTargetPosition();
            this.getView().x = targetPosition.x;
            this.getView().y = targetPosition.y;
        }
        setTargetPosition(position) {
            this.targetPosition = position;
        }
        getTargetPosition() {
            return this.targetPosition;
        }
        // @Override
        getView() {
            return this.container;
        }
        // Getters and setters
        getBeacon() {
            return this.beacon;
        }
        // Getters and setters
        getItemWidth() {
            return this.itemWidth;
        }
        getItemHeight() {
            return this.itemHeight;
        }
        getPivotX() {
            return this.pivotX;
        }
        getPivotY() {
            return this.pivotY;
        }
    }
    BeaconItem.ITEM_HEIGHT = DeviceUtils_3.DeviceUtils.getPhysicalPixelsFromLogical(42);
    exports.BeaconItem = BeaconItem;
});
define("src/app/relution/utils/MouseUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MouseUtils {
        static isHandCursorStyle() {
            return window.document.body.style.cursor === "pointer";
        }
        static changeToHandCursorStyle() {
            window.document.body.style.cursor = "pointer";
        }
        static isDefaultCursorStyle() {
            return window.document.body.style.cursor === "default" || window.document.body.style.cursor === "";
        }
        static changeToDefaultCursorStyle() {
            window.document.body.style.cursor = "default";
        }
        static changeToMoveCursorStyle() {
            window.document.body.style.cursor = "move";
        }
    }
    exports.MouseUtils = MouseUtils;
});
define("src/app/relution/view/world/management/RelutionMapObjectModelBinder", ["require", "exports", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, RelutionMapObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings) {
            // Observation
            this.observers = new Array();
            // Metadata: Layer-object bindnig
            this.bindings = new Array();
            // Factory
            this.modelFactory = null;
            this.objectFactory = null;
            this.config = config;
            this.environment = environment;
            this.floorplanLayer = floorplanLayer;
            this.bindings = bindings;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        getObservers() {
            return this.observers;
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Factories
        setModelFactory(factory) {
            this.modelFactory = factory;
        }
        getModelFactory() {
            return this.modelFactory;
        }
        setObjectFactory(factory) {
            this.objectFactory = factory;
        }
        getObjectFactory() {
            return this.objectFactory;
        }
        // Binding object model
        bindObjectToModel(model) {
            // 1. Get view class
            let viewClass = this.getViewClassForModel(model);
            if (viewClass === null) {
                throw new Error("Failed to find a corresponding view class for model " + model);
            }
            // 2. Create view configuration
            let config = this.createConfigForView(viewClass);
            // 3. Create view
            let view = null;
            if (this.objectFactory !== null) {
                view = this.objectFactory(model, config);
            }
            else {
                view = new viewClass(config, this.environment, this.floorplanLayer, model);
            }
            view.addObserver(this);
            return view;
        }
        getViewClassForModel(model) {
            let modelClass = model.constructor;
            for (let i = 0; i < RelutionMapObject_3.RelutionMapObject.viewModelClassMappings.length; i++) {
                let viewModelClassMapping = RelutionMapObject_3.RelutionMapObject.viewModelClassMappings[i];
                if (viewModelClassMapping.modelClass === modelClass) {
                    let viewClass = viewModelClassMapping.viewClass;
                    if (this.containsBindingToObjectClass(viewClass)) {
                        return viewClass;
                    }
                    else {
                        throw new Error("Layer class does not have a binding for object class " + viewClass);
                    }
                }
            }
            return null;
        }
        containsBindingToObjectClass(objectClass) {
            for (let i = 0; i < this.bindings.length; i++) {
                let binding = this.bindings[i];
                for (let j = 0; j < binding.objectClasses.length; j++) {
                    let currentObjectClass = binding.objectClasses[j];
                    if (currentObjectClass === objectClass) {
                        return true;
                    }
                }
            }
            return false;
        }
        createConfigForView(viewClass) {
            let config = new RelutionMapObject_3.RelutionMapObject.Config();
            // 1. Edit mode
            config.editModeActive = this.config.editModeEnabled;
            // 2. Object type visibility
            if (this.config.objectTypeVisibility.hasOwnProperty(viewClass.name)) {
                config.visible = this.config.objectTypeVisibility[viewClass.name];
            }
            else {
                config.visible = true;
            }
            return config;
        }
        // Unbinding object model
        unbindObjectToModel(view) {
            view.removeObserver(this);
        }
        getObjectWithUuid(uuid) {
            for (let i = 0; i < this.getObjects().length; i++) {
                let object = this.getObjects()[i];
                if (object.getModel().uuid === uuid) {
                    return object;
                }
            }
            return null;
        }
        getObjectWithModel(model) {
            for (let i = 0; i < this.getObjects().length; i++) {
                let object = this.getObjects()[i];
                if (object.getModel().uuid === model.uuid) {
                    return object;
                }
            }
            return null;
        }
        existsObject(view) {
            let views = this.getObjects();
            for (let i = 0; i < views.length; i++) {
                let currentView = views[i];
                if (view === currentView) {
                    return true;
                }
            }
            return false;
        }
        containsObject(objects, object) {
            for (let i = 0; i < objects.length; i++) {
                let currentObject = objects[i];
                if (object === currentObject) {
                    return true;
                }
            }
            return false;
        }
        getAllVisibleObjects() {
            let allVisibleViews = new Array();
            let views = this.getObjects();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                if (view.getModel().visible) {
                    allVisibleViews.push(view);
                }
            }
            return allVisibleViews;
        }
    }
    exports.RelutionMapObjectModelBinder = RelutionMapObjectModelBinder;
});
define("src/app/relution/view/world/management/ViewModelBinderDelegate", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("src/app/relution/view/world/management/ViewModelBinder", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Binds a set of models to views.
     * Whenever a new set of models is loaded, the views will be synchronized.
     *
     * @export
     * @class ViewModelBinder
     * @template M The model type
     * @template V The view type
     */
    class ViewModelBinder {
        // Construction
        constructor(delegate) {
            // Observation
            this.observers = new Array();
            // Models
            this.models = new Array();
            // Views
            this.viewsOnMap = new Array();
            this.viewsInStock = new Array();
            this.delegate = delegate;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        getObservers() {
            return this.observers;
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Load views
        loadViews(models) {
            let removedViews = this.getAllViews();
            this.notifyObservers("onBeforeViewsLoaded", []);
            this.removeAllViews();
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                this.addViewForModel(model);
            }
            this.notifyObservers("onAfterViewsLoaded", []);
            this.notifyObservers("onViewsUnloaded", [removedViews]);
            this.notifyObservers("onViewsLoaded", [this.getAllViews()]);
        }
        // Update views
        updateViews(models) {
            this.models = models;
            // Notify observers
            this.notifyObservers("onBeforeViewsUpdated", []);
            let removedViews = this.removeViewsNotExistingAnymore(models);
            let updatedViews = this.updateExistingViews(models);
            let addedViews = this.addViews(models);
            // Notify observers
            this.notifyObservers("onAfterViewsUpdated", []);
            this.notifyObservers("onViewsLoaded", [addedViews]);
            this.notifyObservers("onViewsUnloaded", [removedViews]);
        }
        // Add views
        addViews(models) {
            let addedViews = [];
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let uuid = model.uuid;
                let view = this.getViewWithUuid(uuid);
                if (view == null) {
                    if (!model.hasUnknownPosition()) {
                        this.addViewForModel(model);
                        view = this.getViewWithUuid(uuid);
                        if (view !== null) {
                            addedViews.push(view);
                        }
                    }
                }
            }
            return addedViews;
        }
        addViewsForModels(models) {
            let addedViews = [];
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let view = this.addViewForModel(model);
                if (view !== null) {
                    addedViews.push(view);
                }
            }
            return addedViews;
        }
        addViewForModel(model) {
            try {
                if (!model.hasUnknownPosition()) {
                    let view = this.delegate.createViewForModel(model);
                    if (model.isOnMap()) {
                        this.setViewToMap(view);
                        this.notifyObservers("onViewSetToMap", [view]);
                    }
                    else {
                        this.setViewToStock(view);
                        this.notifyObservers("onViewSetToStock", [view]);
                    }
                    return view;
                }
                else {
                    return null;
                }
            }
            catch (e) {
                Logger_3.Logger.logDebug("Failed to add view for model " + model + ". " + e);
            }
            return null;
        }
        // Updating views
        updateExistingViews(models) {
            let updatedViews = [];
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let uuid = model.uuid;
                let view = this.getViewWithUuid(uuid);
                if (view != null) {
                    if (!model.hasUnknownPosition()) {
                        updatedViews.push(view);
                        view.updateModel(model);
                    }
                }
            }
            return updatedViews;
        }
        // Remove views
        removeAllViews() {
            let removedViews = this.getAllViews();
            for (let i = 0; i < this.viewsOnMap.length; i++) {
                let view = this.viewsOnMap[i];
                let removed = this.removeViewOnMap(view);
                if (removed) {
                    i--;
                }
            }
            for (let i = 0; i < this.viewsInStock.length; i++) {
                let view = this.viewsInStock[i];
                let removed = this.removeViewInStock(view);
                if (removed) {
                    i--;
                }
            }
            this.viewsOnMap = new Array();
            this.viewsInStock = new Array();
            return removedViews;
        }
        removeViewsNotExistingAnymore(models) {
            let removedViews = [];
            let views = this.getAllViews();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                let uuid = view.getModel().uuid;
                let newModel = this.getModelWithUuid(uuid, models);
                if (newModel == null || newModel.hasUnknownPosition()) {
                    removedViews.push(view);
                    this.removeView(view);
                }
            }
            return removedViews;
        }
        removeView(view) {
            if (view.getModel().isOnMap()) {
                return this.removeViewOnMap(view);
            }
            else {
                return this.removeViewInStock(view);
            }
        }
        removeViewOnMap(view) {
            let index = this.viewsOnMap.indexOf(view, 0);
            if (index > -1) {
                this.viewsOnMap.splice(index, 1);
                this.delegate.removeViewFromMap(view);
                this.delegate.destroyView(view);
                return true;
            }
            return false;
        }
        removeViewInStock(view) {
            let index = this.viewsInStock.indexOf(view, 0);
            if (index > -1) {
                this.viewsInStock.splice(index, 1);
                this.delegate.destroyView(view);
                return true;
            }
            return false;
        }
        // Accessing
        existsModelForView(view, models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                if (this.isViewMatchingModel(view, model)) {
                    return true;
                }
            }
            return false;
        }
        getAllViews() {
            let allViews = new Array();
            for (let i = 0; i < this.viewsOnMap.length; i++) {
                let view = this.viewsOnMap[i];
                allViews.push(view);
            }
            for (let i = 0; i < this.viewsInStock.length; i++) {
                let view = this.viewsInStock[i];
                allViews.push(view);
            }
            return allViews;
        }
        getAllVisibleViews() {
            let visibleViews = new Array();
            let allViews = this.getAllViews();
            for (let i = 0; i < allViews.length; i++) {
                let view = allViews[i];
                if (view.getModel().visible) {
                    visibleViews.push(view);
                }
            }
            return visibleViews;
        }
        getViewWithUuid(uuid) {
            let allViews = this.getAllViews();
            for (let i = 0; i < allViews.length; i++) {
                let view = allViews[i];
                if (view.getModel().uuid === uuid) {
                    return view;
                }
            }
            return null;
        }
        getModelWithUuid(uuid, models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                if (model.uuid === uuid) {
                    return model;
                }
            }
            return null;
        }
        // Map <-> Stock change
        moveViewToMap(view) {
            this.setViewToMap(view);
            this.notifyObservers("onViewMovedToMap", [view]);
        }
        setViewToMap(view) {
            // If view is already in map, do not change anything.
            if (!this.isViewOnMap(view)) {
                // If view is in stock, remove it from the list.
                let index = this.viewsInStock.indexOf(view, 0);
                if (index > -1) {
                    this.viewsInStock.splice(index, 1);
                }
                this.viewsOnMap.push(view);
                this.delegate.addViewToMap(view);
            }
        }
        moveViewToStock(view) {
            this.setViewToStock(view);
            this.notifyObservers("onViewMovedToStock", [view]);
        }
        setViewToStock(view) {
            // If view is already in stock, do not change anything.
            if (!this.isViewInStock(view)) {
                // If view is on map, remove it from the list.
                let index = this.viewsOnMap.indexOf(view, 0);
                if (index > -1) {
                    this.viewsOnMap.splice(index, 1);
                }
                this.delegate.removeViewFromMap(view);
                this.viewsInStock.push(view);
            }
        }
        isViewOnMap(view) {
            let index = this.viewsOnMap.indexOf(view, 0);
            return index >= 0;
        }
        isViewInStock(view) {
            let index = this.viewsInStock.indexOf(view, 0);
            return index >= 0;
        }
        getViewsOnMap() {
            return this.viewsOnMap;
        }
        getVisibleViewsOnMap() {
            let visibleViewsOnMap = new Array();
            for (let i = 0; i < this.viewsOnMap.length; i++) {
                let view = this.viewsOnMap[i];
                if (view.getModel().visible) {
                    visibleViewsOnMap.push(view);
                }
            }
            return visibleViewsOnMap;
        }
        getViewsInStock() {
            return this.viewsInStock;
        }
        // Binding
        isViewMatchingModel(view, model) {
            return view.getModel().uuid === model.uuid;
        }
        // Getters and setters
        getModels() {
            return this.models;
        }
        getViews() {
            return this.getAllViews();
        }
    }
    exports.ViewModelBinder = ViewModelBinder;
});
define("src/app/relution/view/world/management/AutonomousObjectModelBinder", ["require", "exports", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/view/world/management/ViewModelBinder"], function (require, exports, RelutionMapObjectModelBinder_1, ViewModelBinder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AutonomousObjectModelBinder extends RelutionMapObjectModelBinder_1.RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings, parentSceneObject) {
            super(config, environment, floorplanLayer, bindings);
            this.viewModelBinder = new ViewModelBinder_1.ViewModelBinder(this);
            this.viewModelBinder.addObserver(this);
            this.parentSceneObject = parentSceneObject;
        }
        // View-Model binding
        // @Override
        loadModels(models) {
            this.viewModelBinder.loadViews(models);
        }
        // @Override
        updateModels(models) {
            this.viewModelBinder.updateViews(models);
        }
        // @Override
        createViewForModel(model) {
            return this.bindObjectToModel(model);
        }
        // Object observation
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        onObjectMoveStarted(object, x, y) {
            this.notifyObservers("onObjectMoveStarted", [object, x, y]);
        }
        onObjectMoveChanged(object, x, y) {
            this.notifyObservers("onObjectMoveChanged", [object, x, y]);
        }
        onObjectMoveStopped(object, x, y) {
            this.notifyObservers("onObjectMoveStopped", [object, x, y]);
        }
        // View-Model binder delegate methods
        // @Override
        addViewToMap(view) {
            this.parentSceneObject.addChild(view);
            this.notifyObservers("onObjectAddedToMap", [view]);
        }
        // @Override
        removeViewFromMap(view) {
            this.parentSceneObject.removeChild(view);
            this.notifyObservers("onObjectRemovedFromMap", [view]);
        }
        // @Override
        destroyView(view) {
            view.destroy();
        }
        // View-Model binder observation
        onBeforeViewsLoaded(objects) {
            this.notifyObservers("onBeforeObjectsLoaded", [objects]);
        }
        onAfterViewsLoaded(objects) {
            this.notifyObservers("onAfterObjectsLoaded", [objects]);
        }
        onBeforeViewsUpdated(objects) {
            this.notifyObservers("onBeforeObjectsUpdated", [objects]);
        }
        onAfterViewsUpdated(objects) {
            this.notifyObservers("onAfterObjectsUpdated", [objects]);
        }
        onViewsLoaded(objects) {
            this.notifyObservers("onObjectsLoaded", [objects]);
        }
        onViewsUnloaded(objects) {
            this.notifyObservers("onObjectsUnloaded", [objects]);
        }
        onViewSetToMap(object) {
            this.notifyObservers("onObjectSetToMap", [object]);
        }
        onViewSetToStock(object) {
            this.notifyObservers("onObjectSetToStock", [object]);
        }
        onViewMovedToMap(object) {
            this.notifyObservers("onObjectMovedToMap", [object]);
        }
        onViewMovedToStock(object) {
            this.notifyObservers("onObjectMovedToStock", [object]);
        }
        // Accessing objects
        getObjects() {
            return this.viewModelBinder.getViews();
        }
        getObjectsOnMap() {
            return this.viewModelBinder.getViewsOnMap();
        }
        getObjectsInStock() {
            return this.viewModelBinder.getViewsInStock();
        }
        // Changing object state
        moveObjectToMap(object) {
            this.viewModelBinder.moveViewToMap(object);
        }
        moveObjectToStock(object) {
            this.viewModelBinder.moveViewToStock(object);
        }
    }
    exports.AutonomousObjectModelBinder = AutonomousObjectModelBinder;
});
define("src/app/relution/view/world/RelutionMapAttributeObjectLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, FloorplanRelatedLayer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Binds this layer containing Relution map attribute objects to the Relution map object layer.
     * Whenever a Relution map object will be created/deleted/modified, all Relution map attribute objects
     * that existentially depend on the Relution map object, will be created/deleted/modified, as well.
     *
     * @export
     * @class RelutionMapAttributeObjectLayer
     * @extends {FloorplanRelatedLayer}
     */
    class RelutionMapAttributeObjectLayer extends FloorplanRelatedLayer_3.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, relutionMapObjectLayer, floorplanLayer = undefined) {
            super(environment, floorplanLayer !== undefined ? floorplanLayer : (relutionMapObjectLayer !== undefined ? relutionMapObjectLayer.getFloorplanLayer() : undefined));
            // Relution map attribute objects
            this.attributeObjects = new Array();
            this.setTargetLayer(this);
            if (relutionMapObjectLayer !== undefined) {
                relutionMapObjectLayer.addObserver(this);
            }
        }
        // Event-Handling: Relution map object layer
        // @Override
        onObjectsLoaded(objects) {
            this.loadAttributeObjects(objects);
        }
        // @Override
        onObjectsUnloaded(objects) {
            this.removeAttributeObjectsForMapObjects(objects);
        }
        // @Override
        onObjectMovedToMap(object) {
            this.updateAttributeObjectVisibility(object);
        }
        // @Override
        onObjectMovedToStock(object) {
            this.updateAttributeObjectVisibility(object);
        }
        // Loading attribute objects
        loadAttributeObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                this.loadAttributeObjectsForMapObject(object);
            }
        }
        loadAttributeObjectsForMapObject(object) {
            let attributeObjects = this.createAttributeObjectsForObject(object);
            for (let j = 0; j < attributeObjects.length; j++) {
                let attributeObject = attributeObjects[j];
                this.attributeObjects.push(attributeObject);
                this.getTargetLayer().addChild(attributeObject);
                this.updateAttributeObjectVisibility(object);
            }
        }
        // Unloading attribute objects
        removeAttributeObjectsForMapObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                this.removeAttributeObjectsForMapObject(object);
            }
        }
        removeAttributeObjectsForMapObject(object) {
            for (let i = 0; i < this.attributeObjects.length; i++) {
                let attributeObject = this.attributeObjects[i];
                if (attributeObject.dependsOnObject(object)) {
                    this.removeAttributeObject(attributeObject);
                    i--;
                }
            }
        }
        removeAttributeObject(attributeObject) {
            const index = this.attributeObjects.indexOf(attributeObject);
            if (index >= 0) {
                this.attributeObjects.splice(index, 1);
                attributeObject.getParent().removeChild(attributeObject);
                attributeObject.destroy();
            }
        }
        // Accessing attribute objects
        getAttributeObjects() {
            return this.attributeObjects;
        }
        getAttributeObjectsForObject(object) {
            let result = new Array();
            for (let i = 0; i < this.attributeObjects.length; i++) {
                let attributeObject = this.attributeObjects[i];
                if (attributeObject.dependsOnObject(object)) {
                    result.push(attributeObject);
                }
            }
            return result;
        }
        // Updating visibility
        updateAttributeObjectVisibility(object) {
            let attributeObjects = this.getAttributeObjectsForObject(object);
            for (let i = 0; i < attributeObjects.length; i++) {
                let attributeObject = attributeObjects[i];
                let dependentObjects = attributeObject.getDependentObjects();
                if (this.allObjectsVisible(dependentObjects)) {
                    attributeObject.getView().visible = true;
                }
                else {
                    attributeObject.getView().visible = false;
                }
            }
        }
        allObjectsVisible(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (!object.getModel().isOnMap()) {
                    return false;
                }
            }
            return true;
        }
        // Target Layer
        // The Layer where the attribute objects are added as children. Default: this
        setTargetLayer(targetLayer) {
            this.targetLayer = targetLayer;
        }
        getTargetLayer() {
            return this.targetLayer;
        }
    }
    exports.RelutionMapAttributeObjectLayer = RelutionMapAttributeObjectLayer;
});
define("src/app/relution/utils/UuidUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UuidUtils {
        static randomUuid() {
            var dt = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (dt + Math.random() * 16) % 16 | 0;
                dt = Math.floor(dt / 16);
                return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
            return uuid;
        }
    }
    exports.UuidUtils = UuidUtils;
});
define("src/app/relution/view/world/management/CoupledObjectModelBinder", ["require", "exports", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/utils/UuidUtils"], function (require, exports, RelutionMapObjectModelBinder_2, RelutionMapObjectModel_2, RelutionMapAttributeObjectLayer_1, UuidUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * <h1>
     * Binds the Relution map objects to their corresponding models.
     * </h1>
     *
     * <p>
     * In contrast to the autonomous model binder, this model binder is coupled to the life cycle
     * of a superordinate layer, it is existentially depending on.
     * Whenever an object is created in the superior layer, this model binder will be notified
     * and ordered to create the Relution map objects of the generic type V that should existentially
     * depend on the superior object.
     * Hence, in contrast to the autonomous model binder, object creation will not be triggered by
     * model injection directly, but by the creation of objects in the superior layer.
     * </p>
     */
    class CoupledObjectModelBinder extends RelutionMapObjectModelBinder_2.RelutionMapObjectModelBinder {
        // Construction
        constructor(config, environment, floorplanLayer, bindings, targetLayer, superiorLayer) {
            super(config, environment, floorplanLayer, bindings);
            // Model
            this.models = new Array();
            this.targetLayer = targetLayer;
            this.superiorLayer = superiorLayer;
            this.attributeLayer = new CoupledObjectModelBinder.DependentAttributeObjectLayer(environment, this, superiorLayer, floorplanLayer);
            this.attributeLayer.setTargetLayer(this.targetLayer);
        }
        // Loading object models
        loadModels(models) {
            this.models = models;
            this.updateViewsForModels(models);
        }
        updateModels(models) {
            this.models = models;
            this.updateViewsForModels(models);
        }
        updateViewsForModels(models) {
            // 1. Removing models:
            this.removeViewsNotExistingAnymore(models);
            // 2. Existing models:
            // Models that already have an existing view, will be updated normally.
            this.updateExistingViewsForModels(models);
            // 3. Added models:
            // Views will only be created for new models, if the superordinate
            // layer, already has matching map objects.
            this.createViewsForMatchingModels(models);
        }
        removeViewsNotExistingAnymore(models) {
            let objects = this.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                let model = this.getModelWithUuid(models, object.getModel().uuid);
                if (model === null) {
                    this.unbindObjectToModel(object);
                    this.attributeLayer.unloadAttributeObject(object);
                }
            }
        }
        getModelWithUuid(models, uuid) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                if (model.uuid === uuid) {
                    return model;
                }
            }
            return null;
        }
        updateExistingViewsForModels(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getObjectWithModel(model);
                if (object !== null) {
                    object.updateModel(model);
                }
            }
        }
        createViewsForMatchingModels(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getObjectWithModel(model);
                if (object === null) {
                    let parentModelUuid = model.parentUuid;
                    let parentObject = this.superiorLayer.getObjectWithUuid(parentModelUuid);
                    if (parentObject !== null) {
                        this.attributeLayer.loadAttributeObjectsForSuperiorObject(parentObject);
                    }
                }
            }
        }
        // Model access
        getModelsWithParentModel(parentModel) {
            let models = [];
            for (let i = 0; i < this.models.length; i++) {
                let model = this.models[i];
                if (model.parentUuid === parentModel.uuid) {
                    models.push(model);
                }
            }
            return models;
        }
        // Object access
        // @Override
        getObjects() {
            return this.attributeLayer.getAttributeObjects();
        }
        // @Override
        getObjectsOnMap() {
            let objects = this.getObjects();
            let objectsOnMap = [];
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (object.isOnMap()) {
                    objectsOnMap.push(object);
                }
            }
            return objectsOnMap;
        }
        // @Override
        getObjectsInStock() {
            let objects = this.getObjects();
            let objectsInStock = [];
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                if (!object.isOnMap()) {
                    objectsInStock.push(object);
                }
            }
            return objectsInStock;
        }
        // Object state change
        moveObjectToMap(object) {
            // Not allowed, only Relution map object layers using the autonomous object-model binding,
            // are allowed to move objects into map or stock.
        }
        moveObjectToStock(object) {
            // Not allowed, only Relution map object layers using the autonomous object-model binding,
            // are allowed to move objects into map or stock.
        }
    }
    exports.CoupledObjectModelBinder = CoupledObjectModelBinder;
    (function (CoupledObjectModelBinder) {
        class DependentAttributeObjectLayer extends RelutionMapAttributeObjectLayer_1.RelutionMapAttributeObjectLayer {
            // Construction
            constructor(environment, modelBinder, superiorLayer, floorplanLayer = undefined) {
                super(environment, superiorLayer, floorplanLayer);
                // Configuration
                /**
                 * If true, an object of the subordinate layer will be created with default parameters, a random UUID and
                 * a matching parent UUID, whenever an object of the superior layer has been created.
                 * Thus, if the paramter is set to true, model injection is not required explicitly.
                 */
                this.createModelsImplicitly = true;
                this.modelBinder = modelBinder;
                this.superiorLayer = superiorLayer;
            }
            // Loading attribute objects
            /**
             * Explicitly triggers the attribute object creation for the specified superior object.
             * @param superiorObject
             */
            loadAttributeObjectsForSuperiorObject(superiorObject) {
                this.loadAttributeObjectsForMapObject(superiorObject);
            }
            // @Override
            createAttributeObjectsForObject(object) {
                if (this.createModelsImplicitly) {
                    return this.createAttributeObjectsWithImplicitModelCreation(object);
                }
                else {
                    return this.createAttributeObjectsForExplicitlyInjectedModels(object);
                }
            }
            createAttributeObjectsWithImplicitModelCreation(parentObject) {
                let parentModel = parentObject.getModel();
                let modelFactory = this.modelBinder.getModelFactory();
                let model = null;
                if (modelFactory === null) {
                    model = new RelutionMapObjectModel_2.RelutionMapObjectModel();
                }
                else {
                    model = modelFactory(parentModel);
                }
                if (model !== null) {
                    if (model.uuid === null) {
                        model.uuid = UuidUtils_1.UuidUtils.randomUuid();
                    }
                    if (model.parentUuid === null) {
                        model.parentUuid = parentModel.uuid;
                    }
                    this.modelBinder.models.push(model);
                    let object = this.modelBinder.bindObjectToModel(model);
                    return [object];
                }
                else {
                    return [];
                }
            }
            createAttributeObjectsForExplicitlyInjectedModels(parentObject) {
                let parentModel = parentObject.getModel();
                let childModels = this.modelBinder.getModelsWithParentModel(parentModel);
                let objects = [];
                for (let childModel of childModels) {
                    let object = this.modelBinder.bindObjectToModel(childModel);
                    objects.push(object);
                }
                return objects;
            }
            // Unloading attribute object
            unloadAttributeObject(attributeObject) {
                this.removeAttributeObject(attributeObject);
            }
        }
        CoupledObjectModelBinder.DependentAttributeObjectLayer = DependentAttributeObjectLayer;
    })(CoupledObjectModelBinder = exports.CoupledObjectModelBinder || (exports.CoupledObjectModelBinder = {}));
});
define("src/app/relution/view/world/RelutionMapObjectLayer", ["require", "exports", "src/app/relution/utils/MouseUtils", "src/app/relution/view/world/management/AutonomousObjectModelBinder", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/management/CoupledObjectModelBinder"], function (require, exports, MouseUtils_1, AutonomousObjectModelBinder_1, FloorplanRelatedLayer_4, CoupledObjectModelBinder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Base class for all layers maintaining Relution map objects.
     *
     * @export
     * @class RelutionMapObjectLayer
     * @extends {Layer}
     */
    class RelutionMapObjectLayer extends FloorplanRelatedLayer_4.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer, dependingMapObjectLayer = undefined) {
            super(environment, floorplanLayer);
            // Object-Model binding
            this.objectModelBinder = null;
            // State
            this.mouseCursorChanged = false;
            this.hoveringObject = null;
            this.objectOfCurrentEditablePoint = null;
            this.editingObject = null;
            this.movingObject = null;
            this.config = config;
            let bindings = this.initLayerObjectClassBinder();
            this.initObjectModelBinder(dependingMapObjectLayer, config, floorplanLayer, bindings);
        }
        initLayerObjectClassBinder() {
            // Only bind the classes that are bound to the layer's class.
            let myBindings = this.getBindingsForThisClass();
            for (let i = 0; i < myBindings.length; i++) {
                let objectClass = myBindings[i];
                // We enforce a class load by calling an empty function on it.
                objectClass.__initialize = function () { };
                objectClass.__initialize();
            }
            return myBindings;
        }
        getBindingsForThisClass() {
            let myBindings = [];
            for (let i = 0; i < RelutionMapObjectLayer.allBindings.length; i++) {
                let binding = RelutionMapObjectLayer.allBindings[i];
                if (binding.layerClass === this.constructor) {
                    myBindings.push(binding);
                }
            }
            return myBindings;
        }
        initObjectModelBinder(dependingMapObjectLayer, config, floorplanLayer, bindings) {
            if (dependingMapObjectLayer === undefined) {
                this.objectModelBinder = new AutonomousObjectModelBinder_1.AutonomousObjectModelBinder(config, this.getEnvironment(), floorplanLayer, bindings, this);
            }
            else {
                this.objectModelBinder = new CoupledObjectModelBinder_1.CoupledObjectModelBinder(config, this.getEnvironment(), floorplanLayer, bindings, this, dependingMapObjectLayer);
            }
        }
        // Observation
        addObserver(observer) {
            this.objectModelBinder.addObserver(observer);
        }
        removeObserver(observer) {
            this.objectModelBinder.removeObserver(observer);
        }
        getObservers() {
            return this.objectModelBinder.getObservers();
        }
        // Loading object models
        loadModels(models) {
            this.objectModelBinder.loadModels(models);
        }
        updateModels(models) {
            this.objectModelBinder.updateModels(models);
        }
        setModelFactory(factory) {
            this.objectModelBinder.setModelFactory(factory);
        }
        setObjectFactory(factory) {
            this.objectModelBinder.setObjectFactory(factory);
        }
        // Object access
        getObjectWithUuid(uuid) {
            return this.objectModelBinder.getObjectWithUuid(uuid);
        }
        existsObject(view) {
            return this.objectModelBinder.existsObject(view);
        }
        containsObject(objects, object) {
            return this.objectModelBinder.containsObject(objects, object);
        }
        getObjects() {
            return this.objectModelBinder.getObjects();
        }
        getObjectsOnMap() {
            return this.objectModelBinder.getObjectsOnMap();
        }
        getObjectsInStock() {
            return this.objectModelBinder.getObjectsInStock();
        }
        getAllVisibleObjects() {
            return this.objectModelBinder.getAllVisibleObjects();
        }
        moveObjectToMap(object) {
            this.objectModelBinder.moveObjectToMap(object);
        }
        moveObjectToStock(object) {
            this.objectModelBinder.moveObjectToStock(object);
        }
        // Hovering
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.isVisibleInWorld()) {
                this.changeEditPointVisibility(x, y);
                this.changeHoveringObjectIfNecessary(x, y);
            }
            this.changeMouseCursorIfNecessary(x, y);
            return false;
        }
        changeEditPointVisibility(x, y) {
            let object = this.getObjectEditableOnPoint(x, y);
            if (object !== null) {
                if (this.objectOfCurrentEditablePoint !== object) {
                    if (this.objectOfCurrentEditablePoint !== null) {
                        this.objectOfCurrentEditablePoint.setMouseAboveEditPoint(false);
                        this.objectOfCurrentEditablePoint = null;
                    }
                    this.objectOfCurrentEditablePoint = object;
                    this.objectOfCurrentEditablePoint.setMouseAboveEditPoint(true);
                }
            }
            else {
                if (this.objectOfCurrentEditablePoint !== null) {
                    let objects = this.getObjects();
                    for (let i = 0; i < objects.length; i++) {
                        let currentObject = objects[i];
                        currentObject.setMouseAboveEditPoint(false);
                    }
                    this.objectOfCurrentEditablePoint = null;
                }
            }
        }
        changeHoveringObjectIfNecessary(x, y) {
            let collidingObject = this.getCollidingObject(x, y);
            if (collidingObject !== null) {
                if (this.hoveringObject !== collidingObject) {
                    if (this.hoveringObject !== null) {
                        this.hoveringObject.setMouseOver(false);
                        this.hoveringObject = null;
                    }
                    this.hoveringObject = collidingObject;
                    this.hoveringObject.setMouseOver(true);
                }
            }
            else {
                if (this.hoveringObject !== null) {
                    this.hoveringObject.setMouseOver(false);
                    this.hoveringObject = null;
                }
            }
            return false;
        }
        changeMouseCursorIfNecessary(x, y) {
            if (this.isEditModeActive()) {
                this.handleMouseMove(x, y);
                return false;
            }
            else {
                return false;
            }
        }
        handleMouseMove(x, y) {
            if (this.isVisibleInWorld()) {
                if (this.isPointAboveEditPoint(x, y)) {
                    MouseUtils_1.MouseUtils.changeToMoveCursorStyle();
                    this.mouseCursorChanged = true;
                }
                else if (this.isPointCollidingWithObject(x, y)) {
                    MouseUtils_1.MouseUtils.changeToHandCursorStyle();
                    this.mouseCursorChanged = true;
                }
                else {
                    if (this.mouseCursorChanged === true) {
                        MouseUtils_1.MouseUtils.changeToDefaultCursorStyle();
                        this.mouseCursorChanged = false;
                    }
                }
            }
            else {
                if (this.mouseCursorChanged === true) {
                    MouseUtils_1.MouseUtils.changeToDefaultCursorStyle();
                    this.mouseCursorChanged = false;
                }
            }
        }
        // Editing
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchStart(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchStart(x, y) {
            if (this.isPointAboveEditPoint(x, y)) {
                this.editingObject = this.getObjectEditableOnPoint(x, y);
                this.editingObject.onEditStart(x, y);
                return true;
            }
            else if (this.isPointCollidingWithObject(x, y)) {
                let object = this.getCollidingObject(x, y, (object) => {
                    return object.isMovable();
                });
                if (object !== null) {
                    this.movingObject = object;
                    this.movingObject.onMoveStarted(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchMove(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchMove(x, y) {
            if (this.editingObject !== null) {
                this.editingObject.onEditMove(x, y);
                return true;
            }
            else if (this.movingObject !== null) {
                this.movingObject.onMoveChanged(x, y);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchEnd(x, y);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchEnd(x, y) {
            if (this.editingObject !== null) {
                this.editingObject.onEditStop(x, y);
                this.editingObject = null;
                return true;
            }
            else if (this.movingObject !== null) {
                this.movingObject.onMoveStopped(x, y);
                this.movingObject = null;
                return true;
            }
            else {
                return false;
            }
        }
        // Collision detection
        /**
         * Returns the object that succeeds the intersection test on the screen position (x,y) first.
         * @param x \in [0, screenWidth]
         * @param y \in [0, screenHeight]
         * @param condition An additional condition the object must fulfill to pass the hit test.
         * If no additional condition is required, pass undefined.
         */
        getCollidingObject(x, y, condition = undefined) {
            if (this.isVisibleInWorld()) {
                let objects = this.objectModelBinder.getAllVisibleObjects();
                for (let i = 0; i < objects.length; i++) {
                    let view = objects[i];
                    if (condition === undefined || condition(view)) {
                        if (view.intersectsPointInScreenPx(x, y)) {
                            return view;
                        }
                    }
                }
                return null;
            }
            return null;
        }
        isPointCollidingWithObject(x, y) {
            let object = this.getCollidingObject(x, y);
            return object !== null;
        }
        getObjectEditableOnPoint(x, y) {
            if (this.isVisibleInWorld()) {
                let objects = this.objectModelBinder.getAllVisibleObjects();
                for (let i = 0; i < objects.length; i++) {
                    let view = objects[i];
                    if (view.pointIsCloseToEditableArea(x, y)) {
                        return view;
                    }
                }
                return null;
            }
            return null;
        }
        isPointAboveEditPoint(x, y) {
            let object = this.getObjectEditableOnPoint(x, y);
            return object !== null;
        }
        // Visibility
        toggleObjectVisibility(uuid) {
            let view = this.getObjectWithUuid(uuid);
            if (view != null) {
                // Change visibility field in model.
                // All object related objects should become invisible now.
                let visible = !view.getModel().visible;
                let model = view.getModel();
                model.visible = visible;
            }
        }
        toggleObjectTypeVisibility(objectTypeName, visible) {
            // 1. Update map
            this.config.objectTypeVisibility[objectTypeName] = visible;
            // 1. Update views
            let objects = this.objectModelBinder.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let view = objects[i];
                let instance = view.constructor;
                if (instance.name === objectTypeName) {
                    view.getModel().visible = visible;
                }
            }
        }
        // Modes
        setEditModeActive(editModeActive) {
            this.config.editModeEnabled = editModeActive;
            let objects = this.objectModelBinder.getObjectsOnMap();
            for (let i = 0; i < objects.length; i++) {
                let view = objects[i];
                view.setEditModeActive(editModeActive);
            }
        }
        isEditModeActive() {
            return this.config.editModeEnabled;
        }
    }
    // Metadata: Binds Relution map object classes to their corresponding layers via decorator
    RelutionMapObjectLayer.allBindings = new Array();
    exports.RelutionMapObjectLayer = RelutionMapObjectLayer;
    (function (RelutionMapObjectLayer) {
        class Binding {
            constructor(layerClass, objectClasses) {
                this.layerClass = null;
                this.objectClasses = null;
                this.layerClass = layerClass;
                this.objectClasses = objectClasses;
            }
        }
        RelutionMapObjectLayer.Binding = Binding;
        class Config {
            constructor() {
                /**
                 * True, if edit mode should be enabled from the beginning.
                 *
                 * Default: false
                 */
                this.editModeEnabled = false;
                this.objectTypeVisibility = {};
            }
        }
        RelutionMapObjectLayer.Config = Config;
    })(RelutionMapObjectLayer = exports.RelutionMapObjectLayer || (exports.RelutionMapObjectLayer = {}));
    /**
     * Decorator to bind Relution map object classes to Relution map object layers.
     * @param relutionMapObjectClass
     */
    function RelutionMapObjectBinding(...objectClasses) {
        return function (layerClass) {
            RelutionMapObjectLayer.allBindings.push((new RelutionMapObjectLayer.Binding(layerClass, objectClasses)));
        };
    }
    exports.RelutionMapObjectBinding = RelutionMapObjectBinding;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/app/relution/model/device/DeviceModel", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture"], function (require, exports, Device_2, DeviceModel_2, DeviceUtils_4, RelutionMapObject_4, SpriteObject_5, Texture_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Asset_1;
    let Asset = Asset_1 = class Asset extends Device_2.Device {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.initSpriteView();
            this.setMinDeviceSizeInPixels(15);
            this.setMaxDeviceSizeInMeter(1.5);
        }
        initSpriteView() {
            this.spriteView = new SpriteObject_5.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.spriteView);
            // Texture
            this.loadTexture("asset_device_white");
            this.updateSpriteTexture();
            // Pivot
            this.spriteView.pivot.x = this.spriteView.width / 2;
            this.spriteView.pivot.y = this.spriteView.height;
            // Scale
            let targetWidth = DeviceUtils_4.DeviceUtils.getPhysicalPixelsFromLogical(40);
            let targetHeight = this.spriteView.texture.height * (targetWidth / this.spriteView.texture.width);
            this.spriteView.width = targetWidth;
            this.spriteView.height = targetHeight;
        }
        loadTexture(textureName) {
            let texture = PIXI.loader.resources["" + textureName].texture;
            texture.baseTexture.mipmap = true;
            this.spriteView.texture = new Texture_5.Texture(texture, this.getEnvironment().renderingEnvironment);
        }
        // Redrawing
        // @Override
        redraw() {
            this.updateSpriteTexture();
        }
        updateSpriteTexture() {
            if (this.isSelected()) {
                this.spriteView.tint = Asset_1.SELECTED_COLOR;
            }
            else if (this.isInactive()) {
                this.spriteView.tint = Asset_1.INACTIVE_COLOR;
            }
            else {
                this.spriteView.tint = Asset_1.NORMAL_COLOR;
            }
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            // Asset moving is unsupported
        }
        // @Override
        onMoveChanged(x, y) {
            // Asset moving is unsupported
        }
        // @Override
        onMoveStopped(x, y) {
            // Asset moving is unsupported
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastMeasurementDateString(this);
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_asset_id") + ": "
                + this.getModel().assetId;
            return content;
        }
        getLocalizedLastMeasurementDateString(asset) {
            if (asset.getModel().positionEstimate != null) {
                return this.getLocalizedTimeSinceString(asset.getModel().positionEstimate.measurementTimeSec * 1000);
            }
            else {
                return "?";
            }
        }
        // Getters and setters
        // @Ovveride
        getModel() {
            return super.getModel();
        }
        // @Override
        getWidth() {
            return this.spriteView.width;
        }
        isEditModeActive() {
            // Assets are currently uneditable.
            return false;
        }
    };
    // Constants
    Asset.NORMAL_COLOR = 0xe94b36;
    Asset.SELECTED_COLOR = 0x7188bf;
    Asset.INACTIVE_COLOR = 0xe98e36;
    Asset = Asset_1 = __decorate([
        RelutionMapObject_4.RelutionModelBinding(DeviceModel_2.AssetModel)
    ], Asset);
    exports.Asset = Asset;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGateway", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/map/utils/DeviceUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, Beacon_3, DeviceUtils_5, DeviceModel_3, RelutionMapObject_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MeshGateway_1;
    let MeshGateway = MeshGateway_1 = class MeshGateway extends Beacon_3.Beacon {
        // Initialization
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
        }
        // View
        // @Override
        setMinViewDeviceSize() {
            this.setMinDeviceSizeInPixels(20);
        }
        // @Override
        setMaxViewSize() {
            this.setMaxDeviceSizeInMeter(2.0);
        }
        // @Override
        getTextureName() {
            return "beacon_white";
        }
        // @Override
        getTargetDeviceSizeInPx() {
            return MeshGateway_1.MESHGW_SIZE_IN_PX;
        }
        showMeshGatewayInsteadOfCommunicationBeacon(showMeshgw) {
            if (this.communicationBeacon != null) {
                if (showMeshgw) {
                    this.getView().visible = true;
                    this.communicationBeacon.getView().visible = false;
                }
                else {
                    this.getView().visible = false;
                    this.communicationBeacon.getView().visible = true;
                }
            }
        }
        // Communication beacon
        syncWithCommunicationBeacon() {
            // Register as observer on communication beacon position change events.
            if (!this.communicationBeacon.getModel().isObserver(this)) {
                this.communicationBeacon.getModel().addObserver(this);
            }
            if (this.getModel().isObserver(this)) {
                this.getModel().addObserver(this);
            }
            // Synchronize position with communication beacon. MeshGateway holds the correct position.
            this.syncPositionWithCommunicationBeacon(this.getModel());
        }
        // @Override
        xChanged(deviceModel) {
            super.xChanged(deviceModel);
            this.syncPositionWithCommunicationBeacon(deviceModel);
        }
        // @Override
        yChanged(deviceModel) {
            super.yChanged(deviceModel);
            this.syncPositionWithCommunicationBeacon(deviceModel);
        }
        syncPositionWithCommunicationBeacon(deviceModel) {
            if (this.communicationBeacon != null && deviceModel === this.communicationBeacon.getModel()) {
                if (this.getModel().x !== this.communicationBeacon.getModel().x) {
                    this.getModel().x = this.communicationBeacon.getModel().x;
                }
                if (this.getModel().y !== this.communicationBeacon.getModel().y) {
                    this.getModel().y = this.communicationBeacon.getModel().y;
                }
            }
            if (deviceModel == this.getModel()) {
                if (this.communicationBeacon != null) {
                    if (this.getModel().x !== this.communicationBeacon.getModel().x) {
                        this.communicationBeacon.getModel().x = this.getModel().x;
                    }
                    if (this.getModel().y !== this.communicationBeacon.getModel().y) {
                        this.communicationBeacon.getModel().y = this.getModel().y;
                    }
                }
            }
        }
        // Popup info
        // @Override
        getDeviceSpecificPopupInfo() {
            let meshGateway = this;
            let communicationBeacon = meshGateway.getCommunicationBeacon();
            let content = "\n";
            content += this.getLocalizedStringFor("popup_device_last_connected") + ": "
                + this.getLocalizedLastConnectionDateString(meshGateway);
            content += "\n";
            content += this.getLocalizedStringFor("popup_device_meshgw_version") + ": "
                + meshGateway.getModel().os;
            if (communicationBeacon != null) {
                content += communicationBeacon.getDeviceSpecificPopupInfo();
            }
            return content;
        }
        // Getters and setters
        // @Override
        getModel() {
            return super.getModel();
        }
        setCommunicationBeacon(communicationBeacon) {
            this.communicationBeacon = communicationBeacon;
            this.syncWithCommunicationBeacon();
        }
        getCommunicationBeacon() {
            return this.communicationBeacon;
        }
        isCommunicationBeacon() {
            return this.communicationBeacon;
        }
    };
    // View
    MeshGateway.MESHGW_SIZE_IN_PX = DeviceUtils_5.DeviceUtils.getPhysicalPixelsFromLogical(30);
    MeshGateway = MeshGateway_1 = __decorate([
        RelutionMapObject_5.RelutionModelBinding(DeviceModel_3.MeshGatewayModel)
    ], MeshGateway);
    exports.MeshGateway = MeshGateway;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGateway", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, Beacon_4, Asset_2, MeshGateway_2, RelutionMapObjectLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DeviceLayer_1;
    let DeviceLayer = DeviceLayer_1 = class DeviceLayer extends RelutionMapObjectLayer_1.RelutionMapObjectLayer {
        // Initialization
        constructor(environment, floorplanLayer, config = new DeviceLayer_1.Config()) {
            super(config, environment, floorplanLayer);
            this.deviceLayerConfig = config;
            this.addObserver(this);
        }
        // Observation
        // @Override
        onAfterObjectsLoaded(objects) {
            this.connectCommunicationBeaconsAndMeshGateway();
        }
        // @Override
        onAfterObjectsUpdated(objects) {
            this.connectCommunicationBeaconsAndMeshGateway();
        }
        // @Override
        onObjectAddedToMap(object) {
            this.addObjectToMap(object);
        }
        // @Override
        onObjectRemovedFromMap(object) {
            this.removeObjectFromMap(object);
        }
        addObjectToMap(view) {
            view.reset();
            if (view instanceof Beacon_4.Beacon) {
                view.addToMap();
            }
            view.setEditModeActive(this.isEditModeActive());
        }
        removeObjectFromMap(view) {
            if (view instanceof Beacon_4.Beacon) {
                view.removeFromMap();
            }
            view.reset();
        }
        // Accessing
        getDeviceWithUuid(uuid) {
            let allDevices = this.objectModelBinder.getObjects();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().uuid === uuid) {
                    return device;
                }
            }
            return null;
        }
        getDeviceWithDeviceId(deviceId) {
            let allDevices = this.objectModelBinder.getObjects();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().deviceId === deviceId) {
                    return device;
                }
            }
            return null;
        }
        getBeaconWithNodeId(nodeId) {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.getModel().nodeId === nodeId) {
                    return beacon;
                }
            }
            return null;
        }
        getBeaconWithSerial(serialNumber) {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.getModel().deviceId === serialNumber) {
                    return beacon;
                }
            }
            return null;
        }
        filterBeacons(devices) {
            let beacons = new Array();
            for (let i = 0; i < devices.length; i++) {
                let device = devices[i];
                if (device instanceof Beacon_4.Beacon) {
                    beacons.push(device);
                }
            }
            return beacons;
        }
        // MeshGateway appearance
        connectCommunicationBeaconsAndMeshGateway() {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon instanceof MeshGateway_2.MeshGateway) {
                    let communicationBeacon = this.getCommunicationBeaconForMeshGateway(beacon);
                    if (communicationBeacon != null) {
                        let meshGateway = beacon;
                        meshGateway.setCommunicationBeacon(communicationBeacon);
                    }
                }
            }
            this.updateMeshGatewayAppearance();
        }
        getCommunicationBeaconForMeshGateway(meshGateway) {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (meshGateway.getModel().communicationBeaconUuid === beacon.getModel().uuid) {
                    return beacon;
                }
            }
            return null;
        }
        updateMeshGatewayAppearance() {
            let beacons = this.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon instanceof MeshGateway_2.MeshGateway) {
                    let meshgateway = beacon;
                    meshgateway.showMeshGatewayInsteadOfCommunicationBeacon(this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled);
                }
            }
        }
        // Getters and setters
        getBeaconsOnMap() {
            let beaconsOnMap = [];
            for (let i = 0; i < this.objectModelBinder.getObjectsOnMap().length; i++) {
                let view = this.objectModelBinder.getObjectsOnMap()[i];
                if (view instanceof Beacon_4.Beacon) {
                    beaconsOnMap.push(view);
                }
            }
            return beaconsOnMap;
        }
        getBeaconsInStock() {
            let beaconsInStock = [];
            for (let i = 0; i < this.objectModelBinder.getObjectsInStock().length; i++) {
                let view = this.objectModelBinder.getObjectsInStock()[i];
                if (view instanceof Beacon_4.Beacon) {
                    beaconsInStock.push(view);
                }
            }
            return beaconsInStock;
        }
        getVisibleBeaconsOnMap() {
            let visibleBeaconsOnMap = new Array();
            for (let i = 0; i < this.objectModelBinder.getObjectsOnMap().length; i++) {
                let device = this.objectModelBinder.getObjectsOnMap()[i];
                if (device.getModel().visible) {
                    if (device instanceof Beacon_4.Beacon) {
                        visibleBeaconsOnMap.push(device);
                    }
                }
            }
            return visibleBeaconsOnMap;
        }
        getAllBeacons() {
            let allBeacons = new Array();
            let beaconsOnMap = this.getBeaconsOnMap();
            let beaconsInStock = this.getBeaconsInStock();
            for (let i = 0; i < beaconsOnMap.length; i++) {
                let beacon = beaconsOnMap[i];
                allBeacons.push(beacon);
            }
            for (let i = 0; i < beaconsInStock.length; i++) {
                let beacon = beaconsInStock[i];
                allBeacons.push(beacon);
            }
            return allBeacons;
        }
        getAllVisibleBeacons() {
            let visibleBeaconsOnMap = new Array();
            let allBeacons = this.getAllBeacons();
            for (let i = 0; i < allBeacons.length; i++) {
                let beacon = allBeacons[i];
                if (beacon.getModel().visible) {
                    visibleBeaconsOnMap.push(beacon);
                }
            }
            return visibleBeaconsOnMap;
        }
        getAssets() {
            let assets = [];
            let views = this.objectModelBinder.getObjects();
            for (let i = 0; i < views.length; i++) {
                let view = views[i];
                if (view instanceof Asset_2.Asset) {
                    assets.push(view);
                }
            }
            return assets;
        }
        getVisibleAssets() {
            let visibleAssets = new Array();
            let assets = this.getAssets();
            for (let i = 0; i < assets.length; i++) {
                let asset = assets[i];
                if (asset.getModel().visible) {
                    visibleAssets.push(asset);
                }
            }
            return visibleAssets;
        }
        getAllDevices() {
            let allDevices = new Array();
            let allBeacons = this.getAllBeacons();
            let allAssets = this.getAssets();
            for (let i = 0; i < allBeacons.length; i++) {
                let beacon = allBeacons[i];
                allDevices.push(beacon);
            }
            for (let i = 0; i < allAssets.length; i++) {
                let asset = allAssets[i];
                allDevices.push(asset);
            }
            return allDevices;
        }
        getAllVisibleDevices() {
            let visibleDevices = new Array();
            let allDevices = this.getAllDevices();
            for (let i = 0; i < allDevices.length; i++) {
                let device = allDevices[i];
                if (device.getModel().visible) {
                    visibleDevices.push(device);
                }
            }
            return visibleDevices;
        }
        // Getters and setters
        setShowMeshGatewayInsteadOfCommunicationBeaconEnabled(enabled) {
            this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled = enabled;
            this.updateMeshGatewayAppearance();
        }
        isShowingMeshGatewayInsteadOfCommunicationBeaconEnabled() {
            return this.deviceLayerConfig.showMeshGatewayInsteadOfCommunicationBeaconEnabled;
        }
    };
    DeviceLayer = DeviceLayer_1 = __decorate([
        RelutionMapObjectLayer_1.RelutionMapObjectBinding(Asset_2.Asset, Beacon_4.Beacon, MeshGateway_2.MeshGateway)
    ], DeviceLayer);
    exports.DeviceLayer = DeviceLayer;
    (function (DeviceLayer) {
        class Config extends RelutionMapObjectLayer_1.RelutionMapObjectLayer.Config {
            constructor() {
                super(...arguments);
                /**
                 * If true, the gateway view will replace the communication.
                 *
                 * Default: true
                 */
                this.showMeshGatewayInsteadOfCommunicationBeaconEnabled = true;
            }
        }
        DeviceLayer.Config = Config;
    })(DeviceLayer = exports.DeviceLayer || (exports.DeviceLayer = {}));
    exports.DeviceLayer = DeviceLayer;
});
define("src/app/relution/utils/RssiToDistance", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RssiToDistance {
        static rssiToDistance(rssi) {
            return RssiToDistance.rssiToDistanceWithA(rssi, -55);
        }
        static rssiToDistanceWithA(rssi, A) {
            let N = 2.5;
            let distanceInMetre = Math.pow(10, (A - rssi) / (10 * N));
            return distanceInMetre;
        }
    }
    RssiToDistance.MIN_RSSI = -90;
    exports.RssiToDistance = RssiToDistance;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", ["require", "exports", "src/app/relution/utils/RssiToDistance", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture"], function (require, exports, RssiToDistance_1, RelutionMapAttributeObject_2, SpriteObject_6, Texture_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconRange extends RelutionMapAttributeObject_2.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, floorModel, beacon) {
            super(environment, beacon);
            this.initModel(floorModel, beacon);
            this.initView();
        }
        initModel(floorModel, beacon) {
            this.floorModel = floorModel;
            this.beacon = beacon;
            this.radiusInPixels = this.computeRadius();
        }
        computeRadius() {
            let minStableConnectionRssi = -75;
            let calibratedRssi = this.getBeacon().getModel().calibratedRssi;
            let distanceInMeter = RssiToDistance_1.RssiToDistance.rssiToDistanceWithA(minStableConnectionRssi, calibratedRssi);
            let radiusInPixel = this.floorModel.pixelPerMeter * distanceInMeter;
            return radiusInPixel;
        }
        initView() {
            this.redrawCircle();
            this.updatePivot();
            this.updateScale();
            this.updatePosition();
            this.updateAppeareance();
        }
        redrawCircle() {
            this.rangeView = new SpriteObject_6.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.rangeView);
            let texture = PIXI.loader.resources["range"].texture;
            texture.baseTexture.mipmap = true;
            this.rangeView.texture = new Texture_6.Texture(texture, this.getEnvironment().renderingEnvironment);
        }
        updatePivot() {
            this.rangeView.pivot.x = this.rangeView.width / 2;
            this.rangeView.pivot.y = this.rangeView.height / 2;
        }
        updateScale() {
            this.rangeView.scale.x = this.radiusInPixels / (this.rangeView.texture.baseTexture.width / 2);
            this.rangeView.scale.y = this.radiusInPixels / (this.rangeView.texture.baseTexture.height / 2);
        }
        updateAppeareance() {
            this.rangeView.alpha = 1;
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            this.rangeView.destroy();
        }
        // Model Event-Handling
        // @Override
        xChanged(deviceModel) {
            this.updatePosition();
        }
        // @Override
        yChanged(deviceModel) {
            this.updatePosition();
        }
        // @Override
        lastConnectionDateChanged(deviceMode) {
            this.updateAppeareance();
        }
        updatePosition() {
            this.rangeView.x = this.beacon.getView().x;
            this.rangeView.y = this.beacon.getView().y;
        }
        // Getters and setters
        getBeacon() {
            return this.beacon;
        }
    }
    exports.BeaconRange = BeaconRange;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, Beacon_5, BeaconRange_1, RelutionMapAttributeObjectLayer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconRangeLayer extends RelutionMapAttributeObjectLayer_2.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let ranges = [];
            if (device instanceof Beacon_5.Beacon) {
                let beacon = device;
                let range = new BeaconRange_1.BeaconRange(this.getEnvironment(), this.getFloorplanLayer().getModel(), beacon);
                ranges.push(range);
            }
            return ranges;
        }
    }
    exports.BeaconRangeLayer = BeaconRangeLayer;
});
define("src/app/relution/model/indoor/PositionEstimateModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, Model_4, RelutionMapModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PositionEstimateModel extends RelutionMapModel_3.RelutionMapModel {
        constructor() {
            super(...arguments);
            // Derived attributes
            this.positions = null;
        }
        // Getters and setters
        set siteUuid(siteUuid) {
            this._siteUuid = siteUuid;
            this.notifyObservers("siteUuid");
        }
        get siteUuid() {
            return this._siteUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set floorId(floorId) {
            this._floorId = floorId;
            this.notifyObservers("floorId");
        }
        get floorId() {
            return this._floorId;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get x() {
            return this._x;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
        get y() {
            return this._y;
        }
        set accuracy(accuracy) {
            this._accuracy = accuracy;
            this.notifyObservers("accuracy");
        }
        get accuracy() {
            return this._accuracy;
        }
        set measurementTimes(measurementTimes) {
            this._measurementTimes = measurementTimes;
            this.notifyObservers("measurementTime");
        }
        get measurementTimes() {
            return this._measurementTimes;
        }
        set startTimeSec(startTimeSec) {
            this._startTimeSec = startTimeSec;
            this.notifyObservers("startTimeSec");
        }
        get startTimeSec() {
            return this._startTimeSec;
        }
        set endTimeSec(endTimeSec) {
            this._endTimeSec = endTimeSec;
            this.notifyObservers("endTimeSec");
        }
        get endTimeSec() {
            return this._endTimeSec;
        }
        // Derived attributes
        getPositions() {
            if (this.positions == null) {
                this.computePositions();
            }
            return this.positions;
        }
        computePositions() {
            this.positions = [];
            let numPositions = this._x.length;
            for (let i = 0; i < numPositions; i++) {
                let x = this._x[i];
                let y = this._y[i];
                this.positions.push(new PIXI.Point(x, y));
            }
        }
    }
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_siteUuid", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_deviceUuid", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_floorId", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_x", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_y", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_accuracy", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_measurementTimes", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_startTimeSec", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "_endTimeSec", void 0);
    __decorate([
        Model_4.ModelProperty()
    ], PositionEstimateModel.prototype, "positions", void 0);
    exports.PositionEstimateModel = PositionEstimateModel;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange", ["require", "exports", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, RelutionMapAttributeObject_3, Animation_7, LinearInterpolator_6, GraphicsObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceAccuracyRange extends RelutionMapAttributeObject_3.RelutionMapAttributeObject {
        // Constructor
        constructor(environment, floorplanLayer, assetDevice) {
            super(environment, assetDevice);
            // View: Animation
            this.accuracyCircleResolution = 3;
            this.floorplanLayer = floorplanLayer;
            this.accuracyRangeScaleAnimation = new Animation_7.Animation(new LinearInterpolator_6.LinearInterpolator());
            this.initView();
        }
        initView() {
            this.accuracyRangeView = new GraphicsObject_3.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.accuracyRangeView);
            // Pivot
            this.accuracyRangeView.pivot.x = this.accuracyRangeView.width / 2;
            this.accuracyRangeView.pivot.y = this.accuracyRangeView.height / 2;
            // Paint
            this.accuracyRangeView.beginFill(0x0000ff);
            this.accuracyRangeView.drawCircle(0, 0, this.accuracyCircleResolution);
            this.accuracyRangeView.endFill();
            // Scale
            this.accuracyRangeView.scale.x = 1 / this.accuracyCircleResolution;
            this.accuracyRangeView.scale.y = 1 / this.accuracyCircleResolution;
            // Position
            this.accuracyRangeView.x = 0;
            this.accuracyRangeView.y = 0;
            // Alpha
            this.accuracyRangeView.alpha = 0.15;
        }
        // View access
        setPosition(position) {
            this.accuracyRangeView.x = position.x;
            this.accuracyRangeView.y = position.y;
        }
        setAccuracy(accuracyInCm) {
            // Animate scaling, if animation is currently not running.
            if (!this.accuracyRangeScaleAnimation.isCurrentlyAnimating()) {
                let radiusInCm = accuracyInCm * 10;
                let radiusInPixel = this.floorplanLayer.getModel().pixelPerMeter * (radiusInCm / 100);
                let startValue = this.accuracyRangeView.scale.x;
                let endValue = radiusInPixel / this.accuracyCircleResolution;
                let durationInMs = 200;
                let delayInMs = 0;
                this.accuracyRangeScaleAnimation.start(startValue, endValue, durationInMs, delayInMs);
            }
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAccuracyRangeScaleAnimation(lastFrametime);
        }
        updateAccuracyRangeScaleAnimation(lastFrametime) {
            if (this.accuracyRangeScaleAnimation.isCurrentlyAnimating()) {
                let currentScale = this.accuracyRangeScaleAnimation.getValue(lastFrametime);
                this.accuracyRangeView.scale.x = currentScale;
                this.accuracyRangeView.scale.y = currentScale;
            }
        }
    }
    exports.DeviceAccuracyRange = DeviceAccuracyRange;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", ["require", "exports", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, DeviceUtils_6, Vector2_4, RelutionMapAttributeObject_4, GraphicsObject_4, DisplayObjectContainer_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceTrack extends RelutionMapAttributeObject_4.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, floorplanLayer, model, device, deviceAccuracyRange) {
            super(environment, device);
            this.pathPostProcessingEnabled = false;
            this.lastClusterReferencePosition = null;
            // View: State
            this.invalidated = true;
            this.lastScaleFactor = Number.MAX_VALUE;
            // View: Animation
            this.animationModeEnabled = false;
            this.progress = 1.0;
            this.initModel(floorplanLayer, model, device, deviceAccuracyRange);
            this.initView();
        }
        initModel(floorplanLayer, model, device, deviceAccuracyRange) {
            this.floorplanLayer = floorplanLayer;
            this.model = model;
            this.device = device;
            this.deviceAccuracyRange = deviceAccuracyRange;
        }
        initView() {
            this.container = new DisplayObjectContainer_11.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.container);
            this.initPathView();
        }
        initPathView() {
            this.pathView = new GraphicsObject_4.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.container.addChild(this.pathView);
            this.redrawPathViewWithLineWidth(0);
        }
        // Painting
        redrawPathViewWithLineWidth(lineWidth) {
            this.redrawPathViewWithLineWidthAndProgress(lineWidth, 1.0);
        }
        redrawPathViewWithLineWidthAndProgress(lineWidth, progress) {
            // Position processing pipeline
            let positions = this.getPositionsFromModel();
            positions = this.getPositionsUntilProgress(positions, progress);
            positions = this.simplifyPositions(positions);
            positions = this.removeDuplicates(positions);
            if (positions.length === 0) {
                // If no position estimates exist, we do not display the device,
                // event if the position in the device is set, because position estimates
                // replace the position in the device model.
                this.moveDeviceToPosition(0, 0);
                this.pathView.clear();
                return;
            }
            positions = this.getPostprocessedPositions(positions);
            positions = this.getPositionsInWorldCoordinates(positions);
            let subpaths = this.splitPathToSubpaths(positions);
            // Drawing
            this.drawSubpaths(subpaths, lineWidth);
            let lastSubpath = subpaths[subpaths.length - 1];
            if (lastSubpath != null && lastSubpath.length > 0) {
                // Update asset position
                this.moveDeviceToLastSubpathPosition(subpaths);
                // Update asset alpha
                let allPositions = this.model.getPositions();
                let lastPosition = allPositions[allPositions.length - 1];
                if (this.device.getModel().positionIsOutdoor(lastPosition)) {
                    this.device.setInactive(true);
                }
                else {
                    this.device.setInactive(false);
                }
                // Update asset range position and scale
                this.updateAccuracyRange(this.model.accuracy[allPositions.length - 1]);
                // Update position estimate model
                this.updateMeasurementTimeInModel(this.model.measurementTimes[allPositions.length - 1]);
            }
            else {
                // Update asset position to position "unknown""
                this.moveDeviceToPosition(0, 0);
            }
        }
        getPositionsFromModel() {
            return this.model.getPositions().slice();
        }
        simplifyPositions(positions) {
            // Simplify path: Draw in the level of detail depending on the current zoom level.
            let toleranceInPx = 10;
            let floorWidthInScreenPx = this.floorplanLayer.getCurrentFloorSizeInScreenPx().x;
            let relativeTolerance = toleranceInPx / floorWidthInScreenPx;
            // positions = Simplify.simplify(positions, relativeTolerance);
            return positions;
        }
        getPostprocessedPositions(positions) {
            if (this.pathPostProcessingEnabled) {
                positions = this.smoothPositions(positions);
                positions = this.clusterPositions(positions);
            }
            return positions;
        }
        splitPathToSubpaths(positions) {
            let subpaths = new Array();
            // Add first position to subpath
            let firstSubpath = new Array();
            subpaths.push(firstSubpath);
            if (positions.length > 0) {
                if (!this.device.getModel().positionIsOutdoor(positions[0])) {
                    firstSubpath.push(positions[0]);
                }
            }
            // Add all other positions to the corresponding subpath
            for (let i = 1; i < positions.length; i++) {
                // Create new subpath whenever the end of a unknown position sequence is reached.
                if (this.device.getModel().positionIsOutdoor(positions[i - 1])
                    && !this.device.getModel().positionIsOutdoor(positions[i])) {
                    let subpath = new Array();
                    subpaths.push(subpath);
                }
                // Do not add unknown positions to a subpath
                if (!this.device.getModel().positionIsOutdoor(positions[i])) {
                    subpaths[subpaths.length - 1].push(positions[i]);
                }
            }
            // Remove empty subpaths
            for (let i = 0; i < subpaths.length; i++) {
                let subpath = subpaths[i];
                if (subpath.length === 0) {
                    subpaths.splice(i, 1);
                    i--;
                }
            }
            return subpaths;
        }
        drawSubpaths(subpaths, lineWidth) {
            this.pathView.clear();
            for (let i = 0; i < subpaths.length; i++) {
                let subpath = subpaths[i];
                this.drawSubpath(subpath, lineWidth);
            }
        }
        drawSubpath(positions, lineWidth) {
            // Line width
            let adjustedLineWidth = DeviceUtils_6.DeviceUtils.getPhysicalPixelsFromLogical(lineWidth);
            // Color
            let targetColor = 0xe94b36;
            // Drawing
            if (positions.length !== 0) {
                this.pathView.moveTo(positions[0].x, positions[0].y);
            }
            let numPoints = positions.length;
            for (let i = 2; i < numPoints; i++) {
                let currentLineWidth = (adjustedLineWidth * i) / numPoints;
                if (currentLineWidth > 0.001) {
                    let currentAlpha = i / numPoints;
                    let currentRed = ((targetColor & 0xff0000) >> 16);
                    let currentGreen = ((targetColor & 0x00ff00) >> 8);
                    let currentBlue = ((targetColor & 0x0000ff) >> 0);
                    let red = currentRed - currentRed * ((numPoints - i) / numPoints);
                    let green = currentGreen - currentGreen * ((numPoints - i) / numPoints);
                    let blue = currentBlue - currentBlue * ((numPoints - i) / numPoints);
                    let currentColor = (red << 16) + (green << 8) + (blue << 0);
                    this.pathView.lineStyle(currentLineWidth, currentColor, currentAlpha);
                    // We always draw 2 lines to get the smooth corners
                    // created by the drawPolygon method.
                    let points = [
                        positions[i - 2],
                        positions[i - 1],
                        positions[i]
                    ];
                    this.pathView.drawPolygon(points);
                }
            }
            // this.pathView.lineStyle(adjustedLineWidth, targetColor, 1);
            // this.pathView.drawPolygon(positionsInWorldCoordinates);
        }
        getPositionsUntilProgress(positions, progress) {
            // Constrain progress limits
            progress = Math.max(0, Math.min(progress, 1));
            // Get final position index determined by progress
            let finalTimeInMs = this.model.startTimeSec + (this.model.endTimeSec - this.model.startTimeSec) * progress;
            let measurementTimes = this.model.measurementTimes;
            let i = 0;
            for (; i < measurementTimes.length; i++) {
                let measurementTime = measurementTimes[i];
                if (measurementTime >= finalTimeInMs) {
                    break;
                }
            }
            let stopIndex = Math.min(Math.max(i - 1, 0), positions.length - 1);
            // Add artificial final position to get interpolated animation
            let lastPosition = positions[stopIndex];
            let nextPosition = positions[Math.min(stopIndex + 1, positions.length - 1)];
            // Compute interpolated end position only if start and end position of
            // the interpolation is not an unknown position.
            if (!(this.device.getModel().positionIsOutdoor(lastPosition)
                || this.device.getModel().positionIsOutdoor(nextPosition))) {
                let diffX = nextPosition.x - lastPosition.x;
                let diffY = nextPosition.y - lastPosition.y;
                let lastTime = this.model.measurementTimes[stopIndex];
                let nextTime = this.model.measurementTimes[Math.min(stopIndex + 1, positions.length - 1)];
                let interpolatedX = 0;
                let interpolatedY = 0;
                if (lastTime !== nextTime) {
                    let interpolationProgress = (finalTimeInMs - lastTime) / (nextTime - lastTime);
                    interpolatedX = lastPosition.x + diffX * interpolationProgress;
                    interpolatedY = lastPosition.y + diffY * interpolationProgress;
                }
                else {
                    interpolatedX = lastPosition.x;
                    interpolatedY = lastPosition.y;
                }
                // Copy positions
                positions.splice(stopIndex, positions.length - stopIndex);
                // Add interpolated value
                positions.push(new PIXI.Point(interpolatedX, interpolatedY));
            }
            else {
                // Copy positions
                positions.splice(stopIndex + 1, positions.length - stopIndex);
            }
            return positions;
        }
        getPositionsInWorldCoordinates(positions) {
            let worldPositions = new Array();
            let floorSizeX = this.floorplanLayer.getFloorSize().x;
            let floorSizeY = this.floorplanLayer.getFloorSize().y;
            for (let i = 0; i < positions.length; i++) {
                let x = (positions[i].x * floorSizeX);
                let y = (positions[i].y * floorSizeY);
                worldPositions[i] = new PIXI.Point(x, y);
            }
            return worldPositions;
        }
        smoothPositions(positions) {
            let smoothedPositions = this.convolve(positions);
            return smoothedPositions;
        }
        convolve(f) {
            // Output
            let b = new Array();
            // Define kernel
            // let w = this.getAverageKernel(3);
            let w = this.getGaussianKernel(3.5);
            // let w = this.getGaussianKernel(9.5);
            let r = Math.floor(w.length / 2);
            // Extend left end
            let beginIndex = 0;
            for (let i = 0; i < r; i++) {
                f.splice(beginIndex, 0, f[0]);
            }
            // Extend right end
            let endIndex = f.length - 1;
            for (let i = 0; i < r; i++) {
                f.splice(endIndex, 0, f[endIndex]);
            }
            // Convole function
            for (let i = r; i < f.length - r; i++) {
                b[i - r] = new PIXI.Point(0, 0);
                for (let j = i - r; j < i + r; j++) {
                    b[i - r].x += f[j].x * w[j - (i - r)];
                    b[i - r].y += f[j].y * w[j - (i - r)];
                }
            }
            // Return result
            return b;
        }
        getAverageKernel(r) {
            let w = [];
            for (let i = 0; i < r * 2; i++) {
                w[i] = 1 / (r * 2);
            }
            return w;
        }
        getGaussianKernel(sigma) {
            // Input
            let truncate = 4.0;
            let sd = sigma;
            // Make the radius of the filter equal to truncate standard deviations
            let lw = Math.floor(truncate * sd + 0.5);
            let weights = [];
            weights[lw] = 1.0;
            let sum = 1.0;
            sd = sd * sd;
            // Calculate the kernel:
            for (let i = 1; i < lw + 1; i++) {
                let tmp = Math.exp(-0.5 * (i * i) / sd);
                weights[lw + i] = tmp;
                weights[lw - i] = tmp;
                sum += 2.0 * tmp;
            }
            for (let i = 2; i < 2 * lw + 1; i++) {
                weights[i] /= sum;
            }
            return weights;
        }
        roundPositions(positions) {
            let cellWidthInMeter = 1.0;
            let cellWidthInTexel = this.floorplanLayer.getModel().pixelPerMeter * cellWidthInMeter;
            let relativeCellWidth = cellWidthInTexel / this.floorplanLayer.getFloorSize().x;
            let relativeCellHeight = cellWidthInTexel / this.floorplanLayer.getFloorSize().y;
            for (let i = 0; i < positions.length; i++) {
                let position = positions[i];
                position.x = Math.floor(position.x / relativeCellWidth) * relativeCellWidth;
                position.y = Math.floor(position.y / relativeCellHeight) * relativeCellHeight;
            }
            return positions;
        }
        clusterPositions(positions) {
            let clusterThresholdInMeter = 1.5;
            let clusterThresholdInTexels = this.floorplanLayer.getModel().pixelPerMeter * clusterThresholdInMeter;
            let relativeClusterThreshold = clusterThresholdInTexels / this.floorplanLayer.getFloorSize().x;
            // this.lastClusterReferencePosition = null;
            for (let i = 0; i < positions.length; i++) {
                if (this.lastClusterReferencePosition) {
                    let distanceToClusterReferencePosition = Vector2_4.Vector2.getLengthOfPoint(Vector2_4.Vector2.subtractPoints(positions[i], this.lastClusterReferencePosition));
                    let newClusterShouldBeCreated = distanceToClusterReferencePosition > relativeClusterThreshold;
                    if (newClusterShouldBeCreated) {
                        this.lastClusterReferencePosition = positions[i];
                    }
                    else {
                        positions[i].x = this.lastClusterReferencePosition.x;
                        positions[i].y = this.lastClusterReferencePosition.y;
                    }
                }
                else {
                    this.lastClusterReferencePosition = positions[i];
                }
            }
            return positions;
        }
        removeDuplicates(positions) {
            let newPositions = new Array();
            if (positions != null && positions.length > 0) {
                newPositions.push(positions[0]);
            }
            for (let i = 1; i < positions.length; i++) {
                if (!((positions[i].x === positions[i - 1].x) && (positions[i].y === positions[i - 1].y))) {
                    newPositions.push(positions[i]);
                }
            }
            return newPositions;
        }
        updateAccuracyRange(accuracyInCm) {
            if (this.deviceAccuracyRange !== null) {
                this.deviceAccuracyRange.setAccuracy(accuracyInCm);
                this.deviceAccuracyRange.setPosition(this.device.getView().position.pixi());
            }
        }
        moveDeviceToLastSubpathPosition(subpaths) {
            // Move the device to the corresponding position.
            let lastSubpath = subpaths[subpaths.length - 1];
            let lastKnownX = lastSubpath[lastSubpath.length - 1].x;
            let lastKnownY = lastSubpath[lastSubpath.length - 1].y;
            let floorSizeX = this.floorplanLayer.getFloorSize().x;
            let floorSizeY = this.floorplanLayer.getFloorSize().y;
            let relativeX = lastKnownX / floorSizeX;
            let relativeY = lastKnownY / floorSizeY;
            this.moveDeviceToPosition(relativeX, relativeY);
        }
        moveDeviceToPosition(x, y) {
            this.device.getModel().x = x;
            this.device.getModel().y = y;
            this.device.getModel().positionEstimate.x = x;
            this.device.getModel().positionEstimate.y = y;
        }
        updateMeasurementTimeInModel(measurementTimeSec) {
            if (this.device.getModel().positionEstimate != null) {
                this.device.getModel().positionEstimate.measurementTimeSec = measurementTimeSec;
            }
        }
        // Animation
        onAnimationModeEnabled(animationModeEnabled) {
            this.animationModeEnabled = animationModeEnabled;
            if (!this.animationModeEnabled) {
                this.progress = 1.0;
                this.invalidated = true;
            }
        }
        onUpdateAnimationFrame(timeInSec) {
            this.progress = this.getProgressForTime(timeInSec);
            this.invalidated = true;
        }
        getProgressForTime(timeInSec) {
            let startTimeSec = this.model.startTimeSec;
            let endTimeSec = this.model.endTimeSec;
            // Constrain to borders
            timeInSec = Math.max(startTimeSec, Math.min(endTimeSec, timeInSec));
            // Get progress
            let progress = (timeInSec - startTimeSec) / (endTimeSec - startTimeSec);
            return progress;
        }
        // Updating
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScale();
            this.invalidated = false;
        }
        updateScale() {
            let scaleFactor = this.device.getView().scale.x;
            // We rebuild the polyline path only on significant
            // scale changes to save performance.
            let scaleChange = Math.max(this.lastScaleFactor, scaleFactor) / Math.min(this.lastScaleFactor, scaleFactor) - 1.0;
            let minScaleChangeToTriggerRedraw = 2.0;
            if (scaleChange > minScaleChangeToTriggerRedraw || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.rescalePathView(scaleFactor);
            }
        }
        rescalePathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.redrawPathViewWithLineWidthAndProgress(lineWidth, this.progress);
        }
        // Updating model
        updateModel(model) {
            this.model = model;
            this.invalidated = true;
        }
        // Getters and setters
        getDevice() {
            return this.device;
        }
        setPathPostprocessingEnabled(enabled) {
            this.pathPostProcessingEnabled = enabled;
            this.invalidated = true;
        }
        isPathPostprocessingEnabled() {
            return this.pathPostProcessingEnabled;
        }
        getModel() {
            return this.model;
        }
    }
    exports.DeviceTrack = DeviceTrack;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", ["require", "exports", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange"], function (require, exports, RelutionMapAttributeObjectLayer_3, Asset_3, DeviceAccuracyRange_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceAccuracyRangeLayer extends RelutionMapAttributeObjectLayer_3.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let ranges = [];
            if (device instanceof Asset_3.Asset) {
                let asset = device;
                let range = new DeviceAccuracyRange_1.DeviceAccuracyRange(this.getEnvironment(), this.getFloorplanLayer(), asset);
                ranges.push(range);
            }
            return ranges;
        }
    }
    exports.DeviceAccuracyRangeLayer = DeviceAccuracyRangeLayer;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer"], function (require, exports, DeviceTrack_1, FloorplanRelatedLayer_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceTrackLayer extends FloorplanRelatedLayer_5.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer, deviceAccuracyRangeLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Model
            this.positionEstimateModels = new Array();
            // View
            this.tracks = new Array();
            this.trackLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.deviceAccuracyRangeLayer = deviceAccuracyRangeLayer;
            this.deviceLayer.addObserver(this);
        }
        // Event-Handling: Beacon-Layer
        // @Override
        onObjectsLoaded(devices) {
            this.updatePositionEstimates(this.positionEstimateModels);
        }
        // @Override
        onObjectsUnloaded(devices) {
            this.updatePositionEstimates(this.positionEstimateModels);
        }
        // @Override
        onObjectMovedToMap(beacon) {
            this.updateDeviceVisibility(beacon);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.updateDeviceVisibility(beacon);
        }
        // Loading model
        updatePositionEstimates(positionEstimateModels) {
            this.positionEstimateModels = positionEstimateModels;
            let devices = this.deviceLayer.getAllDevices();
            if (devices != null) {
                let addingPositionEstimateModels = this.getAddingPositionEstimateModels(positionEstimateModels);
                let updatingPositionEstimateModels = this.getUpdatingPositionEstimateModels(positionEstimateModels);
                let removingTracks = this.getRemovingPositionEstimateModels(positionEstimateModels);
                this.addTracksForModels(addingPositionEstimateModels);
                this.updateTracksForModels(updatingPositionEstimateModels);
                this.removeTracks(removingTracks);
            }
        }
        getAddingPositionEstimateModels(positionEstimateModels) {
            let addingModels = [];
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (!this.existsTrackForModel(positionEstimateModel)) {
                    // Do add if device does not exist (yet).
                    if (this.deviceLayer.getDeviceWithUuid(positionEstimateModel.deviceUuid) != null) {
                        addingModels.push(positionEstimateModel);
                    }
                }
            }
            return addingModels;
        }
        getUpdatingPositionEstimateModels(positionEstimateModels) {
            let updatingModels = [];
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (this.existsTrackForModel(positionEstimateModel)) {
                    // Do not update, if device does not exist anymore.
                    if (this.deviceLayer.getDeviceWithUuid(positionEstimateModel.deviceUuid) != null) {
                        updatingModels.push(positionEstimateModel);
                    }
                }
            }
            return updatingModels;
        }
        getRemovingPositionEstimateModels(positionEstimateModels) {
            let removingTracks = [];
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                let deviceUuid = track.getDevice().getModel().uuid;
                // Remove track, if position estimate model or device does not exist anymore.
                if ((!this.existsModelForTrack(track, positionEstimateModels))
                    || (this.deviceLayer.getDeviceWithUuid(deviceUuid) == null)) {
                    removingTracks.push(track);
                }
            }
            return removingTracks;
        }
        existsTrackForModel(positionEstimateModel) {
            let track = this.getTrackForModel(positionEstimateModel);
            return track != null;
        }
        getTrackForModel(positionEstimateModel) {
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                if (track.getModel().deviceUuid === positionEstimateModel.deviceUuid) {
                    return track;
                }
            }
            return null;
        }
        existsModelForTrack(deviceTrack, positionEstimateModels) {
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                if (deviceTrack.getModel().deviceUuid === positionEstimateModel.deviceUuid) {
                    return true;
                }
            }
            return false;
        }
        updateTracksForModels(updatingPositionEstimateModels) {
            for (let i = 0; i < updatingPositionEstimateModels.length; i++) {
                let model = updatingPositionEstimateModels[i];
                let track = this.getTrackForModel(model);
                track.updateModel(model);
            }
        }
        removeTracks(removingTracks) {
            for (let i = 0; i < removingTracks.length; i++) {
                let track = removingTracks[i];
                this.removeTrack(track);
            }
        }
        addTracksForModels(positionEstimateModels) {
            for (let i = 0; i < positionEstimateModels.length; i++) {
                let positionEstimateModel = positionEstimateModels[i];
                let deviceUuid = positionEstimateModel.deviceUuid;
                let device = this.deviceLayer.getDeviceWithUuid(deviceUuid);
                if (device != null) {
                    this.addTrackForModel(positionEstimateModel, device);
                }
            }
        }
        addTrackForModel(positionEstimateModel, device) {
            let deviceAccuracyRanges = this.deviceAccuracyRangeLayer.getAttributeObjectsForObject(device);
            let deviceAccuracyRange = null;
            if (deviceAccuracyRanges.length !== 0) {
                deviceAccuracyRange = deviceAccuracyRanges[0];
            }
            let track = new DeviceTrack_1.DeviceTrack(this.getEnvironment(), this.getFloorplanLayer(), positionEstimateModel, device, deviceAccuracyRange);
            track.setPathPostprocessingEnabled(this.trackLayerConfig.pathPostprocessingEnabled);
            this.addChild(track);
            this.tracks.push(track);
        }
        getTrackOfDevice(device) {
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                if (track.getDevice() === device) {
                    return track;
                }
            }
            return null;
        }
        updateDeviceVisibility(device) {
            let track = this.getTrackOfDevice(device);
            if (track != null) {
                track.getView().visible = device.isOnMap();
            }
        }
        deleteAllTracks() {
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                track.destroy();
                if (track.getParent() != null) {
                    track.getParent().removeChild(track);
                }
            }
            this.tracks = new Array();
        }
        removeAllTracks() {
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                this.removeTrack(track);
                i--;
            }
        }
        removeTrack(track) {
            let indexOfTrack = this.getIndexOfTrack(track);
            this.tracks.splice(indexOfTrack, 1);
            this.removeChild(track);
            track.destroy();
        }
        getIndexOfTrack(track) {
            for (let i = 0; i < this.tracks.length; i++) {
                let currentTrack = this.tracks[i];
                if (currentTrack === track) {
                    return i;
                }
            }
            return -1;
        }
        // Getters and setters
        setPathPostprocessingEnabled(enabled) {
            this.trackLayerConfig.pathPostprocessingEnabled = enabled;
            for (let i = 0; i < this.tracks.length; i++) {
                let track = this.tracks[i];
                track.setPathPostprocessingEnabled(enabled);
            }
        }
        isPathPostprocessingEnabled() {
            return this.trackLayerConfig.pathPostprocessingEnabled;
        }
    }
    exports.DeviceTrackLayer = DeviceTrackLayer;
    (function (DeviceTrackLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the paths shall be clustered and smoothed before rendering.
                 *
                 * Default: false
                 */
                this.pathPostprocessingEnabled = false;
            }
        }
        DeviceTrackLayer.Config = Config;
    })(DeviceTrackLayer = exports.DeviceTrackLayer || (exports.DeviceTrackLayer = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", ["require", "exports", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/texture/Texture"], function (require, exports, Vector2_5, DeviceUtils_7, RelutionMapAttributeObject_5, SpriteObject_7, TextObject_2, DisplayObjectContainer_12, Texture_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconConnection extends RelutionMapAttributeObject_5.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, sourceBeacon, targetBeacon, rssi) {
            super(environment, sourceBeacon, targetBeacon);
            // View: Updating
            this.lastScaleFactor = -1;
            this.lastScaleFactorForTranslation = -1;
            this.invalidated = true;
            this.initModel(sourceBeacon, targetBeacon, rssi);
            this.initView();
        }
        initModel(sourceBeacon, targetBeacon, rssi) {
            this.sourceBeacon = sourceBeacon;
            this.targetBeacon = targetBeacon;
            this.rssi = rssi;
        }
        initView() {
            this.container = new DisplayObjectContainer_12.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.container);
            this.initLineView();
            this.initRssiView();
            this.updateAppeareance();
        }
        initLineView() {
            this.lineView = new SpriteObject_7.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.container.addChild(this.lineView);
            this.loadTexture();
            this.setPivot();
            this.drawLineWithLineWidth(0);
        }
        loadTexture() {
            let texture = PIXI.loader.resources["arrow_body"].texture;
            texture.baseTexture.mipmap = true;
            this.lineView.texture = new Texture_7.Texture(texture, this.getEnvironment().renderingEnvironment);
        }
        setPivot() {
            this.lineView.pivot.x = this.lineView.width / 2;
            this.lineView.pivot.y = this.lineView.height / 2;
        }
        drawLineWithLineWidth(lineWidth) {
            // Precomputation
            let sourceVector = Vector2_5.Vector2.getVector2(this.targetBeacon.getView().pixi().position);
            let targetVector = Vector2_5.Vector2.getVector2(this.sourceBeacon.getView().pixi().position);
            let differenceVector = Vector2_5.Vector2.subtract(sourceVector, targetVector);
            // Scale
            let width = DeviceUtils_7.DeviceUtils.getPhysicalPixelsFromLogical(lineWidth);
            let distanceBetweenBeacons = differenceVector.getLength();
            this.lineView.scale.x = distanceBetweenBeacons / this.lineView.texture.width;
            this.lineView.scale.y = width / this.lineView.texture.height;
            // Rotation
            let baseVector = new Vector2_5.Vector2(1, 0);
            let rotation = -Vector2_5.Vector2.getAngleBetween(differenceVector, baseVector);
            // Sign
            let crossProduct = Vector2_5.Vector2.crossProduct(baseVector, differenceVector);
            if (crossProduct > 0) {
                this.lineView.rotation = -rotation;
            }
            else {
                this.lineView.rotation = rotation;
            }
            // Position
            let centerVector = Vector2_5.Vector2.add(sourceVector, targetVector).divide(2);
            this.lineView.x = centerVector.getX();
            this.lineView.y = centerVector.getY();
        }
        initRssiView() {
            let fontSize = DeviceUtils_7.DeviceUtils.getPhysicalPixelsFromLogical(13);
            this.rssiView = new TextObject_2.TextObject(new PIXI.Text("" + this.rssi, { fontFamily: "Arial", fontSize: fontSize, fill: BeaconConnection.TEXT_COLOR_NORMAL, align: "center" }), this.getEnvironment().renderingEnvironment);
            this.rssiView.texture.baseTexture.mipmap = false;
            this.rssiView.pivot.x = this.rssiView.width / 2;
            this.rssiView.pivot.y = this.rssiView.height / 2;
            this.rssiView.x = (this.sourceBeacon.getView().x + this.targetBeacon.getView().x) / 2;
            this.rssiView.y = (this.sourceBeacon.getView().y + this.targetBeacon.getView().y) / 2 - this.rssiView.height;
            this.container.addChild(this.rssiView);
        }
        // View
        updateAppeareance() {
            if (this.sourceBeacon.isDisconnected() || this.targetBeacon.isDisconnected()) {
                this.getView().alpha = 0.5;
                this.rssiView.style.fill = BeaconConnection.TEXT_COLOR_DISCONNECTED;
                this.lineView.tint = BeaconConnection.DISCONNECTED_COLOR;
            }
            else {
                this.getView().alpha = 1.0;
                this.rssiView.style.fill = BeaconConnection.TEXT_COLOR_NORMAL;
                this.lineView.tint = BeaconConnection.NORMAL_COLOR;
            }
        }
        updatePositioning() {
            this.invalidated = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateScale();
            this.updateRotation();
            this.updateTranslation();
            this.invalidated = false;
        }
        updateScale() {
            let sourceBeacon = this.getSourceBeacon();
            let scaleFactor = sourceBeacon.getView().scale.x;
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.rescaleLine(scaleFactor);
                this.rescaleRssiView(scaleFactor);
            }
        }
        rescaleLine(scaleFactor) {
            let referenceLineWidth = 1.5; // In pixels
            let lineWidth = referenceLineWidth * scaleFactor;
            // this.lineView.scale.y = (1.0/this.lineView.height) * lineWidth;
            this.drawLineWithLineWidth(lineWidth);
        }
        rescaleRssiView(scaleFactor) {
            this.rssiView.scale.x = scaleFactor;
            this.rssiView.scale.y = scaleFactor;
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            if (this.rssiView.rotation !== orientation || this.invalidated) {
                this.rssiView.rotation = orientation;
            }
        }
        updateTranslation() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                let sourceX = this.sourceBeacon.getView().x;
                let sourceY = this.sourceBeacon.getView().y;
                let targetX = this.targetBeacon.getView().x;
                let targetY = this.targetBeacon.getView().y;
                let centerX = sourceX + (targetX - sourceX) * 0.5;
                let centerY = sourceY + (targetY - sourceY) * 0.5;
                this.rssiView.x = centerX - (this.rssiView.width / 2);
                this.rssiView.y = centerY - (this.rssiView.height / 2);
            }
        }
        // Destruction
        // @Override
        destroy() {
            super.destroy();
            this.lineView.destroy();
            this.rssiView.destroy(false);
        }
        // Model Event-handling
        // @Override
        xChanged(deviceModel) {
            this.updatePositioning();
        }
        // @Override
        yChanged(deviceModel) {
            this.updatePositioning();
        }
        // @Override
        lastConnectionDateChanged(deviceMode) {
            this.updateAppeareance();
        }
        // Getters and setters
        getSourceBeacon() {
            return this.sourceBeacon;
        }
        getTargetBeacon() {
            return this.targetBeacon;
        }
        getRssi() {
            return this.rssi;
        }
        setRssi(rssi) {
            this.rssi = rssi;
        }
    }
    // Constants
    BeaconConnection.NORMAL_COLOR = 0x566904;
    BeaconConnection.DISCONNECTED_COLOR = 0x000000;
    // View: Colors
    BeaconConnection.LINE_COLOR = 0x566904;
    BeaconConnection.TEXT_COLOR_NORMAL = 0x374203;
    BeaconConnection.TEXT_COLOR_DISCONNECTED = 0x000000;
    exports.BeaconConnection = BeaconConnection;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, BeaconConnection_1, Beacon_6, RelutionMapAttributeObjectLayer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconConnectionsLayer extends RelutionMapAttributeObjectLayer_4.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
            this.deviceLayer = deviceLayer;
        }
        // Device attribute object creation
        // @Override
        createAttributeObjectsForObject(device) {
            let objects = new Array();
            if (device instanceof Beacon_6.Beacon) {
                let beacon = device;
                let beaconModel = beacon.getModel();
                let connections = beaconModel.connections;
                if (connections) {
                    for (let j = 0; j < connections.length; j++) {
                        let connection = connections[j];
                        let rssi = connection.rssi;
                        let targetNodeId = connection.target;
                        let neighbor = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
                        if (neighbor != null) {
                            if (this.connectionExists(neighbor, beacon)) {
                                let existingConnection = this.getConnection(neighbor, beacon);
                                let currentRssi = existingConnection.getRssi();
                                let meanRssi = (currentRssi + rssi) / 2;
                                existingConnection.setRssi(meanRssi);
                            }
                            else {
                                let newConnection = new BeaconConnection_1.BeaconConnection(this.getEnvironment(), beacon, neighbor, rssi);
                                objects.push(newConnection);
                            }
                        }
                    }
                }
            }
            return objects;
        }
        connectionExists(sourceBeacon, targetBeacon) {
            let connection = this.getConnection(sourceBeacon, targetBeacon);
            return connection != null;
        }
        getConnection(sourceBeacon, targetBeacon) {
            for (let i = 0; i < this.getAttributeObjects().length; i++) {
                let connection = this.getAttributeObjects()[i];
                if (connection.getSourceBeacon() === sourceBeacon
                    && connection.getTargetBeacon() === targetBeacon) {
                    return connection;
                }
            }
            return null;
        }
    }
    exports.BeaconConnectionsLayer = BeaconConnectionsLayer;
});
define("src/app/relution/model/usercount/HeatmapDeviceModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HeatmapDeviceModel extends Model_5.Model {
        // Getters and setters
        get deviceUuid() {
            return this._deviceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get totalPacketsCount() {
            return this._totalPacketsCount;
        }
        set totalPacketsCount(totalPacketCount) {
            this._totalPacketsCount = totalPacketCount;
            this.notifyObservers("totalPacketsCount");
        }
        get nodeId() {
            return this._nodeId;
        }
        set nodeId(nodeId) {
            this._nodeId = nodeId;
            this.notifyObservers("nodeId");
        }
        get totalPackets() {
            return this._totalPackets;
        }
        set totalPackets(totalPackets) {
            this._totalPackets = totalPackets;
            this.notifyObservers("totalPackets");
        }
        get totalRssi() {
            return this._totalRssi;
        }
        set totalRssi(totalRssi) {
            this._totalRssi = totalRssi;
            this.notifyObservers("totalRssi");
        }
        // Derived attributes
        getRandomSeed() {
            return this._deviceUuid.valueOf() + this._totalPacketsCount + this._totalPackets + this._totalRssi;
        }
    }
    __decorate([
        Model_5.ModelProperty()
    ], HeatmapDeviceModel.prototype, "_deviceUuid", void 0);
    __decorate([
        Model_5.ModelProperty()
    ], HeatmapDeviceModel.prototype, "_totalPacketsCount", void 0);
    __decorate([
        Model_5.ModelProperty()
    ], HeatmapDeviceModel.prototype, "_nodeId", void 0);
    __decorate([
        Model_5.ModelProperty()
    ], HeatmapDeviceModel.prototype, "_totalPackets", void 0);
    __decorate([
        Model_5.ModelProperty()
    ], HeatmapDeviceModel.prototype, "_totalRssi", void 0);
    exports.HeatmapDeviceModel = HeatmapDeviceModel;
});
define("src/app/relution/model/usercount/HeatmapModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/usercount/HeatmapDeviceModel", "src/app/relution/model/RelutionMapModel"], function (require, exports, Model_6, HeatmapDeviceModel_1, RelutionMapModel_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HeatmapModel extends RelutionMapModel_4.RelutionMapModel {
        // Getters and setters
        set startTimeSec(startTimeSec) {
            this._startTimeSec = startTimeSec;
            this.notifyObservers("startTimeSec");
        }
        get startTimeSec() {
            return this._startTimeSec;
        }
        set endTimeSec(endTimeSec) {
            this._endTimeSec = endTimeSec;
            this.notifyObservers("endTimeSec");
        }
        get endTimeSec() {
            return this._endTimeSec;
        }
        set data(data) {
            this._data = data;
            this.notifyObservers("data");
        }
        get data() {
            return this._data;
        }
        // Derived attributes
        // Merges all heatmap data of an array to one object
        static createMergedHeatmapModel(heatmapData) {
            // start time
            let newStartTimeSec = this.getMergedStartTimeSec(heatmapData);
            // end time
            let newEndTimeSec = this.getMergedEndTimeSec(heatmapData);
            // data
            let newData = this.getMergedData(heatmapData);
            // result
            let newMergedHeatmapData = new HeatmapModel();
            newMergedHeatmapData._startTimeSec = newStartTimeSec;
            newMergedHeatmapData._endTimeSec = newEndTimeSec;
            newMergedHeatmapData._data = newData;
            return newMergedHeatmapData;
        }
        static getMergedStartTimeSec(heatmapData) {
            let minStartTime = Number.MAX_VALUE;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                if (heatmapModel.startTimeSec < minStartTime) {
                    minStartTime = heatmapModel.startTimeSec;
                }
            }
            return minStartTime;
        }
        static getMergedEndTimeSec(heatmapData) {
            let maxEndTime = -Number.MAX_VALUE;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                if (heatmapModel.endTimeSec > maxEndTime) {
                    maxEndTime = heatmapModel.endTimeSec;
                }
            }
            return maxEndTime;
        }
        static getMergedData(heatmapData) {
            // Get device uuids
            let deviceUuids = this.getMergedDeviceUuids(heatmapData);
            let newData = new Array();
            for (let i = 0; i < deviceUuids.length; i++) {
                // Result values
                let deviceUuid = deviceUuids[i];
                let totalPacketsCount = 0;
                let nodeId = 449;
                let totalPackets = 0;
                let totalRssi = 0;
                // Summing up values
                let numOccurencies = 0;
                for (let j = 0; j < heatmapData.length; j++) {
                    let heatmapModel = heatmapData[j];
                    let currentData = heatmapModel._data;
                    for (let k = 0; k < currentData.length; k++) {
                        let currentDevice = currentData[k];
                        if (currentDevice.deviceUuid === deviceUuid) {
                            totalPacketsCount += currentDevice.totalPacketsCount;
                            totalPackets += currentDevice.totalPackets;
                            totalRssi += currentDevice.totalRssi;
                            numOccurencies++;
                        }
                    }
                }
                if (numOccurencies !== 0) {
                    // Averaging
                    totalPacketsCount /= numOccurencies;
                    totalPackets /= numOccurencies;
                    totalRssi /= numOccurencies;
                    // Create merged heatmap device model
                    let mergedHeatmapDeviceModel = new HeatmapDeviceModel_1.HeatmapDeviceModel();
                    mergedHeatmapDeviceModel.deviceUuid = deviceUuid;
                    mergedHeatmapDeviceModel.totalPacketsCount = totalPacketsCount;
                    mergedHeatmapDeviceModel.nodeId = nodeId;
                    mergedHeatmapDeviceModel.totalPackets = totalPackets;
                    mergedHeatmapDeviceModel.totalRssi = totalRssi;
                    // Add it to the list
                    newData.push(mergedHeatmapDeviceModel);
                }
            }
            return newData;
        }
        static getMergedDeviceUuids(heatmapData) {
            let deviceUuids = new Array();
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                let currentDeviceUuids = heatmapModel.getDeviceUuids();
                for (let j = 0; j < currentDeviceUuids.length; j++) {
                    let currentDeviceUuid = currentDeviceUuids[j];
                    // Remove duplicates
                    let index = deviceUuids.indexOf(currentDeviceUuid);
                    if (index < 0) {
                        deviceUuids.push(currentDeviceUuid);
                    }
                }
            }
            return deviceUuids;
        }
        getDeviceUuids() {
            let deviceUuids = new Array();
            for (let i = 0; i < this._data.length; i++) {
                let heatmapDeviceModel = this._data[i];
                deviceUuids.push(heatmapDeviceModel.deviceUuid);
            }
            return deviceUuids;
        }
    }
    __decorate([
        Model_6.ModelProperty()
    ], HeatmapModel.prototype, "_startTimeSec", void 0);
    __decorate([
        Model_6.ModelProperty()
    ], HeatmapModel.prototype, "_endTimeSec", void 0);
    __decorate([
        Model_6.ModelProperty({ clazz: HeatmapDeviceModel_1.HeatmapDeviceModel })
    ], HeatmapModel.prototype, "_data", void 0);
    exports.HeatmapModel = HeatmapModel;
});
define("src/app/relution/model/geofence/GeofenceModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapObjectModel"], function (require, exports, Model_7, RelutionMapObjectModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let GeofenceModel = class GeofenceModel extends RelutionMapObjectModel_3.RelutionMapObjectModel {
        // Getters and setters
        get name() {
            return this._name;
        }
        set name(name) {
            this._name = name;
            this.notifyObservers("name");
        }
        get description() {
            return this._description;
        }
        set description(description) {
            this._description = description;
            this.notifyObservers("description");
        }
        get site() {
            return this._site;
        }
        set site(site) {
            this._site = site;
            this.notifyObservers("site");
        }
        get shape() {
            return this._shape;
        }
        set shape(shape) {
            this._shape = shape;
            this.notifyObservers("shape");
        }
        set type(shape) {
            this._shape = shape;
            this.notifyObservers("shape");
        }
        get timeThreshold() {
            return this._timeThreshold;
        }
        set timeThreshold(timeThreshold) {
            this._timeThreshold = timeThreshold;
            this.notifyObservers("timeThreshold");
        }
        get accuracyThreshold() {
            return this._accuracyThreshold;
        }
        set accuracyThreshold(accuracyThreshold) {
            this._accuracyThreshold = accuracyThreshold;
            this.notifyObservers("accuracyThreshold");
        }
    };
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_name", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_description", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_site", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_shape", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_timeThreshold", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], GeofenceModel.prototype, "_accuracyThreshold", void 0);
    GeofenceModel = __decorate([
        Model_7.ModelTypeInfo("shape"),
        Model_7.ModelSubTypes(new Model_7.ModelType(() => RectangleGeofenceModel, "RECTANGLE"), new Model_7.ModelType(() => CircleGeofenceModel, "CIRCLE"), new Model_7.ModelType(() => PolygonGeofenceModel, "POLYGON"))
    ], GeofenceModel);
    exports.GeofenceModel = GeofenceModel;
    class RectangleGeofenceModel extends GeofenceModel {
        get min() {
            return this._min;
        }
        set min(min) {
            this._min = min;
            this.notifyObservers("min");
        }
        get max() {
            return this._max;
        }
        set max(max) {
            this._max = max;
            this.notifyObservers("max");
        }
    }
    __decorate([
        Model_7.ModelProperty()
    ], RectangleGeofenceModel.prototype, "_min", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], RectangleGeofenceModel.prototype, "_max", void 0);
    exports.RectangleGeofenceModel = RectangleGeofenceModel;
    // tslint:disable-next-line:max-classes-per-file
    class CircleGeofenceModel extends GeofenceModel {
        get center() {
            return this._center;
        }
        set center(center) {
            this._center = center;
            this.notifyObservers("center");
        }
        get radius() {
            return this._radius;
        }
        set radius(radius) {
            this._radius = radius;
        }
    }
    __decorate([
        Model_7.ModelProperty()
    ], CircleGeofenceModel.prototype, "_center", void 0);
    __decorate([
        Model_7.ModelProperty()
    ], CircleGeofenceModel.prototype, "_radius", void 0);
    exports.CircleGeofenceModel = CircleGeofenceModel;
    // tslint:disable-next-line:max-classes-per-file
    class PolygonGeofenceModel extends GeofenceModel {
        get points() {
            return this._points;
        }
        set points(points) {
            this._points = points;
        }
    }
    __decorate([
        Model_7.ModelProperty()
    ], PolygonGeofenceModel.prototype, "_points", void 0);
    exports.PolygonGeofenceModel = PolygonGeofenceModel;
});
define("src/app/relution/model/geofence/GeofenceStateModel", ["require", "exports", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, Model_8, RelutionMapModel_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GeofenceStateModel extends RelutionMapModel_5.RelutionMapModel {
        constructor() {
            super(...arguments);
            this._geofenceUuid = null;
            this._deviceId = "";
            this._state = "LEFT";
        }
        // Getters and setters
        set geofenceUuid(geofenceUuid) {
            this._geofenceUuid = geofenceUuid;
        }
        get geofenceUuid() {
            return this._geofenceUuid;
        }
        set deviceId(deviceId) {
            this._deviceId = deviceId;
        }
        get deviceId() {
            return this._deviceId;
        }
        set state(state) {
            this._state = state;
        }
        get state() {
            return this._state;
        }
    }
    __decorate([
        Model_8.ModelProperty()
    ], GeofenceStateModel.prototype, "_geofenceUuid", void 0);
    __decorate([
        Model_8.ModelProperty()
    ], GeofenceStateModel.prototype, "_deviceId", void 0);
    __decorate([
        Model_8.ModelProperty()
    ], GeofenceStateModel.prototype, "_state", void 0);
    exports.GeofenceStateModel = GeofenceStateModel;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/map/utils/DateUtils"], function (require, exports, RelutionMapObject_6, DateUtils_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Geofence extends RelutionMapObject_6.RelutionMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // State model
            this.stateModel = null;
            // State
            this.invalidated = true;
            this.lastScaleFactor = -1;
        }
        updateStateModel(model) {
            if (this.stateModel === null || (this.stateModel !== null && this.stateModel.state !== model.state)) {
                this.stateModel = model;
                this.redraw();
            }
        }
        getStateModel() {
            return this.stateModel;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.invalidated = false;
                this.redraw();
            }
        }
        // Name
        // Name
        // @Override
        getName() {
            return this.getModel().name;
        }
        // Popup info
        // @Override
        getPopupInfo() {
            let content;
            // General geofence information
            content = this.getLocalizedStringFor("popup_geofence_name") + ": "
                + this.getModel().name;
            // Thresholds
            content += "\n";
            content += this.getLocalizedStringFor("popup_geofence_time_threshold") + ": "
                + this.getFormattedTimeDifference(this.getModel().timeThreshold);
            content += "\n";
            content += this.getLocalizedStringFor("popup_geofence_accuracy_threshold") + ": "
                + (this.getModel().accuracyThreshold / 100).toFixed(1) + " m";
            return content;
        }
        getFormattedTimeDifference(timeDiffInMs) {
            let timeDiffArray = DateUtils_2.DateUtils.getFormattedTimeDifference(timeDiffInMs);
            let interval = timeDiffArray[0];
            let intervalType = timeDiffArray[1];
            let timeDiffString = ""
                + interval + " " + this.getLocalizedStringFor("popup_time_unit_" + intervalType);
            return timeDiffString;
        }
    }
    // Configuration: Alpha
    Geofence.DEFAULT_ALPHA = 0.5;
    // Configuration: Shape
    Geofence.ENTERED_SHAPE_COLOR = 0xff0000;
    Geofence.LEFT_SHAPE_COLOR = 0x66ccff;
    Geofence.UNKNOWN_SHAPE_COLOR = 0xffff00;
    // Configuration: Border
    Geofence.DEFAULT_BORDER_COLOR = 0x000000;
    Geofence.SELECTED_BORDER_COLOR = 0x00ff00;
    Geofence.MOUSE_OVER_BORDER_COLOR = 0xbb00bb;
    // Configuration: Edit points
    Geofence.EDIT_POINT_RADIUS_IN_PX = 4;
    Geofence.EDITABLE_POINT_TOLERANCE_IN_PX = 6;
    // Configuration: Length text
    Geofence.TEXT_PADDING_PX = 5;
    exports.Geofence = Geofence;
});
define("src/engine/rendering/pixi/HighResText", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HighResText extends PIXI.Text {
        constructor(scaleFactor, text, style) {
            super(text, style);
            this.scaleFactor = PIXI.settings.RESOLUTION * 2;
            this.scaleFactor = scaleFactor;
            // Set bigger font size
            this._style.fontSize = (this._style.fontSize) * this.scaleFactor;
            // Downscale text
            this.setScaleX(1);
            this.setScaleY(1);
        }
        setScaleX(x) {
            this.scale.x = x / this.scaleFactor;
        }
        setScaleY(y) {
            this.scale.y = y / this.scaleFactor;
        }
        getScaleX() {
            return this.scale.x * this.scaleFactor;
        }
        getScaleY() {
            return this.scale.y * this.scaleFactor;
        }
        setScaleFactor(scaleFactor) {
            this.scaleFactor = scaleFactor;
        }
        getScaleFactor() {
            return this.scaleFactor;
        }
    }
    exports.HighResText = HighResText;
});
define("src/engine/rendering/objects/HighResTextObject", ["require", "exports", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/DisplayObject"], function (require, exports, TextObject_3, DisplayObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HighResTextObject extends TextObject_3.TextObject {
        // Construction
        constructor(baseObject, environment) {
            super(baseObject, environment);
        }
        // Decorating getters and setters
        setScaleX(x) {
            let oldScaleX = this.pixi().getScaleX();
            this.pixi().setScaleX(x);
            if (Math.abs(oldScaleX - x) > DisplayObject_3.DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        setScaleY(y) {
            let oldScaleY = this.pixi().getScaleY();
            this.pixi().setScaleY(y);
            if (Math.abs(oldScaleY - y) > DisplayObject_3.DisplayObject.EPSILON) {
                this.environment.dirty = true;
            }
        }
        // Getters and setters
        pixi() {
            return super.pixi();
        }
    }
    exports.HighResTextObject = HighResTextObject;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofence", ["require", "exports", "src/engine/math/Vector2", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel", "src/map/utils/DeviceUtils", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/pixi/HighResText", "src/engine/rendering/utils/Point"], function (require, exports, Vector2_6, Geofence_1, RelutionMapObject_7, GeofenceModel_1, DeviceUtils_8, HighResTextObject_1, GraphicsObject_5, HighResText_1, Point_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let RectangleGeofence = class RectangleGeofence extends Geofence_1.Geofence {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            // Editing:
            this.numberOfEditingPoints = 4;
            this.editing = true;
            this.editingMinX = false;
            this.editingMinY = false;
            this.editingMaxX = false;
            this.editingMaxY = false;
            this.editingPoints = Array();
            this.lengthTexts = new Array();
            // Movement: Given in rectangle local coordinates
            this.movingPointInLocalCoords = null;
            this.rectangleModel = model;
            this.initRectangle();
            this.initEditingPoints();
            this.initLengthTexts();
        }
        initRectangle() {
            this.rectangle = new GraphicsObject_5.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.rectangle);
            this.rectangle.alpha = Geofence_1.Geofence.DEFAULT_ALPHA;
        }
        initEditingPoints() {
            for (let i = 0; i < this.numberOfEditingPoints; i++) {
                let editingPoint = new GraphicsObject_5.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
                editingPoint.clear();
                editingPoint.beginFill(Geofence_1.Geofence.MOUSE_OVER_BORDER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            }
        }
        initLengthTexts() {
            let fontSize = DeviceUtils_8.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let style = {
                fill: Geofence_1.Geofence.MOUSE_OVER_BORDER_COLOR,
                fontFamily: "Arial",
                fontSize: fontSize,
            };
            // We want the texts only be shown on the top and right site.
            let numberOfLengthTexts = this.numberOfEditingPoints / 2;
            for (let i = 0; i < numberOfLengthTexts; i++) {
                let lengthText = new HighResTextObject_1.HighResTextObject(new HighResText_1.HighResText(2, "", style), this.getEnvironment().renderingEnvironment);
                // Visibility
                lengthText.visible = false;
                this.lengthTexts.push(lengthText);
                this.getView().addChild(lengthText);
            }
        }
        // Model
        onModelUpdated(model) {
            this.rectangleModel = model;
            this.redraw();
        }
        getModel() {
            return this.rectangleModel;
        }
        // AABB
        // @Override
        getAabbReferenceView() {
            return this.rectangle;
        }
        // Intersection test
        // @Override
        intersectsPointInScreenPx(x, y) {
            return this.intersectsRectangle(x, y) || this.pointIsCloseToEditableArea(x, y);
        }
        intersectsRectangle(x, y) {
            let mouseInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
            return ((mouseInRelative.x >= this.rectangleModel.min.x) && (mouseInRelative.x <= this.rectangleModel.max.x) &&
                (mouseInRelative.y >= this.rectangleModel.min.y) && (mouseInRelative.y <= this.rectangleModel.max.y));
        }
        // @Override
        pointIsCloseToEditableArea(x, y) {
            let mousePosition = new PIXI.Point(x, y);
            let editablePoints = this.getEditablePoints();
            let tolerance = Geofence_1.Geofence.EDITABLE_POINT_TOLERANCE_IN_PX;
            for (let i = 0; i < editablePoints.length; i++) {
                let editablePoint = editablePoints[i];
                let distance = Vector2_6.Vector2.getDistanceBetweenPoints(mousePosition, editablePoint);
                if (distance < tolerance) {
                    return true;
                }
            }
            return false;
        }
        getEditablePoints() {
            let editablePoints = new Array();
            let topLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.min.y));
            let topRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.min.y));
            let bottomLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.max.y));
            let bottomRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.max.y));
            editablePoints.push(topLeft);
            editablePoints.push(topRight);
            editablePoints.push(bottomLeft);
            editablePoints.push(bottomRight);
            return editablePoints;
        }
        // Editing
        // @Override
        onEditStart(x, y) {
            let pointInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
            this.editing = true;
            if (Math.abs(pointInRelative.x - this.rectangleModel.min.x) < Math.abs(pointInRelative.x - this.rectangleModel.max.x)) {
                this.editingMinX = true;
                this.editingMaxX = false;
            }
            else {
                this.editingMinX = false;
                this.editingMaxX = true;
            }
            if (Math.abs(pointInRelative.y - this.rectangleModel.min.y) < Math.abs(pointInRelative.y - this.rectangleModel.max.y)) {
                this.editingMinY = true;
                this.editingMaxY = false;
            }
            else {
                this.editingMinY = false;
                this.editingMaxY = true;
            }
        }
        // @Override
        onEditMove(x, y) {
            if (this.editing === true) {
                // Get mouse position in relative coordinates
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
                let pointInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
                // Constrain the mouse to the world borders.
                pointInRelative.x = Math.max(0, Math.min(1, pointInRelative.x));
                pointInRelative.y = Math.max(0, Math.min(1, pointInRelative.y));
                // Model update
                if (this.editingMinX) {
                    this.rectangleModel.min.x = pointInRelative.x;
                }
                else if (this.editingMaxX) {
                    this.rectangleModel.max.x = pointInRelative.x;
                }
                if (this.editingMinY) {
                    this.rectangleModel.min.y = pointInRelative.y;
                }
                else if (this.editingMaxY) {
                    this.rectangleModel.max.y = pointInRelative.y;
                }
                // Model constraints: Min must always be smaller than max.
                if (this.rectangleModel.min.x > this.rectangleModel.max.x) {
                    let helper = this.rectangleModel.min.x;
                    this.rectangleModel.min.x = this.rectangleModel.max.x;
                    this.rectangleModel.max.x = helper;
                    let helperEditing = this.editingMinX;
                    this.editingMinX = this.editingMaxX;
                    this.editingMaxX = helperEditing;
                }
                if (this.rectangleModel.min.y > this.rectangleModel.max.y) {
                    let helper = this.rectangleModel.min.y;
                    this.rectangleModel.min.y = this.rectangleModel.max.y;
                    this.rectangleModel.max.y = helper;
                    let helperEditing = this.editingMinY;
                    this.editingMinY = this.editingMaxY;
                    this.editingMaxY = helperEditing;
                }
                // View update
                this.redraw();
            }
        }
        // @Override
        onEditStop(x, y) {
            this.editing = false;
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
            let minInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.rectangleModel.min);
            this.movingPointInLocalCoords = new PIXI.Point(pointInTx.x - minInTx.x, pointInTx.y - minInTx.y);
        }
        // @Override
        onMoveChanged(x, y) {
            let diffInTx = this.movingPointInLocalCoords;
            if (diffInTx !== null) {
                let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
                // Adjust min
                let oldMin = this.rectangleModel.min;
                let oldMinInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(oldMin);
                let newMinInTx = new PIXI.Point(pointInTx.x - diffInTx.x, pointInTx.y - diffInTx.y);
                let newMinInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newMinInTx);
                this.rectangleModel.min = newMinInRelative;
                // Adjust max
                let oldMax = this.rectangleModel.max;
                let oldMaxInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(oldMax);
                let widthInTx = oldMaxInTx.x - oldMinInTx.x;
                let heightInTx = oldMaxInTx.y - oldMinInTx.y;
                let newMaxInTx = new PIXI.Point(newMinInTx.x + widthInTx, newMinInTx.y + heightInTx);
                let newMaxInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(newMaxInTx);
                this.rectangleModel.max = newMaxInRelative;
                // World constraints
                this.resolveCollisionsWithWorld();
                // Redrawing
                this.redraw();
            }
        }
        resolveCollisionsWithWorld() {
            if (this.rectangleModel.min.x < 0) {
                let offset = 0 - this.rectangleModel.min.x;
                this.rectangleModel.min.x += offset;
                this.rectangleModel.max.x += offset;
            }
            if (this.rectangleModel.max.x > 1) {
                let offset = this.rectangleModel.max.x - 1;
                this.rectangleModel.min.x -= offset;
                this.rectangleModel.max.x -= offset;
            }
            if (this.rectangleModel.min.y < 0) {
                let offset = 0 - this.rectangleModel.min.y;
                this.rectangleModel.min.y += offset;
                this.rectangleModel.max.y += offset;
            }
            if (this.rectangleModel.max.y > 1) {
                let offset = this.rectangleModel.max.y - 1;
                this.rectangleModel.min.y -= offset;
                this.rectangleModel.max.y -= offset;
            }
        }
        // @Override
        onMoveStopped(x, y) {
            this.movingPointInLocalCoords = null;
        }
        // Centering
        // @Override
        translateAndScaleToCameraCenter() {
            // Compute new coordinates
            let camera = this.getScene().getCamera();
            let paddingInRelative = 0.4;
            let topLeftInScreenCoords = new PIXI.Point(camera.getScreenWidth() * (0.0 + paddingInRelative), camera.getScreenHeight() * (0.0 + paddingInRelative));
            let bottomRightInScreenCoords = new PIXI.Point(camera.getScreenWidth() * (1.0 - paddingInRelative), camera.getScreenHeight() * (1.0 - paddingInRelative));
            let topLeftInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(topLeftInScreenCoords);
            let bottomRightInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(bottomRightInScreenCoords);
            // Update model
            this.rectangleModel.min.x = topLeftInRelativeCoords.x;
            this.rectangleModel.min.y = topLeftInRelativeCoords.y;
            this.rectangleModel.max.x = bottomRightInRelativeCoords.x;
            this.rectangleModel.max.y = bottomRightInRelativeCoords.y;
            // Update view
            this.redraw();
        }
        // Rendering
        // @Override
        redraw() {
            this.redrawRectangle();
            this.redrawEditingPoints();
            this.redrawLengthTexts();
        }
        redrawRectangle() {
            let camera = this.getScene().getCamera();
            // Line width
            let lineWidhtInPx = 2;
            let lineWidthInTx = camera.getPixelsInTexels(lineWidhtInPx);
            // Line color
            let lineColor = Geofence_1.Geofence.DEFAULT_BORDER_COLOR;
            if (this.isSelected()) {
                lineColor = Geofence_1.Geofence.SELECTED_BORDER_COLOR;
            }
            else if (this.isMouseOver()) {
                lineColor = Geofence_1.Geofence.MOUSE_OVER_BORDER_COLOR;
            }
            // Rectangle shape
            let min = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.rectangleModel.min);
            let max = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.rectangleModel.max);
            // Rectangle color
            let color = Geofence_1.Geofence.LEFT_SHAPE_COLOR;
            if (this.getStateModel() !== null) {
                if (this.getStateModel().state === "ENTERED") {
                    color = Geofence_1.Geofence.ENTERED_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "LEFT") {
                    color = Geofence_1.Geofence.LEFT_SHAPE_COLOR;
                }
                else if (this.getStateModel().state === "UNKNOWN") {
                    color = Geofence_1.Geofence.UNKNOWN_SHAPE_COLOR;
                }
            }
            // Draw rectangle
            this.rectangle.clear();
            this.rectangle.beginFill(color);
            this.rectangle.lineStyle(lineWidthInTx, lineColor);
            this.rectangle.drawRect(min.x, min.y, max.x - min.x, max.y - min.y);
            this.rectangle.endFill();
        }
        redrawEditingPoints() {
            if (this.isMouseOver() || this.isMouseAboveEditPoint()) {
                if (this.isEditModeActive()) {
                    this.makeEditPointsVisible(true);
                    this.repositionEditPoints();
                    this.rescaleEditPoints();
                }
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            let topLeftInRelative = new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.min.y);
            let topRightInRelative = new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.min.y);
            let bottomLeftInRelative = new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.max.y);
            let bottomRightInRelative = new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.max.y);
            let topLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topLeftInRelative);
            let topRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topRightInRelative);
            let bottomLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomLeftInRelative);
            let bottomRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomRightInRelative);
            this.editingPoints[0].position = new Point_3.Point(topLeftInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[1].position = new Point_3.Point(topRightInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[2].position = new Point_3.Point(bottomLeftInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[3].position = new Point_3.Point(bottomRightInTx, this.getEnvironment().renderingEnvironment);
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = Geofence_1.Geofence.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawLengthTexts() {
            if (this.isMouseOver() && this.isEditModeActive()) {
                this.makeLengthTextsVisible(true);
                this.updateLengthTexts();
            }
            else {
                this.makeLengthTextsVisible(false);
            }
        }
        makeLengthTextsVisible(visible) {
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                lengthText.visible = visible;
            }
        }
        updateLengthTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            let points = this.getRectanglePointsInTx();
            for (let i = 0; i < this.lengthTexts.length; i++) {
                let lengthText = this.lengthTexts[i];
                let pointA = points[i];
                let pointB = points[(i + 1) % points.length];
                // Compute distance in meters
                let distanceInTx = Vector2_6.Vector2.getDistanceBetweenPoints(pointA, pointB);
                let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
                let distanceInM = distanceInCm / 100.0;
                // Text
                let newText = "" + distanceInM.toFixed(1) + " m";
                if (lengthText.text !== newText) {
                    lengthText.text = newText;
                }
                // Scale
                lengthText.setScaleX(scaleFactor);
                lengthText.setScaleY(scaleFactor);
                // Orientation
                lengthText.rotation = cameraOrientation;
                // Position
                let penetrationResolutionVector = this.getInterpenetrationResolutionVector(pointA, pointB, lengthText);
                lengthText.x = pointA.x + ((pointB.x - pointA.x) / 2) - lengthText.width / 2 + penetrationResolutionVector.x;
                lengthText.y = pointA.y + ((pointB.y - pointA.y) / 2) - lengthText.height / 2 + penetrationResolutionVector.y;
            }
        }
        getRectanglePointsInTx() {
            let points = [];
            let point1InRelative = new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.min.y);
            let point2InRelative = new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.min.y);
            let point3InRelative = new PIXI.Point(this.rectangleModel.max.x, this.rectangleModel.max.y);
            let point4InRelative = new PIXI.Point(this.rectangleModel.min.x, this.rectangleModel.max.y);
            let point1InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point1InRelative);
            let point2InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point2InRelative);
            let point3InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point3InRelative);
            let point4InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point4InRelative);
            points.push(point1InTx);
            points.push(point2InTx);
            points.push(point3InTx);
            points.push(point4InTx);
            return points;
        }
        getInterpenetrationResolutionVector(pointA, pointB, lengthText) {
            let edgeX = pointB.x - pointA.x;
            let edgeY = pointB.y - pointA.y;
            let normalX = edgeY;
            let normalY = -edgeX;
            let normalizedNormalVector = Vector2_6.Vector2.normalizePoint(new PIXI.Point(normalX, normalY));
            let depthInTx = 0;
            // Padding
            let camera = this.getScene().getCamera();
            let paddingInPx = Geofence_1.Geofence.TEXT_PADDING_PX;
            let paddingInTx = camera.getPixelsInTexels(paddingInPx);
            if (Math.abs(normalY) > Math.abs(normalX)) {
                depthInTx = lengthText.height / 2 + paddingInTx;
            }
            else {
                depthInTx = lengthText.width / 2 + paddingInTx;
            }
            let penetrationVector = new PIXI.Point(normalizedNormalVector.x * depthInTx, normalizedNormalVector.y * depthInTx);
            return penetrationVector;
        }
    };
    RectangleGeofence = __decorate([
        RelutionMapObject_7.RelutionModelBinding(GeofenceModel_1.RectangleGeofenceModel)
    ], RectangleGeofence);
    exports.RectangleGeofence = RectangleGeofence;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofence", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel"], function (require, exports, Geofence_2, RelutionMapObject_8, GeofenceModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let CircleGeofence = class CircleGeofence extends Geofence_2.Geofence {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.circleModel = model;
        }
        // Model
        onModelUpdated(model) {
            // TODO
        }
        getModel() {
            return this.circleModel;
        }
        // Editing
        // @Override
        pointIsCloseToEditableArea(x, y) {
            return false;
        }
        // @Override
        onEditStart(x, y) {
        }
        // @Override
        onEditMove(x, y) {
        }
        // @Override
        onEditStop(x, y) {
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
        }
        // @Override
        onMoveChanged(x, y) {
        }
        // @Override
        onMoveStopped(x, y) {
        }
        // Centering
        // @Override
        translateAndScaleToCameraCenter() {
        }
        // Redrawing
        redraw() {
            // TODO
        }
        // Configuration
        setHighlighted(highlighted) {
            // TODO
        }
        isHighlighted() {
            // TODO
            return false;
        }
    };
    CircleGeofence = __decorate([
        RelutionMapObject_8.RelutionModelBinding(GeofenceModel_2.CircleGeofenceModel)
    ], CircleGeofence);
    exports.CircleGeofence = CircleGeofence;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofence", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/geofence/GeofenceModel"], function (require, exports, Geofence_3, RelutionMapObject_9, GeofenceModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let PolygonGeofence = class PolygonGeofence extends Geofence_3.Geofence {
        // Construction
        constructor(config, environment, floorplanLayer, model) {
            super(config, environment, floorplanLayer, model);
            this.polygonModel = model;
        }
        // Model update
        onModelUpdated(model) {
            // TODO
        }
        getModel() {
            return this.polygonModel;
        }
        // Editing
        // @Override
        pointIsCloseToEditableArea(x, y) {
            return false;
        }
        // @Override
        onEditStart(x, y) {
        }
        // @Override
        onEditMove(x, y) {
        }
        // @Override
        onEditStop(x, y) {
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
        }
        // @Override
        onMoveChanged(x, y) {
        }
        // @Override
        onMoveStopped(x, y) {
        }
        // Centering
        // @Override
        translateAndScaleToCameraCenter() {
        }
        // Redrawing
        redraw() {
            // TODO
        }
        // Configuration
        setHighlighted(highlighted) {
            // TODO
        }
        isHighlighted() {
            // TODO
            return false;
        }
    };
    PolygonGeofence = __decorate([
        RelutionMapObject_9.RelutionModelBinding(GeofenceModel_3.PolygonGeofenceModel)
    ], PolygonGeofence);
    exports.PolygonGeofence = PolygonGeofence;
});
define("src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", ["require", "exports", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofence", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofence", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofence", "src/app/relution/model/geofence/GeofenceStateModel", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, RectangleGeofence_1, CircleGeofence_1, PolygonGeofence_1, GeofenceStateModel_1, RelutionMapObjectLayer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let GeofenceLayer = class GeofenceLayer extends RelutionMapObjectLayer_2.RelutionMapObjectLayer {
        // Loading geofence state models
        loadGeofenceStateModels(models) {
            this.resetAllGeofencesToLeftState();
            this.updateGeofenceStates(models);
        }
        resetAllGeofencesToLeftState() {
            for (let i = 0; i < this.getObjects().length; i++) {
                let geofence = this.getObjects()[i];
                let state = new GeofenceStateModel_1.GeofenceStateModel();
                state.geofenceUuid = geofence.getModel().uuid;
                geofence.updateStateModel(state);
            }
        }
        updateGeofenceStates(models) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let geofence = this.getObjectWithUuid(model.geofenceUuid);
                geofence.updateStateModel(model);
            }
        }
    };
    GeofenceLayer = __decorate([
        RelutionMapObjectLayer_2.RelutionMapObjectBinding(CircleGeofence_1.CircleGeofence, PolygonGeofence_1.PolygonGeofence, RectangleGeofence_1.RectangleGeofence)
    ], GeofenceLayer);
    exports.GeofenceLayer = GeofenceLayer;
});
define("src/map/utils/Prando", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* tslint:disable */
    //Taken from https://github.com/zeh/prando
    class Prando {
        constructor(seed = undefined) {
            if (typeof (seed) === "string") {
                // String seed
                this._seed = this.hashCode(seed);
            }
            else if (typeof (seed) === "number") {
                // Numeric seed
                this._seed = seed;
            }
            else {
                // Pseudo-random seed
                this._seed = Date.now() + Math.random();
            }
            this.reset();
        }
        // ================================================================================================================
        // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------
        /**
         * Generates a pseudo-random number between a lower (inclusive) and a higher (exclusive) bounds.
         *
         * @param min - The minimum number that can be randomly generated.
         * @param pseudoMax - The maximum number that can be randomly generated (exclusive).
         * @return The generated pseudo-random number.
         */
        next(min = 0, pseudoMax = 1) {
            this.recalculate();
            return this.map(this._value, Prando.MIN, Prando.MAX, min, pseudoMax);
        }
        /**
         * Generates a pseudo-random integer number in a range (inclusive).
         *
         * @param min - The minimum number that can be randomly generated.
         * @param max - The maximum number that can be randomly generated.
         * @return The generated pseudo-random number.
         */
        nextInt(min = 10, max = 100) {
            this.recalculate();
            return Math.floor(this.map(this._value, Prando.MIN, Prando.MAX, min, max + 1));
        }
        /**
         * Generates a pseudo-random string sequence of a particular length from a specific character range.
         *
         * Note: keep in mind that creating a random string sequence does not guarantee uniqueness; there is always a
         * 1 in (char_length^string_length) chance of collision. For real unique string ids, always check for
         * pre-existing ids, or employ a robust GUID/UUID generator.
         *
         * @param length - Length of the strting to be generated.
         * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
         * @return The generated string sequence.
         */
        nextString(length = 16, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
            let str = "";
            while (str.length < length) {
                str += this.nextChar(chars);
            }
            return str;
        }
        /**
         * Generates a pseudo-random string of 1 character specific character range.
         *
         * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
         * @return The generated character.
         */
        nextChar(chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789") {
            this.recalculate();
            return chars.substr(this.nextInt(0, chars.length - 1), 1);
        }
        /**
         * Picks a pseudo-random item from an array. The array is left unmodified.
         *
         * Note: keep in mind that while the returned item will be random enough, picking one item from the array at a time
         * does not guarantee nor imply that a sequence of random non-repeating items will be picked. If you want to
         * *pick items in a random order* from an array, instead of *pick one random item from an array*, it's best to
         * apply a *shuffle* transformation to the array instead, then read it linearly.
         *
         * @param array - Array of any type containing one or more candidates for random picking.
         * @return An item from the array.
         */
        nextArrayItem(array) {
            this.recalculate();
            return array[this.nextInt(0, array.length - 1)];
        }
        /**
         * Generates a pseudo-random boolean.
         *
         * @return A value of true or false.
         */
        nextBoolean() {
            this.recalculate();
            return this._value > 0.5;
        }
        /**
         * Skips ahead in the sequence of numbers that are being generated. This is equivalent to
         * calling next() a specified number of times, but faster since it doesn't need to map the
         * new random numbers to a range and return it.
         *
         * @param iterations - The number of items to skip ahead.
         */
        skip(iterations = 1) {
            while (iterations-- > 0) {
                this.recalculate();
            }
        }
        /**
         * Reset the pseudo-random number sequence back to its starting seed. Further calls to next()
         * will then produce the same sequence of numbers it had produced before. This is equivalent to
         * creating a new Prando instance with the same seed as another Prando instance.
         *
         * Example:
         * let rng = new Prando(12345678);
         * console.log(rng.next()); // 0.6177754114889017
         * console.log(rng.next()); // 0.5784605181725837
         * rng.reset();
         * console.log(rng.next()); // 0.6177754114889017 again
         * console.log(rng.next()); // 0.5784605181725837 again
         */
        reset() {
            this._value = this._seed;
        }
        // ================================================================================================================
        // PRIVATE INTERFACE ----------------------------------------------------------------------------------------------
        recalculate() {
            // Xorshift*32
            // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper
            this._value ^= this._value << 13;
            this._value ^= this._value >> 17;
            this._value ^= this._value << 5;
        }
        map(val, minFrom, maxFrom, minTo, maxTo) {
            return ((val - minFrom) / (maxFrom - minFrom)) * (maxTo - minTo) + minTo;
        }
        hashCode(str) {
            let hash = 0;
            if (str) {
                let l = str.length;
                for (let i = 0; i < l; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
            }
            return hash;
        }
    }
    Prando.MIN = -2147483648; // Int32 min
    Prando.MAX = 2147483647; // Int32 max
    exports.Prando = Prando;
});
// tslint:disable
define("src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
    Copyright (c) 2015, Vladimir Agafonkin
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without modification, are
    permitted provided that the following conditions are met:
    
       1. Redistributions of source code must retain the above copyright notice, this list of
          conditions and the following disclaimer.
    
       2. Redistributions in binary form must reproduce the above copyright notice, this list
          of conditions and the following disclaimer in the documentation and/or other materials
          provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    /**
     * Canvas based heatmap implementation based on the SimpleHeat library:
     * https://github.com/mourner/simpleheat
     */
    class CanvasHeatmap {
        constructor(canvas) {
            this.defaultGradient = {
                0.4: 'blue',
                0.6: 'cyan',
                0.7: 'lime',
                0.8: 'yellow',
                1.0: 'red'
            };
            this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
            this._ctx = canvas.getContext('2d');
            this._width = canvas.width;
            this._height = canvas.height;
            this._max = 1;
            this._data = [];
        }
        data(data) {
            this._data = data;
            return this;
        }
        max(max) {
            this._max = max;
            return this;
        }
        add(point) {
            this._data.push(point);
            return this;
        }
        clear() {
            this._data = [];
            return this;
        }
        radius(r, blur) {
            blur = blur === undefined ? 15 : blur;
            // create a grayscale blurred circle image that we'll use for drawing points
            var circle = this._circle = this._createCanvas(), ctx = circle.getContext('2d'), r2 = this._r = r + blur;
            circle.width = circle.height = r2 * 2;
            ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
            ctx.shadowBlur = blur;
            ctx.shadowColor = 'black';
            ctx.beginPath();
            ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            return this;
        }
        resize() {
            this._width = this._canvas.width;
            this._height = this._canvas.height;
        }
        gradient(grad) {
            // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
            var canvas = this._createCanvas(), ctx = canvas.getContext('2d'), gradient = ctx.createLinearGradient(0, 0, 0, 256);
            canvas.width = 1;
            canvas.height = 256;
            for (var i in grad) {
                gradient.addColorStop(+i, grad[i]);
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, 256);
            this._grad = ctx.getImageData(0, 0, 1, 256).data;
            return this;
        }
        draw(minOpacity) {
            if (!this._circle)
                this.radius(this.defaultRadius);
            if (!this._grad)
                this.gradient(this.defaultGradient);
            var ctx = this._ctx;
            ctx.clearRect(0, 0, this._width, this._height);
            // draw a grayscale heatmap by putting a blurred circle at each data point
            for (var i = 0, len = this._data.length, p; i < len; i++) {
                p = this._data[i];
                ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);
                ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);
            }
            // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
            var colored = ctx.getImageData(0, 0, this._width, this._height);
            this._colorize(colored.data, this._grad);
            ctx.putImageData(colored, 0, 0);
            return this;
        }
        _colorize(pixels, gradient) {
            for (var i = 0, len = pixels.length, j; i < len; i += 4) {
                j = pixels[i + 3] * 4; // get gradient color from opacity value
                if (j) {
                    pixels[i] = gradient[j];
                    pixels[i + 1] = gradient[j + 1];
                    pixels[i + 2] = gradient[j + 2];
                }
            }
        }
        _createCanvas() {
            if (typeof document !== 'undefined') {
                return document.createElement('canvas');
            }
            else {
                // create a new canvas instance in node.js
                // the canvas class needs to have a default constructor without any parameter
                return new this._canvas.constructor();
            }
        }
    }
    exports.CanvasHeatmap = CanvasHeatmap;
});
define("src/map/utils/MathUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MathUtils {
        static getNormalDistributedSample(mean, standardDeviation, prng) {
            let erfc = function (x) {
                let z = Math.abs(x);
                let t = 1 / (1 + z / 2);
                let r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 +
                    t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 +
                        t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 +
                            t * (-0.82215223 + t * 0.17087277)))))))));
                return x >= 0 ? r : 2 - r;
            };
            let ierfc = function (x) {
                if (x >= 2) {
                    return -100;
                }
                if (x <= 0) {
                    return 100;
                }
                let xx = (x < 1) ? x : 2 - x;
                let t = Math.sqrt(-2 * Math.log(xx / 2));
                let r = -0.70711 * ((2.30753 + t * 0.27061) /
                    (1 + t * (0.99229 + t * 0.04481)) - t);
                for (let j = 0; j < 2; j++) {
                    let err = erfc(r) - xx;
                    r += err / (1.12837916709551257 * Math.exp(-(r * r)) - r * err);
                }
                return (x < 1) ? r : -r;
            };
            let n = prng.next();
            return mean - standardDeviation * Math.sqrt(2) * ierfc(2 * n);
        }
    }
    exports.MathUtils = MathUtils;
});
define("src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", ["require", "exports", "src/app/relution/model/usercount/HeatmapModel", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/map/utils/Prando", "src/app/relution/utils/RssiToDistance", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", "src/map/utils/MathUtils", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/BaseTexture", "src/engine/rendering/texture/Texture"], function (require, exports, HeatmapModel_1, Beacon_7, Prando_1, RssiToDistance_2, FloorplanRelatedLayer_6, CanvasHeatmap_1, MathUtils_1, SpriteObject_8, BaseTexture_4, Texture_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UserCountHeatmapLayer extends FloorplanRelatedLayer_6.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Observers
            this.heatmapObservers = new Array();
            // Animation
            this.animationModeEnabled = false;
            this.lastAnimationUpdateTimeInMs = 0;
            this.updatingAnimationRequired = false;
            this.currentAnimationTimeInSec = 0;
            this.heatmapLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.deviceLayer.addObserver(this);
            this.initView();
        }
        // Observers
        addHeatmapObserver(observer) {
            this.heatmapObservers.push(observer);
        }
        removeHeatmapObserver(observer) {
            let index = this.heatmapObservers.indexOf(observer);
            if (index > -1) {
                this.heatmapObservers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.heatmapObservers.length; i++) {
                let observer = this.heatmapObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Event-Handling: Beacon-Layer
        // @Override
        onObjectsLoaded(devices) {
            if (this.heatmapData != null) {
                let drawingHeatmapModel = this.mergedHeatmapModel;
                this.reinitializeHeatmap(drawingHeatmapModel);
            }
        }
        reinitializeHeatmap(drawingHeatmapModel) {
            this.currentHeatmapModel = drawingHeatmapModel;
            // Update device model
            this.addUserCountToBeaconModel();
            // Notify observers
            this.notifyObservers("currentHeatmapModelChanged", [this]);
            // Redraw heatmap
            this.redrawHeatmap(drawingHeatmapModel);
        }
        addUserCountToBeaconModel() {
            let beacons = this.deviceLayer.getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                let userCount = this.getUserCount(beacon);
                if (userCount !== -1) {
                    let beaconModel = beacon.getModel();
                    beaconModel.userCount = userCount;
                }
            }
        }
        getUserCount(device) {
            let userCount = -1;
            let heatmapModel = this.getCurrentHeatmapModel();
            if (heatmapModel != null) {
                let heatmapDeviceModel = this.getHeatmapModelForDevice(device, heatmapModel);
                if (heatmapDeviceModel != null) {
                    if (device instanceof Beacon_7.Beacon) {
                        if (heatmapModel != null) {
                            let avgNumUsers = heatmapDeviceModel.totalPacketsCount;
                            let avgNumUsersRounded = Math.round(avgNumUsers * 10) / 10;
                            if (isNaN(avgNumUsersRounded)) {
                                avgNumUsersRounded = 0;
                            }
                            userCount = avgNumUsersRounded;
                        }
                        else {
                            userCount = 0;
                        }
                    }
                }
            }
            return userCount;
        }
        getHeatmapModelForDevice(device, heatmapModel) {
            let heatmapData = heatmapModel.data;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapDeviceModel = heatmapData[i];
                if (heatmapDeviceModel.deviceUuid === device.getModel().uuid) {
                    return heatmapDeviceModel;
                }
            }
            return null;
        }
        // @Override
        onObjectsUnloaded(devices) {
            // Nothing to do
        }
        // @Override
        onObjectMovedToMap(beacon) {
            // Nothing to do
        }
        // @Override
        onObjectMovedToStock(beacon) {
            // Nothing to do
        }
        // View
        initView() {
            // Init canvas
            this.heatmapCanvas = document.createElement("canvas");
            let floorWidth = this.getFloorplanLayer().getFloorSize().x;
            let floorHeight = this.getFloorplanLayer().getFloorSize().y;
            this.heatmapCanvas.width = this.heatmapLayerConfig.canvasWidth;
            this.heatmapCanvas.height = this.heatmapCanvas.width * (floorHeight / floorWidth);
            // Init Sprite
            let baseTexture = new BaseTexture_4.BaseTexture(new PIXI.BaseTexture(this.heatmapCanvas), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_8.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            baseTexture.mipmap = true;
            this.heatmapSprite = new SpriteObject_8.SpriteObject(new PIXI.Sprite(texture.pixi()), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.heatmapSprite);
            // Scale
            this.heatmapSprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.heatmapSprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Position
            this.heatmapSprite.x = 0;
            this.heatmapSprite.y = 0;
        }
        // Drawing
        redrawHeatmap(drawingHeatmapModel) {
            this.drawHeatmap(drawingHeatmapModel);
            this.updateTexture();
        }
        // The new heatmap implementation
        drawHeatmap(drawingHeatmapModel) {
            // Create heatmap
            let heatmap = new CanvasHeatmap_1.CanvasHeatmap(this.heatmapCanvas);
            // Configure heatmap
            heatmap.clear();
            heatmap.max(1.0);
            let floorplanWidthInMeter = this.getFloorplanLayer().getFloorSize().x / this.getFloorplanLayer().getModel().pixelPerMeter;
            heatmap.radius(this.heatmapLayerConfig.heatpointRadiusInPixels);
            // Create heatpoints for each device
            let heatmapData = drawingHeatmapModel.data;
            for (let i = 0; i < heatmapData.length; i++) {
                let heatmapModel = heatmapData[i];
                let pnrg = new Prando_1.Prando(drawingHeatmapModel.startTimeSec + heatmapModel.getRandomSeed());
                this.drawHeatpoints(heatmap, heatmapModel, pnrg);
            }
            // Draw heatmap
            heatmap.draw();
        }
        drawHeatpoints(heatmap, heatmapModel, pnrg) {
            // Randomly draw heatpoints around the target beacon.
            let relativeNumOfMeasuredDevices = this.getRelativeNumberOfMeasuredDevices(heatmapModel);
            let numHeatpoints = relativeNumOfMeasuredDevices * 1000;
            for (let j = 0; j < numHeatpoints; j++) {
                // Noise for length
                // let mean = this.getMeanUserDistanceInMeter(heatmapModel);
                let mean = 0;
                let maxNoiseDistanceToBeaconInMeter = RssiToDistance_2.RssiToDistance.rssiToDistance(this.heatmapLayerConfig.maxReceivableRssi);
                let standardDeviationInMeter = maxNoiseDistanceToBeaconInMeter / 6;
                let noiseDistanceInMeter = MathUtils_1.MathUtils.getNormalDistributedSample(mean, standardDeviationInMeter, pnrg);
                let floorplanWidthInMeter = this.getFloorplanLayer().getFloorSize().x / this.getFloorplanLayer().getModel().pixelPerMeter;
                let noiseDistanceInCanvasPixels = (noiseDistanceInMeter / floorplanWidthInMeter) * this.heatmapCanvas.width;
                // Noise for direction
                let noiseAngle = 2 * Math.PI * pnrg.next();
                // Position
                let deviceModel = this.getDeviceModelForHeatmapModel(heatmapModel);
                if (deviceModel != null) {
                    let x = (deviceModel.x * this.heatmapCanvas.width) + noiseDistanceInCanvasPixels * Math.cos(noiseAngle);
                    let y = (deviceModel.y * this.heatmapCanvas.height) + noiseDistanceInCanvasPixels * Math.sin(noiseAngle);
                    // Add heatpoint
                    heatmap.add([x, y, 1]);
                }
            }
        }
        getRelativeNumberOfMeasuredDevices(heatmapModel) {
            let kMinExpectedNumDevices = 0;
            let kMaxExpectedNumDevices = this.heatmapLayerConfig.definitionOfManyDevices;
            // Actually the number of active devices are delivered and not "totalPacketsCount".
            let numActiveDevicesInTimeInterval = heatmapModel.totalPacketsCount;
            // The number of reports delivered in the selected time interval.
            let packetsInTimeInterval = heatmapModel.totalPackets;
            if (numActiveDevicesInTimeInterval <= 0 || packetsInTimeInterval <= 0) {
                return 0;
            }
            // Relative number of devices \in [0,infinity], where 1 means kMaxExpectedNumDevices.
            let relativeNumberOfDevices = (numActiveDevicesInTimeInterval - kMinExpectedNumDevices)
                / (kMaxExpectedNumDevices - kMinExpectedNumDevices);
            relativeNumberOfDevices = Math.min(Math.max(0, relativeNumberOfDevices), 1);
            return relativeNumberOfDevices;
        }
        getDeviceModelForHeatmapModel(heatmapModel) {
            let devices = this.deviceLayer.getAllDevices();
            for (let i = 0; i < devices.length; i++) {
                let deviceModel = devices[i].getModel();
                if (deviceModel.uuid === heatmapModel.deviceUuid) {
                    return deviceModel;
                }
            }
            return null;
        }
        updateTexture() {
            this.heatmapSprite.texture.baseTexture.loadSource(this.heatmapCanvas);
        }
        // Model
        loadHeatmapData(heatmapData) {
            this.heatmapData = heatmapData;
            let devices = this.deviceLayer.getAllDevices();
            if (devices != null) {
                // Update merged heatmap data
                this.mergedHeatmapModel = HeatmapModel_1.HeatmapModel.createMergedHeatmapModel(this.heatmapData);
                // Redraw heatmap
                this.reinitializeHeatmap(this.mergedHeatmapModel);
            }
        }
        // Animation
        // @Override
        onAnimationModeEnabled(animationModeEnabled) {
            this.animationModeEnabled = animationModeEnabled;
            if (!this.animationModeEnabled) {
                if (this.heatmapData != null) {
                    this.reinitializeHeatmap(this.mergedHeatmapModel);
                }
            }
        }
        // @Override
        onUpdateAnimationFrame(timeInSec) {
            this.currentAnimationTimeInSec = timeInSec;
            this.updatingAnimationRequired = true;
        }
        getProgressForTime(timeInSec) {
            let startTimeSec = this.mergedHeatmapModel.startTimeSec;
            let endTimeSec = this.mergedHeatmapModel.endTimeSec;
            // Constrain to borders
            timeInSec = Math.max(startTimeSec, Math.min(endTimeSec, timeInSec));
            // Get progress
            let progress = (timeInSec - startTimeSec) / (endTimeSec - startTimeSec);
            return progress;
        }
        updateHeatmapAnimation(currentProgress) {
            // Redraw heatmap
            if (this.heatmapData != null) {
                let currentAnimatedHeatmapModel = this.getCurrentAnimatedHeatmapModel(currentProgress);
                if (currentAnimatedHeatmapModel != null) {
                    this.reinitializeHeatmap(currentAnimatedHeatmapModel);
                }
            }
        }
        getCurrentAnimatedHeatmapModel(currentProgress) {
            let startTimeInMs = this.mergedHeatmapModel.startTimeSec;
            let endTimeInMs = this.mergedHeatmapModel.endTimeSec;
            let progressTimeInMs = startTimeInMs + (currentProgress * (endTimeInMs - startTimeInMs));
            // Find the heatmap model that matches with the progress time
            for (let i = 0; i < this.heatmapData.length; i++) {
                let heatmapModel = this.heatmapData[i];
                if (heatmapModel.startTimeSec <= progressTimeInMs && heatmapModel.endTimeSec >= progressTimeInMs) {
                    return heatmapModel;
                }
            }
            return null;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAnimationIfNecessary();
        }
        updateAnimationIfNecessary() {
            if (this.updatingAnimationRequired && this.animationModeEnabled) {
                if (this.heatmapData != null) {
                    let timeSinceLastUpdateInMs = Date.now() - this.lastAnimationUpdateTimeInMs;
                    if (timeSinceLastUpdateInMs > 1000) {
                        let currentProgress = this.getProgressForTime(this.currentAnimationTimeInSec);
                        this.updateHeatmapAnimation(currentProgress);
                        this.lastAnimationUpdateTimeInMs = Date.now();
                        this.updatingAnimationRequired = false;
                    }
                }
            }
        }
        // Getters and setters
        getMergedHeatmapModel() {
            return this.mergedHeatmapModel;
        }
        getCurrentHeatmapModel() {
            return this.currentHeatmapModel;
        }
    }
    exports.UserCountHeatmapLayer = UserCountHeatmapLayer;
    (function (UserCountHeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * The width of the canvas in texels
                 */
                this.canvasWidth = 1024;
                /**
                 * The number of measured devices that are necessary
                 * to display the beacon as "hot".
                 */
                this.definitionOfManyDevices = 5;
                /**
                 * RSSI thrshold
                 */
                this.maxReceivableRssi = -80; // RSSI threshold
                /**
                 * The heatpoint radius given in texels
                 */
                this.heatpointRadiusInPixels = 2;
            }
        }
        UserCountHeatmapLayer.Config = Config;
    })(UserCountHeatmapLayer = exports.UserCountHeatmapLayer || (exports.UserCountHeatmapLayer = {}));
});
// tslint:disable
define("src/engine/rendering/filters/TextureMatrix", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const tempMat = new PIXI.Matrix();
    /**
     * Class controls uv transform and frame clamp for texture
     * Can be used in Texture "transform" field, or separately, you can use different clamp settings on the same texture.
     * If you want to add support for texture region of certain feature or filter, that's what you're looking for.
     *
     * @see TextObjecture
     * @see PIXI.mesh.Mesh
     * @see PIXI.extras.TilingSprite
     * @class
     * @memberof PIXI
     */
    class TextureMatrix {
        /**
         *
         * @param {TextObjecture} texture observed texture
         * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         * @constructor
         */
        constructor(texture, clampMargin) {
            this._texture = texture;
            this.mapCoord = new PIXI.Matrix();
            this.uClampFrame = new Float32Array(4);
            this.uClampOffset = new Float32Array(2);
            this._lastTextureID = -1;
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
             *
             * @default 0
             * @member {number}
             */
            this.clampOffset = 0;
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
             *
             * @default 0.5
             * @member {number}
             */
            this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        }
        /**
         * texture property
         * @member {TextObjecture}
         */
        get texture() {
            return this._texture;
        }
        set texture(value) {
            this._texture = value;
            this._lastTextureID = -1;
        }
        /**
         * Multiplies uvs array to transform
         * @param {Float32Array} uvs mesh uvs
         * @param {Float32Array} [out=uvs] output
         * @returns {Float32Array} output
         */
        multiplyUvs(uvs, out) {
            if (out === undefined) {
                out = uvs;
            }
            const mat = this.mapCoord;
            for (let i = 0; i < uvs.length; i += 2) {
                const x = uvs[i];
                const y = uvs[i + 1];
                out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
                out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
            }
            return out;
        }
        /**
         * updates matrices if texture was changed
         * @param {boolean} forceUpdate if true, matrices will be updated any case
         * @returns {boolean} whether or not it was updated
         */
        update(forceUpdate) {
            const tex = this._texture;
            if (!tex || !tex.valid) {
                return false;
            }
            if (!forceUpdate
                && this._lastTextureID === tex._updateID) {
                return false;
            }
            this._lastTextureID = tex._updateID;
            const uvs = tex._uvs;
            this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
            const orig = tex.orig;
            const trim = tex.trim;
            if (trim) {
                tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
                this.mapCoord.append(tempMat);
            }
            const texBase = tex.baseTexture;
            const frame = this.uClampFrame;
            const margin = this.clampMargin / texBase.resolution;
            const offset = this.clampOffset;
            frame[0] = (tex._frame.x + margin + offset) / texBase.width;
            frame[1] = (tex._frame.y + margin + offset) / texBase.height;
            frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
            frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
            this.uClampOffset[0] = offset / texBase.realWidth;
            this.uClampOffset[1] = offset / texBase.realHeight;
            return true;
        }
    }
    exports.default = TextureMatrix;
});
define("src/engine/rendering/filters/SpriteInverseMaskFilter", ["require", "exports", "src/engine/rendering/filters/TextureMatrix"], function (require, exports, TextureMatrix_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The SpriteMaskFilter class
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI
     */
    class SpriteMaskFilter extends PIXI.Filter {
        /**
         * @param {SpriteObject} sprite - the target sprite
         */
        constructor(sprite) {
            const maskMatrix = new PIXI.Matrix();
            super(`
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat3 projectionMatrix;
            uniform mat3 otherMatrix;

            varying vec2 vMaskCoord;
            varying vec2 vTextureCoord;

            void main(void)
            {
                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

                vTextureCoord = aTextureCoord;
                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
            }
            `, `
            varying vec2 vMaskCoord;
            varying vec2 vTextureCoord;

            uniform sampler2D uSampler;
            uniform sampler2D mask;
            uniform float alpha;
            uniform vec4 maskClamp;

            void main(void)
            {
                float clip = step(3.5,
                    step(maskClamp.x, vMaskCoord.x) +
                    step(maskClamp.y, vMaskCoord.y) +
                    step(vMaskCoord.x, maskClamp.z) +
                    step(vMaskCoord.y, maskClamp.w));

                vec4 original = texture2D(uSampler, vTextureCoord);
                vec4 masky = texture2D(mask, vMaskCoord);

                original *= 1.0 - (masky.r * masky.a * alpha * clip);

                gl_FragColor = original;
            }

            `, "");
            sprite.renderable = false;
            this.maskSprite = sprite;
            this.maskMatrix = maskMatrix;
        }
        /**
         * Applies the filter
         *
         * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         */
        apply(filterManager, input, output) {
            const maskSprite = this.maskSprite;
            const tex = this.maskSprite.texture;
            if (!tex.valid) {
                return;
            }
            if (!tex.transform) {
                // margin = 0.0, let it bleed a bit, shader code becomes easier
                // assuming that atlas textures were made with 1-pixel padding
                tex.transform = new TextureMatrix_1.default(tex, 0.0);
            }
            tex.transform.update();
            this.uniforms.mask = tex;
            this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
                .prepend(tex.transform.mapCoord);
            this.uniforms.alpha = maskSprite.worldAlpha;
            this.uniforms.maskClamp = tex.transform.uClampFrame;
            filterManager.applyFilter(this, input, output);
        }
    }
    exports.default = SpriteMaskFilter;
});
define("src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/engine/rendering/filters/SpriteInverseMaskFilter", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/filters/SpriteInverseMaskFilter", "src/engine/rendering/texture/Texture"], function (require, exports, FloorplanRelatedLayer_7, SpriteInverseMaskFilter_1, SpriteObject_9, SpriteInverseMaskFilter_2, Texture_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WallplanLayer extends FloorplanRelatedLayer_7.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer, texture) {
            super(environment, floorplanLayer);
            this.wallplanLayerConfig = config;
            if (texture !== null && texture !== undefined) {
                this.initWallplanSprite(texture);
            }
        }
        initWallplanSprite(texture) {
            // Add texture to sprite
            this.wallplanSprite = new SpriteObject_9.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            texture.baseTexture.mipmap = true;
            this.wallplanSprite.texture = new Texture_9.Texture(texture, this.getEnvironment().renderingEnvironment);
            // Scale
            this.wallplanSprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.wallplanSprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Alpha
            this.wallplanSprite.alpha = 0.5;
            // Add sprite to scene graph
            this.getView().addChild(this.wallplanSprite);
            if (this.wallplanLayerConfig.useMasking) {
                // Set inverse wallmap as mask
                this.wallplanMaskSprite = new SpriteObject_9.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
                this.wallplanMaskSprite.texture = new Texture_9.Texture(texture, this.getEnvironment().renderingEnvironment);
                this.wallplanMaskSprite.width = this.wallplanSprite.width;
                this.wallplanMaskSprite.height = this.wallplanSprite.height;
                if (this.wallplanLayerConfig.useInverseMask) {
                    this.wallplanSprite.filters = [new SpriteInverseMaskFilter_1.default(this.wallplanMaskSprite.pixi())];
                }
                else {
                    this.wallplanSprite.filters = [new SpriteInverseMaskFilter_2.default(this.wallplanMaskSprite.pixi())];
                }
                this.getView().addChild(this.wallplanMaskSprite);
            }
        }
    }
    exports.WallplanLayer = WallplanLayer;
    (function (WallplanLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the wallplan layer should be masked
                 * (pixel intensity will be used for the alpha channel, as well).
                 *
                 * Default: true
                 */
                this.useMasking = true;
                /**
                 * True, if an inverse mask should be used.
                 * Inverse means that the black pixel values will be invisible,
                 * while the white ones will be opaque.
                 *
                 * Default: true
                 */
                this.useInverseMask = true;
            }
        }
        WallplanLayer.Config = Config;
    })(WallplanLayer = exports.WallplanLayer || (exports.WallplanLayer = {}));
});
define("src/app/relution/model/device/DeviceTagModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model"], function (require, exports, RelutionMapObjectModel_4, Model_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceTagModel extends RelutionMapObjectModel_4.RelutionMapObjectModel {
        constructor() {
            // Attributes
            super(...arguments);
            /**
             * The device UUID
             */
            this._deviceUuid = null;
            /**
             * The device ID, e.g. ABBB2
             */
            this._deviceId = "";
            /**
             * True, if the user explicitly set the coordinates.
             * False, otherwise. In this case the coordinates must be ignored.
             */
            this._valid = false;
            /**
             * x in [0,1] relative to the floorplan
             */
            this._x = 0;
            /**
             * y in [0,1] relative to the floorplan
             */
            this._y = 0;
        }
        // Getters and setters
        get deviceUuid() {
            return this._deviceUuid;
        }
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
        }
        get deviceId() {
            return this._deviceId;
        }
        set deviceId(deviceId) {
            this._deviceId = deviceId;
            this.notifyObservers("deviceId");
        }
        get valid() {
            return this._valid;
        }
        set valid(valid) {
            this._valid = valid;
            this.notifyObservers("valid");
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this._x = x;
            this.notifyObservers("x");
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this._y = y;
            this.notifyObservers("y");
        }
    }
    __decorate([
        RelutionMapObjectModel_4.ParentModel(),
        Model_9.ModelProperty()
    ], DeviceTagModel.prototype, "_deviceUuid", void 0);
    __decorate([
        Model_9.ModelProperty()
    ], DeviceTagModel.prototype, "_deviceId", void 0);
    __decorate([
        Model_9.ModelProperty()
    ], DeviceTagModel.prototype, "_valid", void 0);
    __decorate([
        Model_9.ModelProperty()
    ], DeviceTagModel.prototype, "_x", void 0);
    __decorate([
        Model_9.ModelProperty()
    ], DeviceTagModel.prototype, "_y", void 0);
    exports.DeviceTagModel = DeviceTagModel;
});
define("src/map/view/hud/objects/ArrowObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/math/Vector2", "src/map/utils/DeviceUtils", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/texture/Texture"], function (require, exports, SceneObject_8, Vector2_7, DeviceUtils_9, SpriteObject_10, DisplayObjectContainer_13, Texture_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ArrowObject extends SceneObject_8.SceneObject {
        // Initialization
        constructor(config, environment) {
            super(environment);
            this.config = config;
            this.initView();
        }
        initView() {
            this.container = new DisplayObjectContainer_13.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.initLineView(this.config.arrowBodyTextureName);
            this.initArrowHeadView(this.config.arrowHeadTextureName);
            this.getView().visible = false;
        }
        initLineView(arrowBodyTextureName) {
            this.lineView = new SpriteObject_10.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            let texture = PIXI.loader.resources["" + arrowBodyTextureName].texture;
            texture.baseTexture.mipmap = true;
            this.lineView.texture = new Texture_10.Texture(texture, this.getEnvironment().renderingEnvironment);
            this.lineView.tint = this.config.bodyColor;
            this.getView().addChild(this.lineView);
        }
        initArrowHeadView(arrowHeadTextureName) {
            this.arrowHeadView = new SpriteObject_10.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            let texture = PIXI.loader.resources["" + arrowHeadTextureName].texture;
            texture.baseTexture.mipmap = true;
            this.arrowHeadView.texture = new Texture_10.Texture(texture, this.getEnvironment().renderingEnvironment);
            this.arrowHeadView.tint = this.config.headColor;
            this.getView().addChild(this.arrowHeadView);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        getWidth() {
            return this.lineView.texture.width;
        }
        getHeight() {
            return this.lineView.texture.height;
        }
        setBodyColor(bodyColor) {
            this.config.bodyColor = bodyColor;
            this.lineView.tint = this.config.bodyColor;
        }
        getBodyColor() {
            return this.config.bodyColor;
        }
        // Drawing
        draw(sourcePositionInWorldTx, targetPositionInWorldTx, arrowThickness) {
            // Precomputation
            let sourceVector = Vector2_7.Vector2.getVector2(sourcePositionInWorldTx);
            let targetVector = Vector2_7.Vector2.getVector2(targetPositionInWorldTx);
            let differenceVector = Vector2_7.Vector2.subtract(targetVector, sourceVector);
            let arrowLength = differenceVector.getLength();
            // Arrow construction
            this.constructArrow(arrowLength, arrowThickness);
            // Arrow transformation
            this.transformArrow(sourceVector, targetVector);
            // Set visible
            this.getView().visible = true;
        }
        constructArrow(arrowLength, arrowThickness) {
            let thickness = DeviceUtils_9.DeviceUtils.getPhysicalPixelsFromLogical(arrowThickness);
            this.constructLine(arrowLength, thickness);
            this.constructArrowHead();
        }
        constructLine(arrowLength, thickness) {
            // Pivot
            this.lineView.pivot.x = 0;
            this.lineView.pivot.y = this.lineView.texture.height / 2;
            // Scale
            this.lineView.scale.x = arrowLength / this.getWidth();
            this.lineView.scale.y = thickness / this.getHeight();
        }
        constructArrowHead() {
            // Pivot
            this.arrowHeadView.pivot.x = this.arrowHeadView.texture.width;
            this.arrowHeadView.pivot.y = this.arrowHeadView.texture.height / 2;
            // Scale
            let camera = this.getScene().getCamera();
            let arrowHeadWidthInPhysicalPx = DeviceUtils_9.DeviceUtils.getPhysicalPixelsFromLogical(this.config.arrowHeadLengthInLogicalPx);
            let worldHeadWidthPointSource = camera.getWorldCoordinateFromImagePoint(new PIXI.Point(0, 0));
            let worldHeadWidthPointTarget = camera.getWorldCoordinateFromImagePoint(new PIXI.Point(arrowHeadWidthInPhysicalPx, 0));
            let worldHeadWidthPoint = new PIXI.Point(worldHeadWidthPointTarget.x - worldHeadWidthPointSource.x, worldHeadWidthPointTarget.y - worldHeadWidthPointSource.y);
            let arrowHeadWidthInTexels = Vector2_7.Vector2.getLengthOfPoint(worldHeadWidthPoint);
            let maxArrowHeadWidthInTexels = this.lineView.width * this.config.maxArrowHeadLengthInPercent;
            arrowHeadWidthInTexels = Math.min(maxArrowHeadWidthInTexels, arrowHeadWidthInTexels);
            this.arrowHeadView.width = arrowHeadWidthInTexels;
            this.arrowHeadView.height = (this.arrowHeadView.texture.height / this.arrowHeadView.texture.width) * this.arrowHeadView.width;
            // Rotation
            this.arrowHeadView.rotation = 0;
            // Translation
            this.arrowHeadView.x = this.lineView.width;
            this.arrowHeadView.y = 0;
        }
        transformArrow(sourceVector, targetVector) {
            // Preparation
            let differenceVector = Vector2_7.Vector2.subtract(targetVector, sourceVector);
            // Pivot
            this.getView().pivot.x = this.lineView.width / 2;
            this.getView().pivot.y = 0;
            // Rotate
            let baseVector = new Vector2_7.Vector2(1, 0);
            let rotation = -Vector2_7.Vector2.getAngleBetween(differenceVector, baseVector);
            // Sign
            let crossProduct = Vector2_7.Vector2.crossProduct(baseVector, differenceVector);
            if (crossProduct > 0) {
                this.getView().rotation = -rotation;
            }
            else {
                this.getView().rotation = rotation;
            }
            // Position
            let centerVector = Vector2_7.Vector2.add(sourceVector, targetVector).divide(2);
            this.getView().position.x = centerVector.getX();
            this.getView().position.y = centerVector.getY();
        }
    }
    exports.ArrowObject = ArrowObject;
    (function (ArrowObject) {
        class Config {
            constructor() {
                this.arrowBodyTextureName = "arrow_body";
                this.arrowHeadTextureName = "arrow_head";
                this.arrowHeadLengthInLogicalPx = DeviceUtils_9.DeviceUtils.getPhysicalPixelsFromLogical(12);
                this.maxArrowHeadLengthInPercent = 0.2;
                this.bodyColor = 0x000000;
                this.headColor = 0x000000;
            }
        }
        ArrowObject.Config = Config;
    })(ArrowObject = exports.ArrowObject || (exports.ArrowObject = {}));
});
define("src/app/relution/utils/IntersectionUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IntersectionUtils {
        static getIntersectingPointOfTwoVectors(v1, v2, e1, e2) {
            let x1 = v1.x;
            let y1 = v1.y;
            let x2 = v2.x;
            let y2 = v2.y;
            let x3 = e1.x;
            let y3 = e1.y;
            let x4 = e2.x;
            let y4 = e2.y;
            let denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denominator === 0) {
                // Lines are parallel or coincident.
                return null;
            }
            // u_a
            let numerator_ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
            let u_a = numerator_ua / denominator;
            // u_b
            let numerator_ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
            let u_b = numerator_ub / denominator;
            // Line segments only intersect if both u_a and u_b are in (0,1).
            // We use open intervals to prevent vector "touches" to be considered as intersections.
            // For numerical stability, we add a small number (epsilon) to the bounds.
            let epsilon = 0.0001;
            let lowerBound = 0.0 + epsilon;
            let upperBound = 1.0 - epsilon;
            if (u_a > lowerBound && u_a < upperBound && u_b > lowerBound && u_b < upperBound) {
                // Intersection point
                let x = x1 + u_a * (x2 - x1);
                let y = y1 + u_a * (y2 - y1);
                let intersectingPoint = new PIXI.Point(x, y);
                return intersectingPoint;
            }
            else {
                return null;
            }
        }
    }
    exports.IntersectionUtils = IntersectionUtils;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTag", ["require", "exports", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/model/device/DeviceTagModel", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/app/relution/utils/IntersectionUtils", "src/engine/math/Vector2", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture"], function (require, exports, RelutionMapObject_10, DeviceTagModel_1, ArrowObject_1, DeviceUtils_10, IntersectionUtils_1, Vector2_8, SpriteObject_11, Texture_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DeviceTag_1;
    let DeviceTag = DeviceTag_1 = class DeviceTag extends RelutionMapObject_10.RelutionMapObject {
        // Construction
        constructor(config, environment, floorplanLayer, model, device) {
            super(config, environment, floorplanLayer, model, device);
            // State: Scaling
            this.lastDeviceScaleFactor = -1;
            this.invalidated = true;
            this.device = device;
            this.tagModel = model;
            this.initTagView();
        }
        initTagView() {
            this.initArrowObject();
            this.initReferencePositionView();
            this.initEstimatedPositionView();
        }
        initReferencePositionView() {
            this.referencePositionView = new SpriteObject_11.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.initPositionView(this.referencePositionView);
            this.referencePositionView.tint = DeviceTag_1.REFERENCE_POSITION_COLOR;
        }
        initEstimatedPositionView() {
            this.estimatedPositionView = new SpriteObject_11.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.initPositionView(this.estimatedPositionView);
            this.estimatedPositionView.tint = DeviceTag_1.ESTIMATED_POSITION_COLOR;
        }
        initPositionView(spriteView) {
            this.getView().addChild(spriteView);
            // Texture
            let texture = PIXI.loader.resources["asset_device_white"].texture;
            texture.baseTexture.mipmap = true;
            spriteView.texture = new Texture_11.Texture(texture, this.getEnvironment().renderingEnvironment);
            // Pivot
            spriteView.pivot.x = spriteView.width / 2;
            spriteView.pivot.y = spriteView.height;
            // Scale
            spriteView.width = this.device.getView().width;
            spriteView.height = this.device.getView().height;
            // Position
            this.syncPositionWithDevice();
            // Alpha
            spriteView.alpha = 0.0;
        }
        initArrowObject() {
            let arrowObjectConfig = new ArrowObject_1.ArrowObject.Config();
            arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_10.DeviceUtils.getPhysicalPixelsFromLogical(15);
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
            arrowObjectConfig.bodyColor = DeviceTag_1.REFERENCE_POSITION_COLOR;
            arrowObjectConfig.headColor = arrowObjectConfig.bodyColor;
            this.arrowObject = new ArrowObject_1.ArrowObject(arrowObjectConfig, this.getEnvironment());
            this.arrowObject.getView().alpha = 0.0;
            this.addChild(this.arrowObject);
        }
        // Model
        // Tag model event handling
        // @Override
        onModelUpdated(model) {
            this.tagModel = model;
            this.invalidated = true;
        }
        // Device model event handling
        // @Override
        xChanged(deviceModel) {
            this.syncPositionWithDevice();
            this.invalidated = true;
        }
        // @Override
        yChanged(deviceModel) {
            this.syncPositionWithDevice();
            this.invalidated = true;
        }
        syncPositionWithDevice() {
            // Tag view should only move, if currently no valid tags exist (user has not tagged the device yet).
            if (!this.tagModel.valid) {
                this.tagModel.x = this.device.getModel().getPosition().x;
                this.tagModel.y = this.device.getModel().getPosition().y;
            }
        }
        // Rendering
        // @Override
        getAabbReferenceView() {
            return this.referencePositionView;
        }
        // @Override
        redraw() {
            this.invalidated = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                this.updateScale();
                this.invalidated = false;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastDeviceScaleFactor !== scaleFactor || this.invalidated) {
                this.lastDeviceScaleFactor = scaleFactor;
                this.retransformEstimatedPositionView();
                this.retransformReferencePositionView();
                this.retransformArrowObject(scaleFactor);
            }
        }
        retransformEstimatedPositionView() {
            if (this.tagModel.valid) {
                // Scale
                this.estimatedPositionView.width = this.device.getView().width;
                this.estimatedPositionView.height = this.device.getView().height;
                // Orientation
                this.estimatedPositionView.rotation = this.device.getView().rotation;
                // Position
                this.estimatedPositionView.x = this.device.getView().x;
                this.estimatedPositionView.y = this.device.getView().y;
                // Alpha
                this.estimatedPositionView.alpha = DeviceTag_1.ESTIMATED_POSITION_ALPHA;
            }
            else {
                // Alpha
                this.estimatedPositionView.alpha = 0.0;
            }
        }
        retransformReferencePositionView() {
            // Scale
            this.referencePositionView.width = this.device.getView().width;
            this.referencePositionView.height = this.device.getView().height;
            // Orientation
            this.referencePositionView.rotation = this.device.getView().rotation;
            // Position
            if (this.tagModel.valid) {
                this.referencePositionView.x = this.tagModel.x * this.getFloorplanLayer().getFloorSize().x;
                this.referencePositionView.y = this.tagModel.y * this.getFloorplanLayer().getFloorSize().y;
            }
            else {
                this.referencePositionView.x = this.device.getView().x;
                this.referencePositionView.y = this.device.getView().y;
            }
            // Alpha
            if (this.tagModel.valid) {
                this.referencePositionView.alpha = DeviceTag_1.REFERENCE_POSITION_ALPHA;
            }
            else {
                if (this.isMouseOver()) {
                    this.referencePositionView.alpha = 1.0;
                }
                else {
                    this.referencePositionView.alpha = 0.0;
                }
            }
        }
        retransformArrowObject(scaleFactor) {
            if (this.tagModel.valid) {
                // Line width
                let lineWidth = DeviceTag_1.LINE_WIDTH_IN_PX * scaleFactor;
                // Start and end position
                let devicePosition = this.device.getModel().getPosition();
                let deviceTagPosition = new PIXI.Point(this.tagModel.x, this.tagModel.y);
                let sourcePosition = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(devicePosition);
                let targetPosition = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(deviceTagPosition);
                // Resolve interpenetration for sprite view
                targetPosition = this.resolveInterpenetration(sourcePosition, targetPosition, this.referencePositionView);
                // Resolve interpenetration for device view
                sourcePosition = this.resolveInterpenetration(targetPosition, sourcePosition, this.device.getView());
                // Padding
                let paddingInTx = this.getFloorplanLayer().getTexelWidthFromPixelWidth(DeviceTag_1.PADDING_IN_PX);
                this.addPaddingToArrowObject(sourcePosition, targetPosition, paddingInTx);
                // Rendering
                this.arrowObject.draw(sourcePosition, targetPosition, lineWidth);
                // Alpha
                this.arrowObject.getView().alpha = DeviceTag_1.ESTIMATED_POSITION_ALPHA;
            }
            else {
                this.arrowObject.getView().alpha = 0.0;
            }
        }
        resolveInterpenetration(sourcePosition, targetPosition, penetratedView) {
            // Tag corners
            let boundsInScreenPx = penetratedView.pixi().getBounds();
            let topLeft = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(boundsInScreenPx.x + 0, boundsInScreenPx.y + 0));
            let topRight = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(boundsInScreenPx.x + boundsInScreenPx.width, boundsInScreenPx.y + 0));
            let bottomRight = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(boundsInScreenPx.x + boundsInScreenPx.width, boundsInScreenPx.y + boundsInScreenPx.height));
            let bottomLeft = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(boundsInScreenPx.x + 0, boundsInScreenPx.y + boundsInScreenPx.height));
            // Top edge intersection test
            let intersectingPoint = null;
            intersectingPoint = IntersectionUtils_1.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, topLeft, topRight);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Right edge intersection test
            intersectingPoint = IntersectionUtils_1.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, topRight, bottomRight);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Bottom edge intersection test
            intersectingPoint = IntersectionUtils_1.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, bottomRight, bottomLeft);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Left edge intersection test
            intersectingPoint = IntersectionUtils_1.IntersectionUtils.getIntersectingPointOfTwoVectors(sourcePosition, targetPosition, bottomLeft, topLeft);
            if (intersectingPoint !== null) {
                return intersectingPoint;
            }
            // Return the passed target position, if no intersection was found.
            return targetPosition;
        }
        addPaddingToArrowObject(sourcePosition, targetPosition, paddingInTx) {
            // Get normalized direction vector towards target position.
            let v = new Vector2_8.Vector2(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            v.normalize();
            // Add padding to source position
            sourcePosition.x = sourcePosition.x + v.getX() * paddingInTx;
            sourcePosition.y = sourcePosition.y + v.getY() * paddingInTx;
            // Add padding to target position
            targetPosition.x = targetPosition.x - v.getX() * paddingInTx;
            targetPosition.y = targetPosition.y - v.getY() * paddingInTx;
        }
        // Name
        // @Override
        getName() {
            return this.device.getName();
        }
        // Popup info
        // @Override
        getPopupInfo() {
            return this.device.getPopupInfo();
        }
        // Moving
        // @Override
        onMoveStarted(x, y) {
            this.tagModel.valid = true;
            let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
            let viewPositionInTx = this.referencePositionView.position;
            this.movingPointInLocalTx = new PIXI.Point(mouseInTx.x - viewPositionInTx.x, mouseInTx.y - viewPositionInTx.y);
        }
        // @Override
        onMoveChanged(x, y) {
            let mouseInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
            let xInTx = mouseInTx.x - this.movingPointInLocalTx.x;
            let yInTx = mouseInTx.y - this.movingPointInLocalTx.y;
            this.updateModelPositionFromViewPosition(xInTx, yInTx);
        }
        // @Override
        onMoveStopped(x, y) {
            this.onMoveChanged(x, y);
        }
        updateModelPositionFromViewPosition(xInTx, yInTx) {
            this.tagModel.x = xInTx / this.getFloorplanLayer().getFloorSize().x;
            this.tagModel.y = yInTx / this.getFloorplanLayer().getFloorSize().y;
            this.invalidated = true;
        }
        // Getters and setters
        getDevice() {
            return this.device;
        }
    };
    // Constants
    DeviceTag.REFERENCE_POSITION_COLOR = 0x5555ff;
    DeviceTag.ESTIMATED_POSITION_COLOR = 0x5555ff;
    DeviceTag.REFERENCE_POSITION_ALPHA = 0.5;
    DeviceTag.ESTIMATED_POSITION_ALPHA = 1.0;
    DeviceTag.PADDING_IN_PX = DeviceUtils_10.DeviceUtils.getPhysicalPixelsFromLogical(3);
    DeviceTag.LINE_WIDTH_IN_PX = DeviceUtils_10.DeviceUtils.getPhysicalPixelsFromLogical(1);
    DeviceTag = DeviceTag_1 = __decorate([
        RelutionMapObject_10.RelutionModelBinding(DeviceTagModel_1.DeviceTagModel)
    ], DeviceTag);
    exports.DeviceTag = DeviceTag;
});
define("src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTag", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/model/device/DeviceTagModel"], function (require, exports, DeviceTag_2, Asset_4, RelutionMapObjectLayer_3, DeviceTagModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * <h1> A layer that manages the tags of a device.</h1>
     *
     * <p>
     * This class inherits the {@link RelutionMapObjectLayer} base class, as device tags
     * can be moved, selected and hovered independently from the depending devices.
     * However, since device tags existentially depend on devices, the tags' life time
     * is coupled to the corresponding devices. Hence, a device tag is also a Relution map
     * attribute object depending on a device.
     * </p>
     */
    let DeviceTaggingLayer = class DeviceTaggingLayer extends RelutionMapObjectLayer_3.RelutionMapObjectLayer {
        // Construction
        constructor(config, environment, deviceLayer) {
            super(config, environment, deviceLayer.getFloorplanLayer(), deviceLayer);
            this.setModelFactory((parentModel) => {
                let device = deviceLayer.getDeviceWithUuid(parentModel.uuid);
                if (device instanceof Asset_4.Asset) {
                    let model = new DeviceTagModel_2.DeviceTagModel();
                    model.deviceId = device.getModel().deviceId;
                    return model;
                }
                else {
                    return null;
                }
            });
            this.setObjectFactory((model, config) => {
                let device = deviceLayer.getDeviceWithUuid(model.parentUuid);
                if (device !== null) {
                    return new DeviceTag_2.DeviceTag(config, environment, this.getFloorplanLayer(), model, device);
                }
                else {
                    return null;
                }
            });
        }
    };
    DeviceTaggingLayer = __decorate([
        RelutionMapObjectLayer_3.RelutionMapObjectBinding(DeviceTag_2.DeviceTag)
    ], DeviceTaggingLayer);
    exports.DeviceTaggingLayer = DeviceTaggingLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture"], function (require, exports, FloorplanRelatedLayer_8, SpriteObject_12, Texture_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FloorplanOverlayLayer extends FloorplanRelatedLayer_8.FloorplanRelatedLayer {
        // Construction
        constructor(environment, floorplanLayer, name, texture) {
            super(environment, floorplanLayer);
            if (texture !== null && texture !== undefined) {
                this.name = name;
                this.initSprite(texture);
            }
        }
        initSprite(texture) {
            // Add texture to sprite
            this.sprite = new SpriteObject_12.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            texture.baseTexture.mipmap = true;
            this.sprite.texture = new Texture_12.Texture(texture, this.getEnvironment().renderingEnvironment);
            // Scale
            this.sprite.width = this.getFloorplanLayer().getFloorSize().x;
            this.sprite.height = this.getFloorplanLayer().getFloorSize().y;
            // Alpha
            this.sprite.alpha = 0.5;
            // Add sprite to scene graph
            this.getView().addChild(this.sprite);
        }
        // Getters and setters
        getName() {
            return this.name;
        }
    }
    exports.FloorplanOverlayLayer = FloorplanOverlayLayer;
});
define("src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo", ["require", "exports", "src/map/utils/DeviceUtils", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/pixi/HighResText", "src/engine/rendering/utils/Point"], function (require, exports, DeviceUtils_11, RelutionMapAttributeObject_6, HighResTextObject_2, DisplayObjectContainer_14, HighResText_2, Point_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapObjectInfo extends RelutionMapAttributeObject_6.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, mapObject) {
            super(environment, mapObject);
            // View: Updating
            this.invalidated = true;
            this.lastScaleFactor = -1;
            this.lastOrientation = -1;
            this.lastScaleFactorForTranslation = -1;
            this.initModel(mapObject);
            this.initView();
        }
        initModel(mapObject) {
            this.mapObject = mapObject;
            this.mapObject.getModel().addObserver(this);
        }
        initView() {
            this.container = new DisplayObjectContainer_14.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.container);
        }
        // Localization Event-Handling
        // @Override
        initialize() {
            super.initialize();
            this.updateTitle();
        }
        // @Override
        onLocalizationChanged() {
            this.updateTitle();
            return false;
        }
        updateTitle() {
            // Remove old title view
            if (this.titleView != null) {
                this.getView().removeChild(this.titleView);
                this.titleView = null;
            }
            // Create new title view
            let fontSize = DeviceUtils_11.DeviceUtils.getPhysicalPixelsFromLogical(16);
            let style = {
                fill: 0x000000,
                fontFamily: "Arial",
                fontSize: fontSize,
                fontWeight: "normal",
                // strokeThickness: 0.4,
                // stroke: "rgba(240,240,240,1)",
                dropShadow: true,
                dropShadowAlpha: 0.8,
                dropShadowAngle: Math.PI / 6,
                dropShadowBlur: 8,
                dropShadowColor: "#ffffff",
                dropShadowDistance: 0,
            };
            this.titleView = new HighResTextObject_2.HighResTextObject(new HighResText_2.HighResText(1, "", style), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.titleView);
            // Set text
            this.titleView.text = "" + this.mapObject.getName();
            // Pivot
            this.titleView.pivot.x = this.titleView.width / 2;
            this.titleView.pivot.y = this.titleView.height / 2;
            // Redraw
            this.invalidated = true;
        }
        // View
        syncPosition() {
            let worldCamera = this.getScene().getCamera();
            let objectBoundsInImage = this.mapObject.getAabbInImageCoordinates();
            let textBounds = this.titleView.pixi().getBounds();
            let textPositionInImage = new PIXI.Point(objectBoundsInImage.min.x + (objectBoundsInImage.max.x - objectBoundsInImage.min.x) / 2, objectBoundsInImage.min.y - textBounds.height);
            let textPositionInWorld = worldCamera.getWorldCoordinateFromImagePoint(textPositionInImage);
            this.titleView.position = new Point_4.Point(textPositionInWorld, this.getEnvironment().renderingEnvironment);
        }
        // Model Event-Handling
        // @Override
        xChanged(model) {
            this.syncPosition();
        }
        // @Override
        yChanged(model) {
            this.syncPosition();
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                this.updateScale();
                this.updateRotation();
                this.updateTranslation();
                this.invalidated = false;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.titleView.setScaleX(scaleFactor);
                this.titleView.setScaleY(scaleFactor);
            }
        }
        updateRotation() {
            let camera = this.getScene().getCamera();
            let mapObjectOrientation = camera.getRotation();
            if (this.lastOrientation !== mapObjectOrientation || this.invalidated) {
                this.lastOrientation = mapObjectOrientation;
                this.titleView.rotation = mapObjectOrientation;
                this.syncPosition();
            }
        }
        updateTranslation() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                this.syncPosition();
            }
        }
        // Getters and setters
        getRelutionMapObject() {
            return this.mapObject;
        }
    }
    exports.RelutionMapObjectInfo = RelutionMapObjectInfo;
});
define("src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/map/utils/DeviceUtils", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo"], function (require, exports, Layer_4, RelutionMapAttributeObjectLayer_5, DeviceUtils_12, RelutionMapObjectInfo_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapObjectInfoLayer extends RelutionMapAttributeObjectLayer_5.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(config, environment, mapObjectLayer) {
            super(environment, mapObjectLayer);
            this.config = config;
            this.initInfoContainerLayer();
            // We want all map attribute objects to be added to the container,
            // to have better control over attribute objects' visibility.
            this.setTargetLayer(this.infoContainerLayer);
        }
        initInfoContainerLayer() {
            this.infoContainerLayer = new Layer_4.Layer(this.getEnvironment());
            this.addChild(this.infoContainerLayer);
            this.infoContainerLayer.getView().alpha = 0;
        }
        // Life cycle management
        // @Override
        onObjectsUnloaded(objects) {
            super.onObjectsUnloaded(objects);
            // We set the hovering object to null, as it has been removed from the scene
            // and has been destroyed already.
            this.hoveringInfo = null;
        }
        // Attribute object creation
        // @Override
        createAttributeObjectsForObject(mapObject) {
            let objects = [];
            let info = new RelutionMapObjectInfo_1.RelutionMapObjectInfo(this.getEnvironment(), mapObject);
            objects.push(info);
            return objects;
        }
        // Input Event-Handling: Desktop
        // @Override
        onMouseMove(x, y) {
            if (this.config.showInfoOnMouseOver) {
                this.showOrHideInfo(x, y);
            }
            return false;
        }
        // Input Event-Handling: Mobile
        // @Override
        onTap(x, y, numTaps) {
            if (this.config.showInfoOnTapOnMobileDevices) {
                if (DeviceUtils_12.DeviceUtils.isMobileDevice() && numTaps === 1) {
                    return this.showOrHideInfo(x, y);
                }
            }
            return false;
        }
        // Input Event-Handling: General
        showOrHideInfo(x, y) {
            let infoOfCollidingObject = this.getInfoOfCollidingObject(x, y);
            if (infoOfCollidingObject != null) {
                this.setInfoVisible(infoOfCollidingObject);
                return true;
            }
            else {
                this.setInfoVisible(null);
                return false;
            }
        }
        getInfoOfCollidingObject(x, y) {
            for (let i = 0; i < this.getAttributeObjects().length; i++) {
                let info = this.getAttributeObjects()[i];
                let mapObject = info.getRelutionMapObject();
                if (mapObject.intersectsPointInScreenPx(x, y)) {
                    return info;
                }
            }
            return null;
        }
        setInfoVisible(info) {
            // If another object is currently hovered, move it back to the container layer.
            if (this.hoveringInfo != null) {
                this.infoContainerLayer.addChild(this.hoveringInfo);
                this.hoveringInfo = null;
            }
            if (info != null) {
                // Set the new info appear.
                this.hoveringInfo = info;
                this.addChild(info);
            }
        }
        // Modes
        setAllInfosVisible(visible) {
            if (visible) {
                this.infoContainerLayer.getView().alpha = 1.0;
            }
            else {
                this.infoContainerLayer.getView().alpha = 0.0;
            }
        }
        // Getters and setters
        getInfoContainerLayer() {
            return this.infoContainerLayer;
        }
    }
    exports.RelutionMapObjectInfoLayer = RelutionMapObjectInfoLayer;
    (function (RelutionMapObjectInfoLayer) {
        class Config {
            constructor() {
                /**
                 * If true, the map object infos will be shown, whenever
                 * the mouse cursor hovers a map object.
                 *
                 * Default: false
                 */
                this.showInfoOnMouseOver = false;
                /**
                 * True, if an info should appear, whenever the user
                 * taps on the map object.
                 *
                 * Default: false
                 */
                this.showInfoOnTapOnMobileDevices = false;
            }
        }
        RelutionMapObjectInfoLayer.Config = Config;
    })(RelutionMapObjectInfoLayer = exports.RelutionMapObjectInfoLayer || (exports.RelutionMapObjectInfoLayer = {}));
});
/**
 * (c) Michael Zelensky 2015
 *
 * DESCRIPTION
 *
 * Ctrl, Shift, Alt, Cmd buttons detector for Mac
 * to support corresponding event.ctrlKey, event.shiftKey, event.altKey which do not work on Mac
 *
 * LICENSE
 *
 * Distributed under MIT License
 * You can use this code in your project without limitation, no matter if it is commercial or not,
 * with all copyright marks intact
 *
 * USAGE
 *
 * Just include this code into your JS or HTML and then check if key is pressed in your code, e.g.:
 *
 * window.onclick = function (event) {
 *     if (event.ctrlKey || macKeys.ctrlKey) {
 *         //do something
 *     }
 * }
 *
 */
define("src/engine/input/MacKeyDetector", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* tslint:disable */
    class MacKeyDetector {
        static enable() {
            (function () {
                let saywho;
                let isMac;
                let webkit;
                let mozilla;
                let opera;
                let kC;
                isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
                window.macKeys = {
                    cmdKey: false,
                    ctrlKey: false,
                    shiftKey: false,
                    altKey: false,
                    reset: function () {
                        this.cmdKey = false;
                        this.ctrlKey = false;
                        this.shiftKey = false;
                        this.altKey = false;
                    },
                };
                if (isMac) {
                    // browser detection, originates from: http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
                    saywho = (function () {
                        let ua = navigator.userAgent;
                        let tem;
                        let M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
                        if (/trident/i.test(M[1])) {
                            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
                            return { browser: "IE", version: (tem[1] || "") };
                        }
                        if (M[1] === "Chrome") {
                            tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
                            // if(tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
                            if (tem != null) {
                                return { browser: tem.slice(1)[0].replace("OPR", "Opera"), version: tem.slice(1)[1] };
                            }
                        }
                        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, "-?"];
                        if ((tem = ua.match(/version\/(\d+)/i)) != null) {
                            M.splice(1, 1, tem[1]);
                        }
                        return { browser: M[0], version: M[1] };
                    })();
                    webkit = (saywho.browser === "Chrome" || saywho.browser === "Safari");
                    mozilla = saywho.browser === "Firefox";
                    opera = saywho.browser === "Opera";
                    window.onkeydown = function (e) {
                        kC = e.keyCode;
                        if (((webkit || opera) && (kC === 91 || kC === 93)) || (mozilla && kC === 224)) {
                            window.macKeys.cmdKey = true;
                        }
                        else if (kC === 16) {
                            window.macKeys.shiftKey = true;
                        }
                        else if (kC === 17) {
                            window.macKeys.ctrlKey = true;
                        }
                        else if (kC === 18) {
                            window.macKeys.altKey = true;
                        }
                    };
                    window.onkeyup = function (e) {
                        kC = e.keyCode;
                        if (((webkit || opera) && (kC === 91 || kC === 93)) || (mozilla && kC === 224)) {
                            window.macKeys.cmdKey = false;
                        }
                        else if (kC === 16) {
                            window.macKeys.shiftKey = false;
                        }
                        else if (kC === 17) {
                            window.macKeys.ctrlKey = false;
                        }
                        else if (kC === 18) {
                            window.macKeys.altKey = false;
                        }
                    };
                    window.onblur = function () {
                        window.macKeys.reset();
                    };
                }
            })();
        }
    }
    exports.MacKeyDetector = MacKeyDetector;
});
define("src/engine/input/GestureRecognizer", ["require", "exports", "src/engine/input/MacKeyDetector"], function (require, exports, MacKeyDetector_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GestureRecognizer {
        // Initialization
        constructor(interactionView, htmlCanvasElement) {
            this.touchStartTimestampInMs = 0;
            this.touchEndTimestampInMs = 0;
            this.numberOfTaps = 0;
            this.waitingForTapFinish = false;
            // Pinch
            this.pinchFocusX = 0;
            this.pinchFocusY = 0;
            // Mouse click
            this.mouseDown = false;
            this.mouseX = 0;
            this.mouseY = 0;
            this.mouseMoving = false;
            this.lastMouseMoveTimestampInMs = 0;
            // Mouse outside
            this.mouseOutside = true;
            this.mouseOutTimestamp = 0;
            // Mouse wheel
            this.lastWheelEventTimestamp = -1;
            this.lastWheelEventDelta = 1;
            // Low-Level callbacks
            this.onMouseInCallbacks = new Array();
            this.onMouseOutCallbacks = new Array();
            this.onMouseStartedCallbacks = new Array();
            this.onMouseMovedCallbacks = new Array();
            this.onMouseStoppedCallbacks = new Array();
            this.onTouchStartedCallbacks = new Array();
            this.onTouchMovedCallbacks = new Array();
            this.onTouchEndCallbacks = new Array();
            this.onKeyDownCallbacks = new Array();
            this.onKeyUpCallbacks = new Array();
            this.onMouseWheelCallbacks = new Array();
            // High-Level callbacks
            this.onPanningStartedCallbacks = new Array();
            this.onPanningMoveCallbacks = new Array();
            this.onPanningEndCallbacks = new Array();
            this.onPinchingStartedCallbacks = new Array();
            this.onPinchingMoveCallbacks = new Array();
            this.onPinchingEndCallbacks = new Array();
            this.onRotatingStartedCallbacks = new Array();
            this.onRotatingMoveCallbacks = new Array();
            this.onRotatingEndCallbacks = new Array();
            this.onTapCallbacks = new Array();
            this.interactionView = interactionView;
            this.htmlCanvasElement = htmlCanvasElement;
            this.currentTouches = new Array();
            this.lastTouches = new Array();
            this.gestureState = GestureRecognizer.GestureState.NONE;
            this.enableMacKeyDetection();
            this.registerInteraction();
        }
        enableMacKeyDetection() {
            MacKeyDetector_1.MacKeyDetector.enable();
        }
        // Event-Listener registration
        registerInteraction() {
            this.registerMouseDown();
            this.registerMouseMove();
            this.registerMouseUp();
            this.registerMouseUpOutside();
            this.registerMouseWheel();
            this.registerKeyboardDownEvent();
            this.registerKeyboardUpEvent();
            this.registerOnBlurEvent();
            this.registerTouchStart();
            this.registerTouchMove();
            this.registerTouchEnd();
            this.registerTouchEndOutside();
        }
        registerMouseDown() {
            this.interactionView.pixi().on("mousedown", (event) => {
                this.clearSelectionInDom();
                this.mouseDown = true;
                this.handleTouchStart(event);
                this.updateKeyState(event.data.originalEvent);
            }, this);
        }
        clearSelectionInDom() {
            if (document.selection) {
                document.selection.empty();
            }
            else if (window.getSelection) {
                window.getSelection().removeAllRanges();
            }
        }
        registerMouseMove() {
            this.interactionView.pixi().on("mousemove", (event) => {
                this.mouseX = event.data.getLocalPosition(this.interactionView.pixi()).x;
                this.mouseY = event.data.getLocalPosition(this.interactionView.pixi()).y;
                if (this.mouseOutside) {
                    let nowInMs = Date.now();
                    if (this.mouseInsideInteractionView(this.mouseX, this.mouseY)
                        && (nowInMs - this.mouseOutTimestamp) > GestureRecognizer.MIN_TIME_BETWEEN_MOUSEOUT_AND_MOUSEIN) {
                        this.mouseOutside = false;
                        this.handleMouseIn(event);
                    }
                }
                if (this.mouseDown === true) {
                    this.handleTouchMove(event);
                }
                else {
                    this.handleMouseMove(event);
                }
                this.updateKeyState(event.data.originalEvent);
            }, this);
        }
        mouseInsideInteractionView(x, y) {
            let minX = this.interactionView.x;
            let minY = this.interactionView.y;
            let maxX = this.interactionView.x + this.interactionView.width;
            let maxY = this.interactionView.x + this.interactionView.height;
            return x >= minX && x <= maxX &&
                y >= minX && y <= maxY;
        }
        registerMouseUp() {
            this.interactionView.pixi().on("mouseup", (event) => {
                if (this.mouseDown === true) {
                    this.mouseDown = false;
                    this.handleTouchEnd(event);
                }
                this.updateKeyState(event.data.originalEvent);
            }, this);
        }
        registerMouseUpOutside() {
            this.interactionView.pixi().on("mouseout", (event) => {
                if (this.mouseDown === true) {
                    this.mouseDown = false;
                    this.handleTouchEnd(event);
                }
                this.mouseOutside = true;
                this.mouseOutTimestamp = Date.now();
                this.handleMouseOut(event);
                this.updateKeyState(event.data.originalEvent);
            }, this);
        }
        registerMouseWheel() {
            let that = this;
            let handleMouseWheelEvent = (e) => {
                that.handleMouseWheel(e);
                that.updateKeyState(e);
            };
            let item = this.htmlCanvasElement;
            if (item.addEventListener) {
                // IE9, Chrome, Safari, Opera
                item.addEventListener("mousewheel", handleMouseWheelEvent, false);
                // Firefox
                item.addEventListener("DOMMouseScroll", handleMouseWheelEvent, false);
            }
            else {
                // IE 6/7/8
                item.attachEvent("onmousewheel", handleMouseWheelEvent);
            }
        }
        registerKeyboardDownEvent() {
            let that = this;
            window.addEventListener("keydown", (key) => {
                // Do not handle the key event, if a text field or something else has the focus.
                if (document.activeElement === window.document.body) {
                    that.handleKeyDownEvent(key);
                    that.updateKeyState(key);
                }
            }, false);
        }
        registerKeyboardUpEvent() {
            let that = this;
            window.addEventListener("keyup", (key) => {
                // Do not handle the key event, if a text field or something else has the focus.
                if (document.activeElement === window.document.body) {
                    that.handleKeyUpEvent(key);
                    that.updateKeyState(key);
                }
            }, false);
        }
        registerOnBlurEvent() {
            let that = this;
            window.onblur = () => {
                that.updateKeyState(null);
            };
        }
        registerTouchStart() {
            this.interactionView.pixi().on("touchstart", (event) => {
                this.handleTouchStart(event);
            }, this);
        }
        registerTouchMove() {
            this.interactionView.pixi().on("touchmove", (event) => {
                this.handleTouchMove(event);
            }, this);
        }
        registerTouchEnd() {
            this.interactionView.pixi().on("touchend", (event) => {
                this.handleTouchEnd(event);
            }, this);
        }
        registerTouchEndOutside() {
            this.interactionView.pixi().on("touchendoutside", (event) => {
                this.handleTouchEnd(event);
            }, this);
        }
        // Handling Events
        handleMouseIn(event) {
            let position = event.data.getLocalPosition(this.interactionView.pixi());
            // Call mouse in callback
            this.onMouseIn(position.x, position.y);
        }
        handleMouseMove(event) {
            let position = event.data.getLocalPosition(this.interactionView.pixi());
            if (!this.mouseMoving) {
                this.mouseMoving = true;
                // Call start callback
                this.onMouseStarted(position.x, position.y);
            }
            // Call move callback
            this.lastMouseMoveTimestampInMs = Date.now();
            this.currentMouseMoveEvent = { position: event.data.getLocalPosition(this.interactionView.pixi()) };
            GestureRecognizer.mousePositionX = event.data.getLocalPosition(this.interactionView.pixi()).x;
            GestureRecognizer.mousePositionY = event.data.getLocalPosition(this.interactionView.pixi()).y;
            this.onMouseMoved(position.x, position.y);
        }
        handleMouseOut(event) {
            let position = event.data.getLocalPosition(this.interactionView.pixi());
            // Call mouse out callback
            this.onMouseOut(position.x, position.y);
        }
        handleTouchStart(event) {
            // Init current and last touches
            let currentTouch = { identifier: event.data.identifier, position: event.data.getLocalPosition(this.interactionView.pixi()) };
            let lastTouch = { identifier: event.data.identifier, position: event.data.getLocalPosition(this.interactionView.pixi()) };
            this.currentTouches.push(currentTouch);
            this.lastTouches.push(lastTouch);
            // Call callback
            this.onTouchStart(event);
        }
        handleTouchMove(event) {
            // Update current touches
            for (let i = 0; i < this.currentTouches.length; i++) {
                let currentTouch = this.currentTouches[i];
                if (currentTouch.identifier === event.data.identifier) {
                    this.currentTouches[i].position = event.data.getLocalPosition(this.interactionView.pixi());
                    GestureRecognizer.mousePositionX = event.data.getLocalPosition(this.interactionView.pixi()).x;
                    GestureRecognizer.mousePositionY = event.data.getLocalPosition(this.interactionView.pixi()).y;
                }
            }
            // Call callback
            this.onTouchMove(event);
            // Update last position
            for (let i = 0; i < this.currentTouches.length; i++) {
                let currentTouch = this.currentTouches[i];
                if (currentTouch.identifier === event.data.identifier) {
                    this.lastTouches[i].position = currentTouch.position;
                }
            }
        }
        handleTouchEnd(event) {
            // Call callback
            this.onTouchEnd(event);
            // Remove current and last touches
            for (let i = 0; i < this.currentTouches.length; i++) {
                if (this.currentTouches[i].identifier === event.data.identifier) {
                    this.currentTouches.splice(i, 1);
                    this.lastTouches.splice(i, 1);
                }
            }
        }
        handleMouseWheel(e) {
            // Cross-browser wheel delta
            e = window.event || e; // old IE support
            let delta = this.getNormalizedMouseWheelDelta(e);
            if (this.tooManyMouseWheelEvents() || this.mouseWheelDeltaChangedTooQuickly(e, delta)) {
                // On some trackpads a pinch end always produces
                // a wheel delta inversely to the last one, leading
                // to an ugly "reverse zoom jump". To fix this,
                // we disallow quick delta changes.
                this.lastWheelEventTimestamp = Date.now();
                this.lastWheelEventDelta = delta;
                return false;
            }
            this.lastWheelEventTimestamp = Date.now();
            this.lastWheelEventDelta = delta;
            let mousePosition = new PIXI.Point(this.mouseX, this.mouseY);
            this.onMouseWheel(delta, mousePosition.x, mousePosition.y);
            return false;
        }
        /**
         * Returns the mouse wheel delta in range [0,1]
         * @param e mouse wheel event
         */
        getNormalizedMouseWheelDelta(e) {
            let d = e.detail;
            let w = e.wheelDelta;
            let n = 225;
            let n1 = n - 1;
            let f = 0;
            // Normalize delta
            d = d ? w && (f = w / d) ? d / f : -d / 1.35 : w / 120;
            // Quadratic scale if |d| > 1
            d = d < 1 ? d < -1 ? (-Math.pow(d, 2) - n1) / n : d : (Math.pow(d, 2) + n1) / n;
            // Delta *should* not be greater than 2...
            let delta = Math.min(Math.max(d / 2, -1), 1);
            return delta;
        }
        tooManyMouseWheelEvents() {
            return (Date.now() - this.lastWheelEventTimestamp) < 9;
        }
        mouseWheelDeltaChangedTooQuickly(e, delta) {
            return (Date.now() - this.lastWheelEventTimestamp) < 200 &&
                (this.lastWheelEventDelta > 0 && delta <= 0 || this.lastWheelEventDelta <= 0 && delta > 0);
        }
        handleKeyDownEvent(keyboardEvent) {
            // Call callback
            this.onKeyDown(keyboardEvent.keyCode);
        }
        handleKeyUpEvent(keyboardEvent) {
            // Call callback
            this.onKeyUp(keyboardEvent.keyCode);
        }
        onTouchStart(event) {
            // We ignore touch start, because we cannot distinguish
            // gestures without having access to recent touch positions.
            this.touchStartTimestampInMs = Date.now();
            this.touchStartEvent = { identifier: event.data.identifier, position: event.data.getLocalPosition(this.interactionView.pixi()) };
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchStarted(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        onTouchMove(event) {
            // If this touch is definitely no tap, recognize other touch related gestures.
            if (!this.touchCanBeTap(event)) {
                this.handleNonTapTouchMoveEvent(event);
            }
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchMoved(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        touchCanBeTap(event) {
            let gestureStateIsNone = this.gestureState === GestureRecognizer.GestureState.NONE;
            let onlyOneTapActive = this.currentTouches.length === 1;
            let distance = Math.sqrt((Math.pow(this.currentTouches[0].position.x - this.touchStartEvent.position.x, 2)) +
                (Math.pow(this.currentTouches[0].position.y - this.touchStartEvent.position.y, 2)));
            let shortDistanceToTouchStart = distance < GestureRecognizer.MAX_TAP_DISTANCE_PX;
            let shortTimeSinceTouchStart = (Date.now() - this.touchStartTimestampInMs) < GestureRecognizer.MAX_TAP_DURATION_MS;
            return gestureStateIsNone && onlyOneTapActive && shortDistanceToTouchStart && shortTimeSinceTouchStart;
        }
        handleNonTapTouchMoveEvent(event) {
            // Gesture state machine
            if (this.gestureState === GestureRecognizer.GestureState.NONE) {
                if (this.recognizedPinchEvent(event)) {
                    this.gestureState = GestureRecognizer.GestureState.PINCHING;
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingStarted(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedRotateEvent(event)) {
                    this.gestureState = GestureRecognizer.GestureState.ROTATING;
                    let rotation = this.getRotation();
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingStarted(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedPanEvent(event)) {
                    this.gestureState = GestureRecognizer.GestureState.PANNING;
                    let x = this.currentTouches[0].position.x;
                    let y = this.currentTouches[0].position.y;
                    this.onPanningStarted(x, y);
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                if (this.recognizedPinchEvent(event)) {
                    this.gestureState = GestureRecognizer.GestureState.PINCHING;
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingStarted(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                }
                else if (this.recognizedRotateEvent(event)) {
                    this.gestureState = GestureRecognizer.GestureState.ROTATING;
                    let rotation = this.getRotation();
                    this.computePinchFocus();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingStarted(rotation, this.pinchFocusX, this.pinchFocusX, distance, scaleFactor);
                }
            }
            // Update gesture
            if (this.gestureState === GestureRecognizer.GestureState.PINCHING) {
                let distance = this.getPinchDistance();
                let scaleFactor = this.getScaleFactor();
                this.onPinchingMove(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
            }
            else if (this.gestureState === GestureRecognizer.GestureState.ROTATING) {
                let rotation = this.getRotation();
                let distance = this.getPinchDistance();
                let scaleFactor = this.getScaleFactor();
                this.onRotatingMove(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                let x = this.currentTouches[0].position.x;
                let y = this.currentTouches[0].position.y;
                this.onPanningMove(x, y);
            }
        }
        recognizedPinchEvent(event) {
            // At least two fingers
            if (this.currentTouches.length < 2) {
                return false;
            }
            let directionRatio = this.getDirectionRatio();
            let movementVector = this.getMovementVector();
            let movementVectorLength = Math.sqrt(movementVector.x * movementVector.x + movementVector.y * movementVector.y);
            return directionRatio > (GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD)
                && movementVectorLength > GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD;
        }
        computePinchFocus() {
            let pinchFocus = this.getPinchFocus();
            this.pinchFocusX = pinchFocus.x;
            this.pinchFocusY = pinchFocus.y;
        }
        getPinchFocus() {
            let focusX = (this.currentTouches[0].position.x + this.currentTouches[1].position.x) / 2;
            let focusY = (this.currentTouches[0].position.y + this.currentTouches[1].position.y) / 2;
            return new PIXI.Point(focusX, focusY);
        }
        getPinchDistance() {
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Distance
            let distance = Math.sqrt(Math.pow(currentDistanceVectorX, 2) + Math.pow(currentDistanceVectorY, 2));
            return distance;
        }
        getScaleFactor() {
            // Current distance
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            let currentDistance = Math.sqrt(Math.pow(currentDistanceVectorX, 2) + Math.pow(currentDistanceVectorY, 2));
            // Last distance
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            let lastDistance = Math.sqrt(Math.pow(lastDistanceVectorX, 2) + Math.pow(lastDistanceVectorY, 2));
            // Scale factor
            let scaleFactor = currentDistance / lastDistance;
            return scaleFactor;
        }
        recognizedRotateEvent(event) {
            // At least two fingers
            if (this.currentTouches.length < 2) {
                return false;
            }
            // The difference between pinching and rotating must be big enough.
            // Moreover, the moving distance must exceed a threshold.
            let directionRatio = this.getDirectionRatio();
            let movementVector = this.getMovementVector();
            let movementVectorLength = Math.sqrt(movementVector.x * movementVector.x + movementVector.y * movementVector.y);
            return directionRatio < (1.0 / GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD)
                && movementVectorLength > GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD;
        }
        getRotation() {
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            let currentDistanceVectorLength = Math.sqrt(currentDistanceVectorX * currentDistanceVectorX + currentDistanceVectorY * currentDistanceVectorY);
            let lastDistanceVectorLength = Math.sqrt(lastDistanceVectorX * lastDistanceVectorX + lastDistanceVectorY * lastDistanceVectorY);
            let numerator = currentDistanceVectorX * lastDistanceVectorX + currentDistanceVectorY * lastDistanceVectorY;
            let denominator = Math.abs(currentDistanceVectorLength) * Math.abs(lastDistanceVectorLength);
            // Rotation
            let rotation = Math.acos(numerator / denominator);
            if (isNaN(rotation)) {
                rotation = 0;
            }
            // Sign
            let crossProduct = currentDistanceVectorX * lastDistanceVectorY - currentDistanceVectorY * lastDistanceVectorX;
            if (crossProduct > 0) {
                rotation = -rotation;
            }
            return rotation;
        }
        getDirectionRatio() {
            // If the movement vector's projection to the circle is greater
            // than the projection to the finger distance vector, we assume
            // this touch gesture to be a rotation.
            let movementVector = this.getMovementVector();
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Project movement vector to current distance vector
            let distanceVectorProjection = Math.abs(movementVector.x * currentDistanceVectorX + movementVector.y * currentDistanceVectorY);
            // Project movement vector to the normal vector of the current distance vector
            let perpendicularCurrentDistanceVectorX = -currentDistanceVectorY;
            let perpendicularCurrentDistanceVectorY = currentDistanceVectorX;
            let perpendicularDistanceVectorProjection = Math.abs(movementVector.x * perpendicularCurrentDistanceVectorX
                + movementVector.y * perpendicularCurrentDistanceVectorY);
            return distanceVectorProjection / perpendicularDistanceVectorProjection;
        }
        getMovementVector() {
            // Current distance vector
            let currentDistanceVectorX = this.currentTouches[0].position.x - this.currentTouches[1].position.x;
            let currentDistanceVectorY = this.currentTouches[0].position.y - this.currentTouches[1].position.y;
            // Last distance vector
            let lastDistanceVectorX = this.lastTouches[0].position.x - this.lastTouches[1].position.x;
            let lastDistanceVectorY = this.lastTouches[0].position.y - this.lastTouches[1].position.y;
            // Movement vector
            let movementVectorX = currentDistanceVectorX - lastDistanceVectorX;
            let movementVectorY = currentDistanceVectorY - lastDistanceVectorY;
            return new PIXI.Point(movementVectorX, movementVectorY);
        }
        recognizedPanEvent(event) {
            return this.currentTouches.length === 1;
        }
        onTouchEnd(event) {
            // If this touch is definitely no tap, recognize other touch related gestures.
            if (this.touchCanBeTap(event)) {
                this.handleTapTouchEndEvent(event);
            }
            else {
                this.handleNonTapTouchEndEvent(event);
            }
            // Call callback
            let lastTouchIndex = this.currentTouches.length - 1;
            this.onTouchEnded(this.currentTouches[lastTouchIndex].position.x, this.currentTouches[lastTouchIndex].position.y, this.currentTouches[lastTouchIndex].identifier);
        }
        handleTapTouchEndEvent(event) {
            // If no other touch event will be recognized within "touch timeout"" milliseconds,
            // the touch gesture will be considered as "completed".
            this.numberOfTaps++;
            this.touchEndTimestampInMs = Date.now();
            this.waitingForTapFinish = true;
        }
        handleNonTapTouchEndEvent(event) {
            // Stop gesture
            if (this.gestureState === GestureRecognizer.GestureState.PINCHING) {
                if (this.currentTouches.length === 2) {
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onPinchingEnd(this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.ROTATING) {
                if (this.currentTouches.length === 2) {
                    let rotation = this.getRotation();
                    let distance = this.getPinchDistance();
                    let scaleFactor = this.getScaleFactor();
                    this.onRotatingEnd(rotation, this.pinchFocusX, this.pinchFocusY, distance, scaleFactor);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
            else if (this.gestureState === GestureRecognizer.GestureState.PANNING) {
                if (this.currentTouches.length === 1) {
                    let x = this.currentTouches[0].position.x;
                    let y = this.currentTouches[0].position.y;
                    this.onPanningEnd(x, y);
                    this.gestureState = GestureRecognizer.GestureState.NONE;
                }
            }
        }
        //// CALLBACKS
        /// LOW LEVEL EVENTS
        onMouseIn(x, y) {
            for (let i = 0; i < this.onMouseInCallbacks.length; i++) {
                let callback = this.onMouseInCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseOut(x, y) {
            for (let i = 0; i < this.onMouseOutCallbacks.length; i++) {
                let callback = this.onMouseOutCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseStarted(x, y) {
            for (let i = 0; i < this.onMouseStartedCallbacks.length; i++) {
                let callback = this.onMouseStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseMoved(x, y) {
            for (let i = 0; i < this.onMouseMovedCallbacks.length; i++) {
                let callback = this.onMouseMovedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onMouseStopped(x, y) {
            for (let i = 0; i < this.onMouseStoppedCallbacks.length; i++) {
                let callback = this.onMouseStoppedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onTouchStarted(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchStartedCallbacks.length; i++) {
                let callback = this.onTouchStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onTouchMoved(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchMovedCallbacks.length; i++) {
                let callback = this.onTouchMovedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onTouchEnded(x, y, touchIndex) {
            for (let i = 0; i < this.onTouchEndCallbacks.length; i++) {
                let callback = this.onTouchEndCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, touchIndex]);
            }
        }
        onKeyDown(keyCode) {
            for (let i = 0; i < this.onKeyDownCallbacks.length; i++) {
                let callback = this.onKeyDownCallbacks[i];
                callback.apply(this.callbackReceiver, [keyCode]);
            }
        }
        onKeyUp(keyCode) {
            for (let i = 0; i < this.onKeyUpCallbacks.length; i++) {
                let callback = this.onKeyUpCallbacks[i];
                callback.apply(this.callbackReceiver, [keyCode]);
            }
        }
        // Called, whenever the mouse wheel is used.
        // delta = -1, on mouse wheel down,
        // delta = 1, on mouse wheel up
        onMouseWheel(delta, mouseX, mouseY) {
            for (let i = 0; i < this.onMouseWheelCallbacks.length; i++) {
                let callback = this.onMouseWheelCallbacks[i];
                callback.apply(this.callbackReceiver, [delta, mouseX, mouseY]);
            }
        }
        /// HIGH-LEVEL EVENTS
        onPanningStarted(x, y) {
            for (let i = 0; i < this.onPanningStartedCallbacks.length; i++) {
                let callback = this.onPanningStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPanningMove(x, y) {
            for (let i = 0; i < this.onPanningMoveCallbacks.length; i++) {
                let callback = this.onPanningMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPanningEnd(x, y) {
            for (let i = 0; i < this.onPanningEndCallbacks.length; i++) {
                let callback = this.onPanningEndCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y]);
            }
        }
        onPinchingStarted(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingStartedCallbacks.length; i++) {
                let callback = this.onPinchingStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingMoveCallbacks.length; i++) {
                let callback = this.onPinchingMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onPinchingEndCallbacks.length; i++) {
                let callback = this.onPinchingEndCallbacks[i];
                callback.apply(this.callbackReceiver, [pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingStarted(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingStartedCallbacks.length; i++) {
                let callback = this.onRotatingStartedCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingMoveCallbacks.length; i++) {
                let callback = this.onRotatingMoveCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            for (let i = 0; i < this.onRotatingEndCallbacks.length; i++) {
                let callback = this.onRotatingEndCallbacks[i];
                callback.apply(this.callbackReceiver, [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor]);
            }
        }
        onTap(x, y, numTaps) {
            for (let i = 0; i < this.onTapCallbacks.length; i++) {
                let callback = this.onTapCallbacks[i];
                callback.apply(this.callbackReceiver, [x, y, numTaps]);
            }
        }
        // Updating
        update() {
            this.updateTapState();
            this.updateMouseState();
        }
        updateKeyState(event) {
            // Updates the current state of the control keys
            if (event == null) {
                GestureRecognizer.ctrlPressed = false;
                GestureRecognizer.shiftPressed = false;
                GestureRecognizer.altPressed = false;
            }
            else {
                GestureRecognizer.ctrlPressed = event.ctrlKey || window.macKeys.cmdKey;
                GestureRecognizer.shiftPressed = event.shiftKey || window.macKeys.shiftKey;
                GestureRecognizer.altPressed = event.altKey || window.macKeys.altKey;
            }
        }
        updateTapState() {
            if (this.waitingForTapFinish) {
                let now = Date.now();
                if (now - this.touchEndTimestampInMs > GestureRecognizer.DELAY_BETWEEN_TAPS_IN_MULTI_TAP_MS
                    || this.numberOfTaps >= GestureRecognizer.MAX_NUMBER_TAPS_IN_MULTI_TAP) {
                    this.onTap(this.touchStartEvent.position.x, this.touchStartEvent.position.y, this.numberOfTaps);
                    this.numberOfTaps = 0;
                    this.waitingForTapFinish = false;
                }
            }
        }
        updateMouseState() {
            if (this.mouseMoving) {
                let now = Date.now();
                if (now - this.lastMouseMoveTimestampInMs > GestureRecognizer.TIME_TO_RECOGNIZE_MOUSE_STOP_IN_MS) {
                    this.onMouseStopped(this.currentMouseMoveEvent.position.x, this.currentMouseMoveEvent.position.y);
                    this.mouseMoving = false;
                }
            }
        }
        // Getters and setters
        getGestureState() {
            return this.gestureState;
        }
        static isCtrlPressed() {
            return this.ctrlPressed;
        }
        static isShiftPressed() {
            return this.shiftPressed;
        }
        static isAltPressed() {
            return this.altPressed;
        }
        static getMousePositionX() {
            return this.mousePositionX;
        }
        static getMousePositionY() {
            return this.mousePositionY;
        }
    }
    // Tap
    GestureRecognizer.MAX_TAP_DURATION_MS = 250;
    GestureRecognizer.MAX_TAP_DISTANCE_PX = 2;
    GestureRecognizer.DELAY_BETWEEN_TAPS_IN_MULTI_TAP_MS = 250;
    GestureRecognizer.MAX_NUMBER_TAPS_IN_MULTI_TAP = 2;
    // Pinch-Rotate
    GestureRecognizer.PINCH_ROTATE_DIFFERENCE_THRESHOLD = 5;
    GestureRecognizer.MOVEMENT_VECTOR_LENGTH_PINCH_ROTATE_THRESHOLD = 2;
    // Mouse move
    GestureRecognizer.TIME_TO_RECOGNIZE_MOUSE_STOP_IN_MS = 300;
    GestureRecognizer.mousePositionX = 0;
    GestureRecognizer.mousePositionY = 0;
    GestureRecognizer.MIN_TIME_BETWEEN_MOUSEOUT_AND_MOUSEIN = 200;
    // Keys
    GestureRecognizer.ctrlPressed = false;
    GestureRecognizer.shiftPressed = false;
    GestureRecognizer.altPressed = false;
    exports.GestureRecognizer = GestureRecognizer;
    (function (GestureRecognizer) {
        let GestureState;
        (function (GestureState) {
            GestureState[GestureState["NONE"] = 0] = "NONE";
            GestureState[GestureState["PINCHING"] = 1] = "PINCHING";
            GestureState[GestureState["ROTATING"] = 2] = "ROTATING";
            GestureState[GestureState["PANNING"] = 3] = "PANNING";
        })(GestureState = GestureRecognizer.GestureState || (GestureRecognizer.GestureState = {}));
    })(GestureRecognizer = exports.GestureRecognizer || (exports.GestureRecognizer = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/engine/rendering/objects/GraphicsObject", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator", "src/engine/math/Vector2", "src/engine/input/GestureRecognizer"], function (require, exports, FloorplanRelatedLayer_9, GraphicsObject_6, Device_3, Animation_8, LinearInterpolator_7, Vector2_9, GestureRecognizer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A layer that makes it possible to set the position of a specified device.
     */
    class SingleDeviceEditLayer extends FloorplanRelatedLayer_9.FloorplanRelatedLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(environment, deviceLayer.getFloorplanLayer());
            // Observers
            this.observers = new Array();
            this.touchStartPoint = null;
            this.invalidated = true;
            this.lastCameraScale = -1;
            this.config = config;
            this.deviceLayer = deviceLayer;
            this.initView();
            this.deviceLayer.addObserver(this);
        }
        initView() {
            this.initBlueDotView();
            this.initTapView();
        }
        initBlueDotView() {
            this.blueDotView = new GraphicsObject_6.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.blueDotView.beginFill(SingleDeviceEditLayer.BLUE_DOT_COLOR);
            this.blueDotView.drawCircle(0, 0, SingleDeviceEditLayer.BLUE_DOT_SIZE_IN_WORLD_TX);
            this.blueDotView.endFill();
            this.blueDotView.visible = false;
            this.blueDotView.alpha = 0.0;
            this.getView().addChild(this.blueDotView);
            this.blueDotAnimation = new Animation_8.Animation(new LinearInterpolator_7.LinearInterpolator());
            this.startBlueDotAnimation();
        }
        startBlueDotAnimation() {
            const startValue = 0.0;
            const endValue = 1.0;
            const durationInMs = 750;
            const delayInMs = 500;
            this.blueDotAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        initTapView() {
            this.tapView = new GraphicsObject_6.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.tapView.beginFill(0x000000);
            this.tapView.drawCircle(0, 0, SingleDeviceEditLayer.TAP_VIEW_RESOLUTION_IN_PX);
            this.tapView.endFill();
            this.tapView.alpha = 0.0;
            this.tapView.scale.x = 1.0;
            this.tapView.scale.y = 1.0;
            this.getView().addChild(this.tapView);
            this.tapViewAnimation = new Animation_8.Animation(new LinearInterpolator_7.LinearInterpolator());
        }
        startTapViewAnimation() {
            // Reset tap view
            if (this.tapViewAnimation.isCurrentlyAnimating()) {
                this.tapViewAnimation.stop();
            }
            // Reset scale
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            this.retransformTapView(scaleFactor);
            // Reset alpha
            this.tapView.alpha = SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA;
            // Start animation
            const startValue = 0.0;
            const endValue = 1.0;
            const durationInMs = 250;
            const delayInMs = 0;
            this.tapViewAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        // Observers
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index > -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObserversAboutPositionChange(device) {
            for (let i = 0; i < this.observers.length; i++) {
                const observer = this.observers[i];
                observer.onDevicePositionChanged(device);
            }
        }
        // Beacon event handling
        onObjectMovedToMap(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectMovedToStock(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectSetToMap(object) {
            this.handleObjectSceneChange(object);
        }
        onObjectSetToStock(object) {
            this.handleObjectSceneChange(object);
        }
        handleObjectSceneChange(object) {
            if (object.getModel().uuid === this.config.editableDeviceUuid) {
                if (object instanceof Device_3.Device) {
                    const device = object;
                    device.getModel().removeObserver(this);
                    this.updateAppearance();
                }
            }
        }
        // Tap event handling
        // @Override
        onTap(x, y, numTaps) {
            super.onTap(x, y, numTaps);
            if (numTaps === 1) {
                if (this.config.enabled) {
                    if (this.config.editableDeviceUuid !== null) {
                        const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
                        if (device !== null) {
                            const deviceModel = device.getModel();
                            const positionInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
                            deviceModel.x = Math.max(Math.min(positionInRelativeCoords.x, 1.0), 0.0);
                            deviceModel.y = Math.max(Math.min(positionInRelativeCoords.y, 1.0), 0.0);
                            this.deviceLayer.moveObjectToMap(device);
                            device.invalidate();
                            this.updateAppearance();
                            this.notifyObserversAboutPositionChange(device);
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        // Touch event handling
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (this.config.enabled) {
                this.touchStartPoint = new PIXI.Point(x, y);
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            return false;
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (this.config.enabled && this.touchStartPoint !== null) {
                const touchPointInScreenPx = new PIXI.Point(x, y);
                const tapViewToleranceInPx = GestureRecognizer_1.GestureRecognizer.MAX_TAP_DISTANCE_PX;
                if (Vector2_9.Vector2.getDistanceBetweenPoints(this.touchStartPoint, new PIXI.Point(x, y)) < tapViewToleranceInPx) {
                    const touchPointInWorldTx = this.getFloorplanLayer().getTexelsFromScreenPixels(touchPointInScreenPx);
                    this.tapView.x = touchPointInWorldTx.x;
                    this.tapView.y = touchPointInWorldTx.y;
                    this.startTapViewAnimation();
                }
                this.touchStartPoint = null;
            }
            return false;
        }
        // Frame events
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                this.updateBlueDotAnimation(lastFrametime);
                this.updateTapViewAnimation(lastFrametime);
                this.updateScale();
                this.invalidated = false;
            }
        }
        updateBlueDotAnimation(lastFrametime) {
            if (this.blueDotAnimation.isCurrentlyAnimating()) {
                const value = this.blueDotAnimation.getValue(lastFrametime);
                const maxAlpha = 0.5;
                this.blueDotView.alpha = maxAlpha - (value * maxAlpha);
                this.blueDotView.scale.x = value;
                this.blueDotView.scale.y = value;
            }
            else {
                this.startBlueDotAnimation();
            }
        }
        updateTapViewAnimation(lastFrametime) {
            if (this.tapViewAnimation.isCurrentlyAnimating()) {
                const value = this.tapViewAnimation.getValue(lastFrametime);
                const maxAlpha = SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA;
                this.tapView.alpha = maxAlpha - (value * maxAlpha);
                this.invalidated = true;
            }
        }
        updateScale() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            if (this.lastCameraScale !== scaleFactor || this.invalidated) {
                this.lastCameraScale = scaleFactor;
                this.retransformTapView(scaleFactor);
            }
        }
        retransformTapView(scaleFactor) {
            const value = this.tapViewAnimation.getLastValue();
            this.tapView.scale.x = (1.0 - value) * scaleFactor;
            this.tapView.scale.y = (1.0 - value) * scaleFactor;
        }
        // Model Event-Handling
        // @Override
        xChanged(deviceModel) {
            if (deviceModel.uuid === this.config.editableDeviceUuid) {
                this.updateAppearance();
            }
        }
        // @Override
        yChanged(deviceModel) {
            if (deviceModel.uuid === this.config.editableDeviceUuid) {
                this.updateAppearance();
            }
        }
        // Appearance
        updateAppearance() {
            if (this.config.enabled && this.config.editableDeviceUuid !== null) {
                if (this.editableDeviceIsOnMap()) {
                    this.highlightEditableDevice();
                }
                this.tapView.visible = true;
            }
            else {
                this.unhighlightEditableDevice();
                this.tapView.visible = false;
            }
        }
        editableDeviceIsOnMap() {
            const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
            if (device !== null) {
                return device.getModel().isOnMap();
            }
            else {
                return false;
            }
        }
        highlightEditableDevice() {
            const device = this.deviceLayer.getDeviceWithUuid(this.config.editableDeviceUuid);
            if (device !== null) {
                this.blueDotView.x = device.getView().x;
                this.blueDotView.y = device.getView().y;
                this.blueDotView.visible = true;
                device.setHighlighted(true);
            }
        }
        unhighlightEditableDevice() {
            this.blueDotView.visible = false;
            const allDevices = this.deviceLayer.getAllDevices();
            for (let i = 0; i < allDevices.length; i++) {
                const device = allDevices[i];
                device.setHighlighted(false);
            }
        }
        // Getters and setters
        setEditModeActive(enabled, editableDeviceUuid) {
            this.config.enabled = enabled;
            this.config.editableDeviceUuid = editableDeviceUuid;
            this.updateAppearance();
        }
        isEditModeActive() {
            return this.config.enabled;
        }
        getEditableDeviceUuid() {
            return this.config.editableDeviceUuid;
        }
    }
    // Constants
    // Constants: Colors
    SingleDeviceEditLayer.BLUE_DOT_COLOR = 0x95b5ff;
    // Constants: Size
    SingleDeviceEditLayer.BLUE_DOT_SIZE_IN_WORLD_TX = 150;
    SingleDeviceEditLayer.TAP_VIEW_RESOLUTION_IN_PX = 20;
    SingleDeviceEditLayer.MAX_TAP_VIEW_ALPHA = 0.1;
    exports.SingleDeviceEditLayer = SingleDeviceEditLayer;
    (function (SingleDeviceEditLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the single device edit layer should be enabled by default
                 *
                 * Default: false
                 */
                this.enabled = false;
                /**
                 * The UUID of the editable device, if the single device edit mode is enabled by default.
                 *
                 * Default: null, as this mode is disabled by default.
                 */
                this.editableDeviceUuid = null;
            }
        }
        SingleDeviceEditLayer.Config = Config;
    })(SingleDeviceEditLayer = exports.SingleDeviceEditLayer || (exports.SingleDeviceEditLayer = {}));
});
define("src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/HighResTextObject", "src/map/utils/DeviceUtils", "src/engine/rendering/pixi/HighResText", "src/engine/rendering/utils/Point", "src/engine/math/Vector2", "src/engine/input/GestureRecognizer", "src/engine/general/AABB"], function (require, exports, FloorplanRelatedLayer_10, GraphicsObject_7, HighResTextObject_3, DeviceUtils_13, HighResText_3, Point_5, Vector2_10, GestureRecognizer_2, AABB_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A layer containing a rectangular tape measure making it possible to measure
     * distances between two points on the floorplan.
     *
     * <p>
     * Creating and modifying the rectangle is only possible in the tape measure
     * edit mode. Creating the tape measure rectangle can be done by tapping on two
     * points on the map subsequently. A third tap will remove the rectangle.
     * Modifying an already created tape measure is possible by dragging the corner
     * points (also called edit points).
     * </p>
     */
    class TapeMeasureWorldLayer extends FloorplanRelatedLayer_10.FloorplanRelatedLayer {
        // Construction
        constructor(config, environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // View: Creating rectangle
            this.isFirstEditPointSet = false;
            this.isSecondEditPointSet = false;
            this.tapStartPoint = null;
            // View: Resizing rectangle
            this.numberOfEditingPoints = 4;
            this.editing = false;
            this.editTouchIndex = -1;
            this.editingMinX = false;
            this.editingMinY = false;
            this.editingMaxX = false;
            this.editingMaxY = false;
            this.editingPoints = Array();
            this.measureTexts = new Array();
            this.axisAlignedMeasureTexts = new Array();
            this.diagonalMeasureText = null;
            // State
            this.invalidated = true;
            this.lastScaleFactor = -1;
            this.config = config;
            this.initModel();
            this.initView();
        }
        initModel() {
            this.model = new TapeMeasureWorldLayer.Model();
        }
        initView() {
            this.initRectangle();
            this.initEditingPoints();
            this.initMeasureTexts();
            this.getView().visible = false;
        }
        initRectangle() {
            this.rectangle = new GraphicsObject_7.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.rectangle);
        }
        initEditingPoints() {
            for (let i = 0; i < this.numberOfEditingPoints; i++) {
                let editingPoint = new GraphicsObject_7.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
                editingPoint.clear();
                editingPoint.beginFill(TapeMeasureWorldLayer.CORNER_COLOR);
                editingPoint.drawCircle(0, 0, 1);
                editingPoint.endFill();
                this.editingPoints.push(editingPoint);
                this.getView().addChild(editingPoint);
            }
        }
        initMeasureTexts() {
            let fontSize = DeviceUtils_13.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let style = {
                fill: TapeMeasureWorldLayer.TEXT_COLOR,
                fontFamily: "Arial",
                fontSize: fontSize,
            };
            // We want the texts only be shown on the top and right site.
            let numberOfMeasureTexts = this.numberOfEditingPoints / 2;
            for (let i = 0; i < numberOfMeasureTexts; i++) {
                const measureText = this.addMeasureText(style);
                this.axisAlignedMeasureTexts.push(measureText);
            }
            this.diagonalMeasureText = this.addMeasureText(style);
        }
        addMeasureText(style) {
            let measureText = new HighResTextObject_3.HighResTextObject(new HighResText_3.HighResText(2, "", style), this.getEnvironment().renderingEnvironment);
            measureText.visible = false;
            this.measureTexts.push(measureText);
            this.getView().addChild(measureText);
            return measureText;
        }
        // Creating and editing the measure rectangle
        // @Override
        onTouchStart(x, y, touchIndex) {
            super.onTouchStart(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    return this.handleTouchStart(x, y, touchIndex);
                }
                else {
                    return false;
                }
            }
        }
        handleTouchStart(x, y, touchIndex) {
            if (this.hasCreatedRectangle() && this.pointIsCloseToEditableArea(x, y)) {
                this.onEditCornerStart(x, y, touchIndex);
                return true;
            }
            else {
                this.tapStartPoint = new PIXI.Point(x, y);
            }
        }
        pointIsCloseToEditableArea(x, y) {
            let mousePosition = new PIXI.Point(x, y);
            let editablePoints = this.getEditablePoints();
            for (let i = 0; i < editablePoints.length; i++) {
                let editablePoint = editablePoints[i];
                let distance = Vector2_10.Vector2.getDistanceBetweenPoints(mousePosition, editablePoint);
                const toleranceInPx = DeviceUtils_13.DeviceUtils.isMobileDevice()
                    ? DeviceUtils_13.DeviceUtils.getPhysicalPixelsFromLogical(TapeMeasureWorldLayer.EDITABLE_POINT_MOBILE_TOLERANCE_IN_PX)
                    : TapeMeasureWorldLayer.EDITABLE_POINT_DESKTOP_TOLERANCE_IN_PX;
                if (distance < toleranceInPx) {
                    return true;
                }
            }
            return false;
        }
        getEditablePoints() {
            let editablePoints = new Array();
            let topLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.model.min.x, this.model.min.y));
            let topRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.model.max.x, this.model.min.y));
            let bottomLeft = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.model.min.x, this.model.max.y));
            let bottomRight = this.getFloorplanLayer().getScreenPixelsFromRelativeCoords(new PIXI.Point(this.model.max.x, this.model.max.y));
            editablePoints.push(topLeft);
            editablePoints.push(topRight);
            editablePoints.push(bottomLeft);
            editablePoints.push(bottomRight);
            return editablePoints;
        }
        onEditCornerStart(x, y, touchIndex) {
            let pointInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
            this.editing = true;
            this.editTouchIndex = touchIndex;
            if (Math.abs(pointInRelative.x - this.model.min.x) < Math.abs(pointInRelative.x - this.model.max.x)) {
                this.editingMinX = true;
                this.editingMaxX = false;
            }
            else {
                this.editingMinX = false;
                this.editingMaxX = true;
            }
            if (Math.abs(pointInRelative.y - this.model.min.y) < Math.abs(pointInRelative.y - this.model.max.y)) {
                this.editingMinY = true;
                this.editingMaxY = false;
            }
            else {
                this.editingMinY = false;
                this.editingMaxY = true;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    this.onEditCornerMove(x, y, touchIndex);
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        onEditCornerMove(x, y, touchIndex) {
            if (this.editTouchIndex === touchIndex) {
                if (this.editing === true) {
                    // Get mouse position in relative coordinates
                    let pointInTx = this.getFloorplanLayer().getTexelsFromScreenPixels(new PIXI.Point(x, y));
                    let pointInRelative = this.getFloorplanLayer().getRelativeCoordinatesFromTexels(pointInTx);
                    // Constrain the mouse to the world borders.
                    pointInRelative.x = Math.max(0, Math.min(1, pointInRelative.x));
                    pointInRelative.y = Math.max(0, Math.min(1, pointInRelative.y));
                    // Model update
                    if (this.editingMinX) {
                        this.model.min.x = pointInRelative.x;
                    }
                    else if (this.editingMaxX) {
                        this.model.max.x = pointInRelative.x;
                    }
                    if (this.editingMinY) {
                        this.model.min.y = pointInRelative.y;
                    }
                    else if (this.editingMaxY) {
                        this.model.max.y = pointInRelative.y;
                    }
                    // Model constraints: Min must always be smaller than max.
                    this.normalizeModel();
                    // View update
                    this.redraw();
                }
            }
        }
        normalizeModel() {
            if (this.model.min.x > this.model.max.x) {
                let helper = this.model.min.x;
                this.model.min.x = this.model.max.x;
                this.model.max.x = helper;
                let helperEditing = this.editingMinX;
                this.editingMinX = this.editingMaxX;
                this.editingMaxX = helperEditing;
            }
            if (this.model.min.y > this.model.max.y) {
                let helper = this.model.min.y;
                this.model.min.y = this.model.max.y;
                this.model.max.y = helper;
                let helperEditing = this.editingMinY;
                this.editingMinY = this.editingMaxY;
                this.editingMaxY = helperEditing;
            }
            this.model.min.x = Math.max(0.0, Math.min(1.0, this.model.min.x));
            this.model.min.y = Math.max(0.0, Math.min(1.0, this.model.min.y));
            this.model.max.x = Math.max(0.0, Math.min(1.0, this.model.max.x));
            this.model.max.y = Math.max(0.0, Math.min(1.0, this.model.max.y));
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            super.onTouchEnd(x, y, touchIndex);
            if (!this.isVisibleInWorld()) {
                return false;
            }
            else {
                if (this.isEditModeActive()) {
                    if (this.editing) {
                        this.onEditCornerStop(x, y, touchIndex);
                    }
                    else {
                        this.handleTapIfDetected(x, y);
                    }
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        onEditCornerStop(x, y, touchIndex) {
            this.editing = false;
            this.editTouchIndex = -1;
        }
        handleTapIfDetected(x, y) {
            if (this.tapStartPoint !== null) {
                const tapViewToleranceInPx = GestureRecognizer_2.GestureRecognizer.MAX_TAP_DISTANCE_PX * 2;
                if (Vector2_10.Vector2.getDistanceBetweenPoints(new PIXI.Point(x, y), this.tapStartPoint) < tapViewToleranceInPx) {
                    this.handleTap(x, y);
                }
                this.tapStartPoint = null;
            }
        }
        handleTap(x, y) {
            if (this.isCreatingRectangle()) {
                this.isSecondEditPointSet = true;
                this.setSecondEditPoint(x, y);
                this.normalizeModel();
            }
            else if (this.hasCreatedRectangle()) {
                this.isFirstEditPointSet = false;
                this.isSecondEditPointSet = false;
                this.getView().visible = false;
            }
            else {
                this.isFirstEditPointSet = true;
                this.setFirstEditPoint(x, y);
            }
        }
        isCreatingRectangle() {
            return this.isFirstEditPointSet && !this.isSecondEditPointSet;
        }
        hasCreatedRectangle() {
            return this.isFirstEditPointSet && this.isSecondEditPointSet;
        }
        setFirstEditPoint(x, y) {
            const pointInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
            this.model.min.x = pointInRelativeCoords.x;
            this.model.min.y = pointInRelativeCoords.y;
            this.model.max.x = pointInRelativeCoords.x;
            this.model.max.y = pointInRelativeCoords.y;
            this.getView().visible = true;
            this.invalidated = true;
        }
        setSecondEditPoint(x, y) {
            const pointInRelativeCoords = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
            this.model.max.x = pointInRelativeCoords.x;
            this.model.max.y = pointInRelativeCoords.y;
            this.getView().visible = true;
            this.invalidated = true;
        }
        // Mouse movement
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.isFirstEditPointSet && !this.isSecondEditPointSet) {
                this.setSecondEditPoint(x, y);
            }
            return false;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.invalidated = false;
                this.redraw();
            }
        }
        redraw() {
            this.redrawRectangle();
            this.redrawEditingPoints();
            this.redrawMeasureTexts();
        }
        redrawRectangle() {
            let camera = this.getScene().getCamera();
            // Line width
            let lineWidhtInPx = 1.0;
            let lineWidthInTx = camera.getPixelsInTexels(lineWidhtInPx);
            // Line color
            let lineColor = TapeMeasureWorldLayer.BORDER_COLOR;
            // Rectangle shape
            let min = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.model.min);
            let max = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(this.model.max);
            // Rectangle color
            let color = TapeMeasureWorldLayer.SHAPE_COLOR;
            const alpha = 0.1;
            // Draw rectangle
            this.rectangle.clear();
            this.rectangle.beginFill(color, alpha);
            this.rectangle.lineStyle(lineWidthInTx, lineColor);
            this.rectangle.drawRect(min.x, min.y, max.x - min.x, max.y - min.y);
            this.rectangle.drawPolygon([min, max]);
            this.rectangle.endFill();
        }
        redrawEditingPoints() {
            if (this.isEditModeActive()) {
                this.makeEditPointsVisible(true);
                this.repositionEditPoints();
                this.rescaleEditPoints();
            }
            else {
                this.makeEditPointsVisible(false);
            }
        }
        makeEditPointsVisible(visible) {
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.visible = visible;
            }
        }
        repositionEditPoints() {
            let topLeftInRelative = new PIXI.Point(this.model.min.x, this.model.min.y);
            let topRightInRelative = new PIXI.Point(this.model.max.x, this.model.min.y);
            let bottomLeftInRelative = new PIXI.Point(this.model.min.x, this.model.max.y);
            let bottomRightInRelative = new PIXI.Point(this.model.max.x, this.model.max.y);
            let topLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topLeftInRelative);
            let topRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(topRightInRelative);
            let bottomLeftInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomLeftInRelative);
            let bottomRightInTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(bottomRightInRelative);
            this.editingPoints[0].position = new Point_5.Point(topLeftInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[1].position = new Point_5.Point(topRightInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[2].position = new Point_5.Point(bottomLeftInTx, this.getEnvironment().renderingEnvironment);
            this.editingPoints[3].position = new Point_5.Point(bottomRightInTx, this.getEnvironment().renderingEnvironment);
        }
        rescaleEditPoints() {
            let camera = this.getScene().getCamera();
            let widthInPx = TapeMeasureWorldLayer.EDIT_POINT_RADIUS_IN_PX * 2;
            let widthInTx = camera.getPixelsInTexels(widthInPx);
            for (let i = 0; i < this.editingPoints.length; i++) {
                let editingPoint = this.editingPoints[i];
                editingPoint.width = widthInTx;
                editingPoint.height = widthInTx;
            }
        }
        redrawMeasureTexts() {
            this.makeMeasureTextsVisible(true);
            this.updateMeasureTexts();
        }
        makeMeasureTextsVisible(visible) {
            for (let i = 0; i < this.measureTexts.length; i++) {
                let measureText = this.measureTexts[i];
                measureText.visible = visible;
            }
        }
        updateMeasureTexts() {
            let camera = this.getScene().getCamera();
            let scaleFactor = camera.getScaleX();
            let cameraOrientation = camera.getRotation();
            let points = this.getRectanglePointsInTx();
            this.updateAxisAlignedMeasureTexts(points, scaleFactor, cameraOrientation);
            this.updateDiagonalMeasureText(points, scaleFactor, cameraOrientation);
            this.avoidOverlappingMeasureTexts();
        }
        getRectanglePointsInTx() {
            let points = [];
            const minX = Math.min(this.model.min.x, this.model.max.x);
            const maxX = Math.max(this.model.min.x, this.model.max.x);
            const minY = Math.min(this.model.min.y, this.model.max.y);
            const maxY = Math.max(this.model.min.y, this.model.max.y);
            let point1InRelative = new PIXI.Point(minX, minY);
            let point2InRelative = new PIXI.Point(maxX, minY);
            let point3InRelative = new PIXI.Point(maxX, maxY);
            let point4InRelative = new PIXI.Point(minX, maxY);
            let point1InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point1InRelative);
            let point2InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point2InRelative);
            let point3InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point3InRelative);
            let point4InTx = this.getFloorplanLayer().getTexelsFromRelativeCoordinates(point4InRelative);
            points.push(point1InTx);
            points.push(point2InTx);
            points.push(point3InTx);
            points.push(point4InTx);
            return points;
        }
        updateAxisAlignedMeasureTexts(points, scaleFactor, cameraOrientation) {
            for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                let measureText = this.axisAlignedMeasureTexts[i];
                let pointA = points[i];
                let pointB = points[(i + 1) % points.length];
                this.updateMeasureText(measureText, pointA, pointB, scaleFactor, cameraOrientation);
            }
        }
        updateDiagonalMeasureText(points, scaleFactor, cameraOrientation) {
            let point1 = points[0]; // min
            let point2 = points[2]; // max
            this.updateMeasureText(this.diagonalMeasureText, point1, point2, scaleFactor, cameraOrientation);
        }
        updateMeasureText(measureText, pointA, pointB, scaleFactor, cameraOrientation) {
            // Compute distance in meters
            let distanceInTx = Vector2_10.Vector2.getDistanceBetweenPoints(pointA, pointB);
            let distanceInCm = this.getFloorplanLayer().getCmFromTexels(distanceInTx);
            let distanceInM = distanceInCm / 100.0;
            // Text
            let newText = "" + distanceInM.toFixed(1) + " m";
            if (measureText.text !== newText) {
                measureText.text = newText;
            }
            // Scale
            measureText.setScaleX(scaleFactor);
            measureText.setScaleY(scaleFactor);
            // Orientation
            measureText.rotation = cameraOrientation;
            // Position
            let penetrationResolutionVector = this.getInterpenetrationResolutionVector(pointA, pointB, measureText);
            measureText.x = pointA.x + ((pointB.x - pointA.x) / 2) - measureText.width / 2 + penetrationResolutionVector.x;
            measureText.y = pointA.y + ((pointB.y - pointA.y) / 2) - measureText.height / 2 + penetrationResolutionVector.y;
        }
        getInterpenetrationResolutionVector(pointA, pointB, measureText) {
            let edgeX = pointB.x - pointA.x;
            let edgeY = pointB.y - pointA.y;
            let normalX = edgeY;
            let normalY = -edgeX;
            let normalizedNormalVector = Vector2_10.Vector2.normalizePoint(new PIXI.Point(normalX, normalY));
            let depthInTx = 0;
            // Padding
            let camera = this.getScene().getCamera();
            let paddingInPx = TapeMeasureWorldLayer.TEXT_PADDING_PX;
            let paddingInTx = camera.getPixelsInTexels(paddingInPx);
            if (Math.abs(normalX) > 0) {
                depthInTx = measureText.width / 2 + paddingInTx;
            }
            else {
                depthInTx = measureText.height / 2 + paddingInTx;
            }
            let penetrationVector = new PIXI.Point(normalizedNormalVector.x * depthInTx, normalizedNormalVector.y * depthInTx);
            return penetrationVector;
        }
        avoidOverlappingMeasureTexts() {
            // Show width and height texts only, if thery are not colliding with diagonal text.
            if (this.diagonalTextOveralpsAxisAlignedMeasureTexts()) {
                for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                    const axisAlignedMeasureText = this.axisAlignedMeasureTexts[i];
                    axisAlignedMeasureText.visible = false;
                }
            }
        }
        diagonalTextOveralpsAxisAlignedMeasureTexts() {
            const diagonalMeasureTextAabbInScreenPx = this.getMeasureTextBounds(this.diagonalMeasureText);
            for (let i = 0; i < this.axisAlignedMeasureTexts.length; i++) {
                const axisAlignedMeasureText = this.axisAlignedMeasureTexts[i];
                const axisAlignedTextAabbInScreenPx = this.getMeasureTextBounds(axisAlignedMeasureText);
                if (diagonalMeasureTextAabbInScreenPx.intersects(axisAlignedTextAabbInScreenPx)) {
                    return true;
                }
            }
        }
        getMeasureTextBounds(measureText) {
            const minInScreenCoords = measureText.pixi().toGlobal(new PIXI.Point(0 - measureText.anchor.x, 0 - measureText.anchor.y), new PIXI.Point());
            const maxInScreenCoords = measureText.pixi().toGlobal(new PIXI.Point(0 - measureText.anchor.x + measureText.width, 0 - measureText.anchor.y + measureText.height), new PIXI.Point());
            return new AABB_7.AABB(minInScreenCoords, maxInScreenCoords);
        }
        // Getters and setters
        setEditModeActive(enabled) {
            this.config.editModeEnabled = enabled;
            this.invalidated = true;
        }
        isEditModeActive() {
            return this.config.editModeEnabled;
        }
    }
    // Constants
    // Constants: Color
    TapeMeasureWorldLayer.CORNER_COLOR = 0xbb00bb;
    TapeMeasureWorldLayer.TEXT_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    TapeMeasureWorldLayer.BORDER_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    TapeMeasureWorldLayer.SHAPE_COLOR = TapeMeasureWorldLayer.CORNER_COLOR;
    // Constants: Edit points
    TapeMeasureWorldLayer.EDIT_POINT_RADIUS_IN_PX = 4;
    TapeMeasureWorldLayer.EDITABLE_POINT_MOBILE_TOLERANCE_IN_PX = 12;
    TapeMeasureWorldLayer.EDITABLE_POINT_DESKTOP_TOLERANCE_IN_PX = 6;
    // Constants: Length text
    TapeMeasureWorldLayer.TEXT_PADDING_PX = 5;
    exports.TapeMeasureWorldLayer = TapeMeasureWorldLayer;
    (function (TapeMeasureWorldLayer) {
        class Config {
            constructor() {
                /**
                 * True, if editing the tape measure should be enabled by default.
                 *
                 * Default: false
                 */
                this.editModeEnabled = false;
            }
        }
        TapeMeasureWorldLayer.Config = Config;
        class Model {
            constructor() {
                this._min = new PIXI.Point(0.0, 0.0);
                this._max = new PIXI.Point(0.0, 0.0);
            }
            get min() {
                return this._min;
            }
            set min(min) {
                this._min = min;
            }
            get max() {
                return this._max;
            }
            set max(max) {
                this._max = max;
            }
        }
        TapeMeasureWorldLayer.Model = Model;
    })(TapeMeasureWorldLayer = exports.TapeMeasureWorldLayer || (exports.TapeMeasureWorldLayer = {}));
});
define("src/app/relution/view/world/Floor", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", "src/map/utils/Logger", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", "src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", "src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", "src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", "src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer"], function (require, exports, Layer_5, FloorplanLayer_1, DeviceLayer_2, BeaconRangeLayer_1, DeviceTrackLayer_1, BeaconConnectionsLayer_1, Logger_4, GeofenceLayer_1, RelutionMapObjectLayer_4, Geofence_4, UserCountHeatmapLayer_1, WallplanLayer_1, DeviceAccuracyRangeLayer_1, DeviceTaggingLayer_1, FloorplanOverlayLayer_1, Device_4, RelutionMapObjectInfoLayer_1, SingleDeviceEditLayer_1, TapeMeasureWorldLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Represents a floor in the Relution Map.
     * A floor contains multiple layer containers. Each of them consists of layers
     * referring to different kinds of Relution map objects.
     */
    class Floor extends Layer_5.Layer {
        // Construction
        /**
         *
         * @param config
         * @param floorName Should be a unique string
         * @param floorModel
         */
        constructor(environment, floorName, floorModel, config = new Floor.Config()) {
            super(environment);
            // Observation
            this.observers = new Array();
            this.floorplanResourceName = null;
            this.floorplanTexture = null;
            this.wallplanResourceName = null;
            this.wallplanTexture = null;
            this.floorplanOverlayResourceNameToTexture = new Map();
            this.floorplanOverlayLayers = new Map();
            // View: Relution map object layers
            this.relutionMapObjectLayers = new Array();
            this.relutionMapObjectInfoLayers = new Map();
            this.config = config;
            this.initModel(floorName, floorModel);
        }
        initModel(floorName, floorModel) {
            this.floorName = floorName;
            this.floorModel = floorModel;
        }
        // Loading
        /**
         * Loads the floor's floorplan as a texture to the GPU memory.
         * @param loadedCallback Will be called, when the texture has been successfully loaded into GPU memory.
         */
        load(loadedCallback) {
            if (PIXI.loader.loading) {
                // TODO: loading the floorplan should be done by FruityMap.preloadResources()!
                setTimeout(() => {
                    this.load(loadedCallback);
                }, 1000);
                return;
            }
            this.floorplanResourceName = this.addImageToLoader(this.floorModel.floorplanImageUrl, "floorplan_");
            if (this.floorModel.wallplanImageUrl !== null) {
                this.wallplanResourceName = this.addImageToLoader(this.floorModel.wallplanImageUrl, "wallplan_");
            }
            this.floorModel.floorplanOverlayNameToImageUrl.forEach((overlayImageUrl, overlayName) => {
                this.floorplanOverlayResourceNameToTexture.set(this.addImageToLoader(overlayImageUrl, overlayName + "_"), null);
            });
            PIXI.loader.load(() => {
                if (this.floorplanLoaded() && this.wallplanLoaded() && this.overlayLayersLoaded()) {
                    this.floorplanTexture = PIXI.loader.resources["" + this.floorplanResourceName].texture;
                    if (this.wallplanResourceName !== null) {
                        this.wallplanTexture = PIXI.loader.resources["" + this.wallplanResourceName].texture;
                    }
                    for (let resourceName of Array.from(this.floorplanOverlayResourceNameToTexture.keys())) {
                        let texture = PIXI.loader.resources["" + resourceName].texture;
                        ;
                        this.floorplanOverlayResourceNameToTexture.set(resourceName, texture);
                    }
                    this.initWorldLayers();
                    loadedCallback(this);
                }
            });
        }
        floorplanLoaded() {
            return this.floorplanResourceName !== null && PIXI.loader.resources["" + this.floorplanResourceName] !== undefined;
        }
        wallplanLoaded() {
            return this.wallplanResourceName === null ||
                (this.wallplanResourceName !== null && PIXI.loader.resources["" + this.wallplanResourceName] !== undefined);
        }
        overlayLayersLoaded() {
            for (let resourceName of Array.from(this.floorplanOverlayResourceNameToTexture.keys())) {
                if (PIXI.loader.resources["" + resourceName] === undefined) {
                    return false;
                }
            }
            return true;
        }
        addImageToLoader(url, resourcePrefix) {
            let resourceName = resourcePrefix + this.floorName;
            let options = {
                crossOrigin: false,
                // Forces the loader to load URLs without extension as PNG.
                loadType: PIXI.loaders.Resource.LOAD_TYPE.IMAGE,
                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.BLOB,
            };
            if (PIXI.utils.TextureCache[this.floorplanResourceName]) {
                PIXI.utils.TextureCache[this.floorplanResourceName].destroy(true);
            }
            PIXI.loader.add(resourceName, url, options);
            return resourceName;
        }
        initWorldLayers() {
            this.loadMapLayers(this.floorModel);
            this.loadGeofenceLayers();
            this.loadDeviceLayers();
            this.loadOverlayLayers();
        }
        loadMapLayers(floorModel) {
            this.floorplanLayerContainer = new Layer_5.Layer(this.getEnvironment());
            this.floorplanLayerContainer.setVisible(true);
            // Init layers
            this.initFloorplanLayer(floorModel);
            this.initOverlayLayers();
            this.initWallplanLayer();
            // Add layers
            this.addLayer(this.floorplanLayerContainer);
            this.floorplanLayerContainer.addLayer(this.floorplanLayer);
            this.floorplanOverlayLayers.forEach((floorplanOverlayLayer, overlayName) => {
                this.floorplanLayerContainer.addLayer(floorplanOverlayLayer);
            });
            this.floorplanLayerContainer.addLayer(this.wallplanLayer);
            // Set default visibility
            this.floorplanLayer.setVisible(true);
        }
        initFloorplanLayer(floorModel) {
            this.floorplanLayer = new FloorplanLayer_1.FloorplanLayer(this.config.floorplanLayer, this.getEnvironment(), floorModel, this.floorplanTexture);
            this.floorplanLayer.setIsInBackground(true);
        }
        initOverlayLayers() {
            this.floorplanOverlayResourceNameToTexture.forEach((texture, resourceName) => {
                let overlayName = this.getOverlayNameForResourceWithName(resourceName);
                if (overlayName !== null) {
                    let floorplanOverlayLayer = new FloorplanOverlayLayer_1.FloorplanOverlayLayer(this.getEnvironment(), this.floorplanLayer, overlayName, texture);
                    this.floorplanOverlayLayers.set(overlayName, floorplanOverlayLayer);
                }
            });
        }
        getOverlayNameForResourceWithName(resourceName) {
            for (let overlayName of Array.from(this.floorModel.floorplanOverlayNameToImageUrl.keys())) {
                if (resourceName.indexOf(overlayName) > -1) {
                    return overlayName;
                }
            }
            return null;
        }
        initWallplanLayer() {
            this.wallplanLayer = new WallplanLayer_1.WallplanLayer(this.config.wallplanLayer, this.getEnvironment(), this.floorplanLayer, this.wallplanTexture);
        }
        loadGeofenceLayers() {
            this.geofenceLayerContainer = new Layer_5.Layer(this.getEnvironment());
            this.geofenceLayerContainer.setVisible(true);
            // Init layers
            this.initGeofenceLayer();
            this.initGeofenceInfoLayer();
            // Add layers
            this.addLayer(this.geofenceLayerContainer);
            this.geofenceLayerContainer.addLayer(this.geofenceLayer);
            this.geofenceLayerContainer.addLayer(this.geofenceInfoLayer);
            // Set default visibility
            this.geofenceLayer.setVisible(true);
        }
        initGeofenceLayer() {
            this.geofenceLayer = new GeofenceLayer_1.GeofenceLayer(this.config.geofenceLayer, this.getEnvironment(), this.floorplanLayer);
            this.geofenceLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.geofenceLayer);
        }
        initGeofenceInfoLayer() {
            this.geofenceInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.geofenceLayer);
            this.relutionMapObjectInfoLayers.set(Geofence_4.Geofence.name, this.geofenceInfoLayer);
        }
        loadDeviceLayers() {
            this.deviceLayerContainer = new Layer_5.Layer(this.getEnvironment());
            this.deviceLayerContainer.setVisible(true);
            // Init layers
            this.initDeviceLayer();
            this.initDeviceAccuracyRangeLayer();
            this.initBeaconRangeLayer();
            this.initDeviceTrackLayer();
            this.initBeaconConnectionsLayer();
            this.initDeviceTaggingLayer();
            this.initDeviceInfoLayer();
            this.initUserCountHeatmapLayer();
            this.initSingleDeviceEditLayer();
            // Add layers
            this.addLayer(this.deviceLayerContainer);
            this.deviceLayerContainer.addLayer(this.heatmapLayer);
            this.deviceLayerContainer.addLayer(this.beaconRangeLayer);
            this.deviceLayerContainer.addLayer(this.deviceAccuracyRangeLayer);
            this.deviceLayerContainer.addLayer(this.deviceTrackLayer);
            this.deviceLayerContainer.addLayer(this.beaconConnectionsLayer);
            this.deviceLayerContainer.addLayer(this.deviceLayer);
            this.deviceLayerContainer.addLayer(this.deviceTaggingLayer);
            this.deviceLayerContainer.addLayer(this.deviceInfoLayer);
            this.deviceLayerContainer.addLayer(this.singleDeviceEditLayer);
            // Set default visibility
            this.heatmapLayer.setVisible(true);
            this.beaconRangeLayer.setVisible(true);
            this.deviceAccuracyRangeLayer.setVisible(true);
            this.deviceTrackLayer.setVisible(true);
            this.beaconConnectionsLayer.setVisible(true);
            this.deviceLayer.setVisible(true);
            this.deviceTaggingLayer.setVisible(true);
            this.deviceInfoLayer.setVisible(true);
            this.singleDeviceEditLayer.setVisible(true);
        }
        initDeviceLayer() {
            this.deviceLayer = new DeviceLayer_2.DeviceLayer(this.getEnvironment(), this.floorplanLayer, this.config.deviceLayer);
            this.deviceLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.deviceLayer);
        }
        initDeviceAccuracyRangeLayer() {
            this.deviceAccuracyRangeLayer = new DeviceAccuracyRangeLayer_1.DeviceAccuracyRangeLayer(this.getEnvironment(), this.deviceLayer);
        }
        initBeaconRangeLayer() {
            this.beaconRangeLayer = new BeaconRangeLayer_1.BeaconRangeLayer(this.getEnvironment(), this.deviceLayer);
        }
        initDeviceTrackLayer() {
            this.deviceTrackLayer = new DeviceTrackLayer_1.DeviceTrackLayer(this.config.deviceTrackLayer, this.getEnvironment(), this.deviceLayer, this.deviceAccuracyRangeLayer);
        }
        initBeaconConnectionsLayer() {
            this.beaconConnectionsLayer = new BeaconConnectionsLayer_1.BeaconConnectionsLayer(this.getEnvironment(), this.deviceLayer);
        }
        initDeviceInfoLayer() {
            this.deviceInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer(this.config.objectInfoLayer, this.getEnvironment(), this.deviceLayer);
            this.relutionMapObjectInfoLayers.set(Device_4.Device.name, this.deviceInfoLayer);
        }
        initDeviceTaggingLayer() {
            this.deviceTaggingLayer = new DeviceTaggingLayer_1.DeviceTaggingLayer(this.config.deviceTaggingLayer, this.getEnvironment(), this.deviceLayer);
            this.deviceTaggingLayer.addObserver(this);
            this.relutionMapObjectLayers.push(this.deviceTaggingLayer);
        }
        initUserCountHeatmapLayer() {
            this.heatmapLayer = new UserCountHeatmapLayer_1.UserCountHeatmapLayer(this.config.userCountHeatmapLayer, this.getEnvironment(), this.deviceLayer);
        }
        initSingleDeviceEditLayer() {
            this.singleDeviceEditLayer = new SingleDeviceEditLayer_1.SingleDeviceEditLayer(this.config.singleDeviceEditLayer, this.getEnvironment(), this.deviceLayer);
        }
        loadOverlayLayers() {
            this.overlayLayerContainer = new Layer_5.Layer(this.getEnvironment());
            this.overlayLayerContainer.setVisible(true);
            // Init layers
            this.initTapeMeasureLayer();
            // Add layers
            this.addLayer(this.overlayLayerContainer);
            this.overlayLayerContainer.addLayer(this.tapeMeasureLayer);
            // Set default visibility
            this.tapeMeasureLayer.setVisible(true);
        }
        initTapeMeasureLayer() {
            this.tapeMeasureLayer = new TapeMeasureWorldLayer_1.TapeMeasureWorldLayer(this.config.tapeMeasureLayer, this.getEnvironment(), this.floorplanLayer);
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Generic Relution map object API
        /**
         * Returns a list of all Relution map objects ordered in the rendering order.
         */
        getAllVisibleObjects() {
            // We iterate in reverse order to test intersection of beacon on higher
            // levels at first.
            let allVisibleObjects = new Array();
            for (let i = this.relutionMapObjectLayers.length - 1; i >= 0; i--) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                if (relutionMapObjectLayer.isVisibleInWorld()) {
                    let objects = relutionMapObjectLayer.getAllVisibleObjects();
                    for (let j = objects.length - 1; j >= 0; j--) {
                        let object = objects[j];
                        allVisibleObjects.push(object);
                    }
                }
            }
            return allVisibleObjects;
        }
        /**
         * Returns the colliding object at position (x,y) given in screen pixels.
         * @param x \in [0, screenWidth]
         * @param y \in [0, screenHeight]
         * @param condition An additional condition the object is required to fulfill to be selected as the colliding object.
         */
        getCollidingObject(x, y, condition) {
            for (let i = this.relutionMapObjectLayers.length - 1; i >= 0; i--) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                let object = relutionMapObjectLayer.getCollidingObject(x, y, condition);
                if (object !== null) {
                    return object;
                }
            }
            return null;
        }
        // Devices
        /**
         * Loads a new list of devices into the map.
         * This will destroy all devices that currently exist and recreate them.
         * @param models
         */
        loadDevices(models) {
            this.loadObjects(this.deviceLayer, models);
        }
        /**
         * Updates the list of devices in the map.
         * If device's already exist, their state will be updated.
         * If devices are not in the list anymore, they will be removed from the scene graph.
         * If devices have been added to the list, the will be added to the scene graph.
         * @param models
         */
        updateDevices(models) {
            this.updateObjects(this.deviceLayer, models);
        }
        getDeviceWithUuid(uuid) {
            return this.getObjectWithUuid(this.deviceLayer, uuid);
        }
        toggleDeviceVisibility(uuid) {
            this.toggleObjectVisibility(this.deviceLayer, uuid);
        }
        setDeviceWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.deviceLayer, uuid);
        }
        setDeviceWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.deviceLayer, uuid);
        }
        moveDeviceWithUuidToMap(uuid) {
            this.moveObjectWithUuidToMap(this.deviceLayer, uuid);
        }
        moveDeviceWithUuidToStock(uuid) {
            this.moveObjectWithUuidToStock(this.deviceLayer, uuid);
        }
        /**
         * Returns the models of the device layer
         */
        getDeviceModels() {
            return this.getModelsFromObjectLayer(this.deviceLayer);
        }
        // Tracks
        /**
         * Loads the asset tracking position estimates to the map
         * @param positionEstimateModels
         */
        loadTracks(positionEstimateModels) {
            this.deviceTrackLayer.updatePositionEstimates(positionEstimateModels);
        }
        // Heatmap
        /**
         * Loads the user count measurements to the map and passes this information to the heatmap layer.
         * @param heatmapData
         */
        loadHeatmapData(heatmapData) {
            this.heatmapLayer.loadHeatmapData(heatmapData);
        }
        // Device tags
        /**
         * Updates the models of the device tags. Use the {@link getDeviceTagModels} method
         * to fetch the tag models of all devices, modify them, and reinject them using this function.
         * @param tagModels
         */
        updateDeviceTags(tagModels) {
            this.deviceTaggingLayer.updateModels(tagModels);
        }
        /**
         * Returns the models of the device tagging layer
         */
        getDeviceTagModels() {
            return this.getModelsFromObjectLayer(this.deviceTaggingLayer);
        }
        // Geofences
        loadGeofences(models) {
            this.loadObjects(this.geofenceLayer, models);
        }
        updateGeofences(models) {
            this.updateObjects(this.geofenceLayer, models);
        }
        getGeofenceWithUuid(uuid) {
            return this.getObjectWithUuid(this.geofenceLayer, uuid);
        }
        toggleGeofenceVisibility(uuid) {
            this.toggleObjectVisibility(this.geofenceLayer, uuid);
        }
        setGeofenceWithUuidSelected(uuid) {
            this.setObjectWithUuidSelected(this.geofenceLayer, uuid);
        }
        setGeofenceWithUuidUnselected(uuid) {
            this.setObjectWithUuidUnselected(this.geofenceLayer, uuid);
        }
        /**
         * Returns the models of the geofence layer
         */
        getGeofenceModels() {
            return this.getModelsFromObjectLayer(this.geofenceLayer);
        }
        // Relution map objects
        loadObjects(layer, models) {
            layer.loadModels(models);
        }
        updateObjects(layer, models) {
            if (layer.getObjects().length === 0) {
                this.loadObjects(layer, models);
            }
            else {
                layer.updateModels(models);
            }
        }
        getObjectWithUuid(layer, uuid) {
            return layer.getObjectWithUuid(uuid);
        }
        toggleObjectVisibility(layer, uuid) {
            layer.toggleObjectVisibility(uuid);
        }
        toggleObjectTypeVisibility(objectTypeName, visible) {
            for (let i = 0; i < this.relutionMapObjectLayers.length; i++) {
                let relutionMapObjectLayer = this.relutionMapObjectLayers[i];
                relutionMapObjectLayer.toggleObjectTypeVisibility(objectTypeName, visible);
            }
        }
        setObjectWithUuidSelected(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                // Remove observer, because we do not want to call the callback,
                // when the object is moved to the map via this interface.
                layer.removeObserver(this);
                // Select object
                object.setSelected(true);
                // Add observer again
                layer.addObserver(this);
            }
            else {
                Logger_4.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        setObjectWithUuidUnselected(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                // Remove observer, because we do not want to call the callback,
                // when the object is moved to the map via this interface.
                layer.removeObserver(this);
                // Select object
                object.setSelected(false);
                // Add observer again
                layer.addObserver(this);
            }
            else {
                Logger_4.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        moveObjectWithUuidToMap(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                if (object.isMovableToStock()) {
                    // Remove observer, because we do not want to call the callback,
                    // when the object is moved to the map via this interface.
                    layer.removeObserver(this);
                    // Move object to map
                    layer.moveObjectToMap(object);
                    // Add the observer again
                    layer.addObserver(this);
                }
                else {
                    Logger_4.Logger.logDebug("Object with UUID " + uuid + " is not movable to/from stock.");
                }
            }
            else {
                Logger_4.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        moveObjectWithUuidToStock(layer, uuid) {
            let object = layer.getObjectWithUuid(uuid);
            if (object != null) {
                if (object.isMovableToStock()) {
                    // Remove observer, because we do not want to call the callback,
                    // when the object is moved to the map via this interface.
                    layer.removeObserver(this);
                    // Move object to stock
                    layer.moveObjectToStock(object);
                    // Add the observer again
                    layer.addObserver(this);
                }
                else {
                    Logger_4.Logger.logDebug("Object with UUID " + uuid + " is not movable to/from stock.");
                }
            }
            else {
                Logger_4.Logger.logDebug("Object with uuid " + uuid + " does not exist");
            }
        }
        getModelsFromObjectLayer(relutionMapObjectLayer) {
            let models = [];
            let objects = relutionMapObjectLayer.getObjects();
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                let model = object.getModel();
                models.push(model);
            }
            return models;
        }
        setInfosOfAllMapObjectsVisible(objectTypeName, visible) {
            const infoLayer = this.relutionMapObjectInfoLayers.get(objectTypeName);
            if (infoLayer !== undefined) {
                infoLayer.setAllInfosVisible(visible);
            }
        }
        // Event-Handling: Device layer
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyObservers("onObjectMovedToStock", [beacon]);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        // @Override
        onObjectDoubleClicked(object) {
            this.notifyObservers("onObjectDoubleClicked", [object]);
        }
        // Floor information
        getHeightInMeter() {
            return this.floorModel.floorBaseInMeter;
        }
        getAvgBeaconHeightInMeter() {
            let deviceLayer = this.getDeviceLayer();
            let beaconsOnMap = deviceLayer.getBeaconsOnMap();
            let sumOfHeightInMeter = 0.0;
            for (let i = 0; i < beaconsOnMap.length; i++) {
                let beaconOnMap = beaconsOnMap[i];
                let deviceModel = beaconOnMap.getModel();
                let height = deviceModel.z;
                sumOfHeightInMeter += height;
            }
            let avgHeightInMeter = sumOfHeightInMeter / beaconsOnMap.length;
            return avgHeightInMeter;
        }
        // Getters and setters
        getFloorName() {
            return this.floorName;
        }
        getMapLayerContainer() {
            return this.floorplanLayerContainer;
        }
        getFloorplanLayer() {
            return this.floorplanLayer;
        }
        getWallplanLayer() {
            return this.wallplanLayer;
        }
        getGeofenceLayerContainer() {
            return this.geofenceLayerContainer;
        }
        getGeofenceLayer() {
            return this.geofenceLayer;
        }
        getDeviceLayerContainer() {
            return this.deviceLayerContainer;
        }
        getDeviceLayer() {
            return this.deviceLayer;
        }
        getBeaconRangeLayer() {
            return this.beaconRangeLayer;
        }
        getDeviceTrackLayer() {
            return this.deviceTrackLayer;
        }
        getBeaconConnectionsLayer() {
            return this.beaconConnectionsLayer;
        }
        getDeviceTaggingLayer() {
            return this.deviceTaggingLayer;
        }
        getDeviceInfoLayer() {
            return this.deviceInfoLayer;
        }
        getHeatmapLayer() {
            return this.heatmapLayer;
        }
        getSingleDeviceEditLayer() {
            return this.singleDeviceEditLayer;
        }
        getTapeMeasureLayer() {
            return this.tapeMeasureLayer;
        }
        getObjectLayers() {
            return this.relutionMapObjectLayers;
        }
        /**
         * Returns the floorplan overlay layer if exists, or null if an overlay layer
         * with the given name does not exist.
         * @param overlayName
         */
        getFloorplanOverlayLayerWithName(overlayName) {
            let layer = this.floorplanOverlayLayers.get(overlayName);
            return layer === undefined ? null : layer;
        }
    }
    exports.Floor = Floor;
    (function (Floor) {
        class Config {
            constructor() {
                // Map layers
                this.floorplanLayer = new FloorplanLayer_1.FloorplanLayer.Config();
                this.wallplanLayer = new WallplanLayer_1.WallplanLayer.Config();
                // Object layers
                this.objectInfoLayer = new RelutionMapObjectInfoLayer_1.RelutionMapObjectInfoLayer.Config();
                // Geofence layers
                this.geofenceLayer = new RelutionMapObjectLayer_4.RelutionMapObjectLayer.Config();
                // Device layers
                this.deviceLayer = new DeviceLayer_2.DeviceLayer.Config();
                this.deviceTrackLayer = new DeviceTrackLayer_1.DeviceTrackLayer.Config();
                this.deviceTaggingLayer = new RelutionMapObjectLayer_4.RelutionMapObjectLayer.Config();
                this.userCountHeatmapLayer = new UserCountHeatmapLayer_1.UserCountHeatmapLayer.Config();
                this.singleDeviceEditLayer = new SingleDeviceEditLayer_1.SingleDeviceEditLayer.Config();
                // Overlay layers
                this.tapeMeasureLayer = new TapeMeasureWorldLayer_1.TapeMeasureWorldLayer.Config();
            }
        }
        Floor.Config = Config;
    })(Floor = exports.Floor || (exports.Floor = {}));
});
define("src/app/relution/view/world/Building", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/Floor"], function (require, exports, Layer_6, Floor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Represents a building in the Relution Map.
     * A building consists of one or more floors. Only one floor is visible at each time.
     * The floors are ordered from bottom to top. <code>Ctrl+Up</code> fades to an upper floor,
     * whereas <code>Ctrl+Down</code> fades to a lower floor.
     */
    class Building extends Layer_6.Layer {
        // Construction
        /**
         * Creates a building with one floor passed as an argument.
         * @param floor
         */
        constructor(config, environment, floor) {
            super(environment);
            // Configuration
            this.config = new Building.Config();
            // Observation
            this.floorObservers = new Array();
            this.relutionMapObjectObservers = new Array();
            // View: Floors
            this.floors = new Array();
            this.currentFloor = null;
            // Modes
            this.deviceEditingEnabled = false;
            this.singleDeviceEditModeEnabled = false;
            this.geofenceEditingEnabled = false;
            this.taggingModeEnabled = false;
            this.tapeMeasureEditModeEnabled = false;
            this.config = config;
            this.initLayerVisibility();
            this.initObjectTypeVisibility();
            this.initFloors(floor);
        }
        initLayerVisibility() {
            this.layerNameToVisible = {};
            this.layerNameToVisible["wallplan"] = false;
            this.layerNameToVisible["devices"] = true;
            this.layerNameToVisible["help"] = true;
            this.layerNameToVisible["ranges"] = true;
            this.layerNameToVisible["info"] = false;
            this.layerNameToVisible["connections"] = true;
            this.layerNameToVisible["tracking"] = true;
            this.layerNameToVisible["heatmap"] = true;
            this.layerNameToVisible["geofence"] = true;
            this.layerNameToVisible["tagging"] = false;
            this.layerNameToVisible["tapeMeasure"] = false;
            this.config.layerVisibilities.forEach((visible, layerName) => {
                this.layerNameToVisible[layerName] = visible;
            });
        }
        initObjectTypeVisibility() {
            this.relutionMapObjectTypeNamesToVisible = this.config.objectTypeVisibilities;
        }
        initFloors(floor) {
            this.addFloor(floor);
            this.setCurrentFloor(floor);
        }
        // Floor management
        /**
         * Adds a floor to the list of all floors. This floor will be considered
         * as the top floor in the building.
         * @param floor
         */
        addFloor(floor) {
            if (this.floors.indexOf(floor) == -1) {
                this.floors.push(floor);
                this.addLayerAtIndex(floor, 0);
                this.initFloor(floor);
                this.notifyFloorObservers("floorAdded", [floor]);
            }
        }
        /**
         * Adds floors to the list of all floors. These floors will be considered
         * to be the top floors in the building. The floor list must be ordered from bottom to top.
         * @param floors
         */
        addFloors(floors) {
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.addFloor(floor);
            }
        }
        initFloor(floor) {
            floor.setVisible(false);
            this.setEditModeActive(this.isEditModeActive());
            this.setDeviceEditingEnabled(this.isDeviceEditingEnabled());
        }
        /**
         * Removes the floor from the list of all floors.
         * @param floor
         */
        removeFloor(floor) {
            let index = this.floors.indexOf(floor);
            if (index !== -1) {
                this.floors.splice(index, 1);
                this.notifyFloorObservers("floorRemoved", [floor]);
            }
        }
        /**
         * Sorts all floors by height in an ascending order (bottom -> top).
         * The height of a floor is specified in "floorBaseInMeter" attribute the floor model.
         * The bottom most floor will be set as the active one.
         */
        sortFloorsByHeight() {
            // Sort floors list
            this.floors.sort((floorA, floorB) => {
                let heightA = floorA.getHeightInMeter();
                let heightB = floorB.getHeightInMeter();
                if (heightA < heightB) {
                    return -1;
                }
                else if (heightA > heightB) {
                    return +1;
                }
                else {
                    return 0;
                }
            });
            // Sort scene graph
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                this.setLayerAtIndex(floor, i);
            }
            // Make bottom most layer the active one
            this.setCurrentFloor(this.floors[0]);
        }
        // Floor change
        /**
         * Changes the active floor to the floor "floor".
         * @param floor The floor that should be set to the active one.
         * @param changeVisibility Should be set to true, if the current floor should be visible.
         * This should only be set to false, if a fading animation is used to smoothly fade into
         * this floor (See @code animateToFloor).
         */
        setCurrentFloor(floor, changeVisibility = true) {
            let floorBefore = this.currentFloor;
            let floorAfter = floor;
            if (this.currentFloor !== null) {
                this.leaveFloor(this.currentFloor, changeVisibility);
            }
            this.currentFloor = floor;
            if (this.currentFloor !== null) {
                this.enterFloor(this.currentFloor, changeVisibility);
            }
            this.notifyFloorObservers("floorChanged", [floorBefore, floorAfter]);
        }
        /**
         * Animates to the floor "floor" and makes this floor the active floor.
         * @param floor
         */
        animateToFloor(floor) {
            // Set current floor, without changing the visibility
            this.setCurrentFloor(floor, false);
            // Fade in floor
            floor.animateVisible(true, () => {
                // Guarantee that only the current floor is visible
                this.makeAllInactiveFloorsInvisible();
                floor.setVisible(true);
            });
        }
        /**
         * Fades to the upper floor and makes this floor the active floor.
         */
        changeToUpperFloor() {
            let indexOfCurrentFloor = this.floors.indexOf(this.getCurrentFloor());
            let indexOfUpperFloor = indexOfCurrentFloor + 1;
            if (indexOfUpperFloor >= 0 && indexOfUpperFloor < this.floors.length) {
                let upperFloor = this.floors[indexOfUpperFloor];
                this.animateToFloor(upperFloor);
            }
        }
        /**
         * Fades to the lower floor and makes this floor the active floor.
         */
        changeToLowerFloor() {
            let indexOfCurrentFloor = this.floors.indexOf(this.getCurrentFloor());
            let indexOfUpperFloor = indexOfCurrentFloor - 1;
            if (indexOfUpperFloor >= 0 && indexOfUpperFloor < this.floors.length) {
                let upperFloor = this.floors[indexOfUpperFloor];
                this.animateToFloor(upperFloor);
            }
        }
        // Floor access
        /**
         * Returns the list of all floors ordered from bottom to top.
         */
        getFloors() {
            return this.floors;
        }
        /**
         * Returns floor with the name "floorName".
         * @param floorName
         */
        getFloorWithName(floorName) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (floor.getFloorName() === floorName) {
                    return floor;
                }
            }
            return null;
        }
        /**
         * Returns the floor's index in the list of floors.
         * @param floor
         */
        getFloorIndex(floor) {
            for (let i = 0; i < this.floors.length; i++) {
                let currentFloor = this.floors[i];
                if (currentFloor === floor) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Returns the floor that is currently active.
         */
        getCurrentFloor() {
            return this.currentFloor;
        }
        enterFloor(floor, changeVisibility) {
            if (changeVisibility) {
                this.makeAllInactiveFloorsInvisible();
                floor.setVisible(true);
            }
            // Move floor to the top in the scene graph.
            // This is necessary. Otherwise the invisible floors
            // might receive the interaction events first.
            this.setChildIndex(floor, this.getChildren().length);
            this.configureFloorOnEnter();
            this.registerAsObserver();
        }
        makeAllInactiveFloorsInvisible() {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (floor !== this.currentFloor) {
                    floor.setVisible(false);
                }
            }
        }
        configureFloorOnEnter() {
            // 1. Make layers visible/invisible and register as observer to the layers
            this.syncLayerVisibilitiesForCurrentFloor();
            this.addLayerVisibilityObservers();
            // 2. Make Relution map object types visible and register as observer
            this.syncObjectTypeVisibilitiesForCurrentFloor();
        }
        leaveFloor(floor, changeVisibility) {
            if (changeVisibility) {
                floor.setVisible(false);
            }
            this.configureFloorOnLeft();
            this.unregisterAsObserver();
        }
        configureFloorOnLeft() {
            this.removeLayerVisibilityObservers();
        }
        registerAsObserver() {
            this.getCurrentFloor().addObserver(this);
        }
        unregisterAsObserver() {
            if (this.getCurrentFloor() !== undefined) {
                this.getCurrentFloor().removeObserver(this);
            }
        }
        // Floor observation
        /**
         * Adds an observer to the list of all observers.
         * Can be used to get informed about floor changes.
         * @param observer
         */
        addFloorObserver(observer) {
            this.floorObservers.push(observer);
        }
        /**
         * Removes an observer from the list of all observers.
         * @param observer
         */
        removeFloorObserver(observer) {
            let index = this.floorObservers.indexOf(observer);
            if (index !== -1) {
                this.floorObservers.splice(index, 1);
            }
        }
        notifyFloorObservers(callback, args) {
            for (let i = 0; i < this.floorObservers.length; i++) {
                let observer = this.floorObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Relution map objects
        // Relution map objects: Observation
        /**
         * Adds a RelutionMapObject observer to the list of all RelutionMapObject observers.
         * Should be used to get informed about RelutionMapObject state changes (e.g. selection changes etc.).
         * @param observer
         */
        addRelutionMapObjectObserver(observer) {
            this.relutionMapObjectObservers.push(observer);
        }
        /**
         * Removes a RelutionMapObject observer to the list of all RelutionMapObject observers.
         * @param observer
         */
        removeRelutionMapObjectObserver(observer) {
            let index = this.relutionMapObjectObservers.indexOf(observer);
            if (index !== -1) {
                this.relutionMapObjectObservers.splice(index, 1);
            }
        }
        notifyRelutionMapObjectObservers(callback, args) {
            for (let i = 0; i < this.relutionMapObjectObservers.length; i++) {
                let observer = this.relutionMapObjectObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Relution map objects: Object type toggling
        toggleRelutionMapObjectTypeVisibility(objectTypeName, visible, notifyObservers = true) {
            // 1. Set optional parameter value, if necessary.
            if (visible === undefined) {
                visible = this.relutionMapObjectTypeNamesToVisible.get(objectTypeName) === undefined ? true : !this.relutionMapObjectTypeNamesToVisible.get(objectTypeName);
            }
            // 1. Update visibility map
            this.relutionMapObjectTypeNamesToVisible.set(objectTypeName, visible);
            // 2. Update relution map object type visibility on all floors
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.toggleObjectTypeVisibility(objectTypeName, visible);
            }
            // 3. Notify observers
            if (notifyObservers) {
                this.notifyRelutionMapObjectObservers("onObjectTypeVisibilityChanged", [objectTypeName, visible]);
            }
        }
        syncObjectTypeVisibilitiesForCurrentFloor() {
            this.relutionMapObjectTypeNamesToVisible.forEach((visible, objectTypeName) => {
                this.getCurrentFloor().toggleObjectTypeVisibility(objectTypeName, visible);
            });
        }
        // Relution map objects: Info toggling
        /**
         * Sets the info labels (names) of all Relution map objects to {@link visible}.
         * @param objectTypeName is a direct subclass of {@link RelutionMapObject}, e.g. Device.name or Geofence.name
         * @param visible true, if all objects of the given type and its subtypes should be permanently visible.
         */
        setInfosOfAllMapObjectsVisible(objectTypeName, visible) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.setInfosOfAllMapObjectsVisible(objectTypeName, visible);
            }
        }
        // Layers
        syncLayerVisibilitiesForCurrentFloor() {
            this.layerNameToLayer = {
                wallplan: this.getCurrentFloor().getWallplanLayer(),
                devices: this.getCurrentFloor().getDeviceLayerContainer(),
                ranges: this.getCurrentFloor().getBeaconRangeLayer(),
                info: this.getCurrentFloor().getDeviceInfoLayer().getInfoContainerLayer(),
                connections: this.getCurrentFloor().getBeaconConnectionsLayer(),
                tracking: this.getCurrentFloor().getDeviceTrackLayer(),
                heatmap: this.getCurrentFloor().getHeatmapLayer(),
                geofence: this.getCurrentFloor().getGeofenceLayerContainer(),
                tagging: this.getCurrentFloor().getDeviceTaggingLayer(),
                tapeMeasure: this.getCurrentFloor().getTapeMeasureLayer()
            };
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                let visible = this.layerNameToVisible[layerName];
                if (layer != null) {
                    layer.setVisible(visible);
                }
            }
        }
        addLayerVisibilityObservers() {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                if (layer != null) {
                    layer.addVisiblityObserver(this);
                }
            }
        }
        removeLayerVisibilityObservers() {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let layer = this.layerNameToLayer[layerName];
                if (layer != null) {
                    layer.removeVisibilityObserver(this);
                }
            }
        }
        toggleLayerVisibility(layerName, enabled) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (layerName === "wallplan") {
                    this.toggleVisibilityForLayer(floor.getWallplanLayer(), enabled);
                }
                else if (layerName === "devices") {
                    this.toggleVisibilityForLayer(floor.getDeviceLayerContainer(), enabled);
                }
                else if (layerName === "ranges") {
                    this.toggleVisibilityForLayer(floor.getBeaconRangeLayer(), enabled);
                }
                else if (layerName === "info") {
                    this.toggleVisibilityForLayer(floor.getDeviceInfoLayer().getInfoContainerLayer(), enabled);
                }
                else if (layerName === "connections") {
                    this.toggleVisibilityForLayer(floor.getBeaconConnectionsLayer(), enabled);
                }
                else if (layerName === "tracking") {
                    this.toggleVisibilityForLayer(floor.getDeviceTrackLayer(), enabled);
                }
                else if (layerName === "heatmap") {
                    this.toggleVisibilityForLayer(floor.getHeatmapLayer(), enabled);
                }
                else if (layerName === "geofence") {
                    this.toggleVisibilityForLayer(floor.getGeofenceLayerContainer(), enabled);
                }
                else if (layerName === "tagging") {
                    this.toggleVisibilityForLayer(floor.getDeviceTaggingLayer(), enabled);
                }
                else if (layerName === "tapeMeasure") {
                    this.toggleVisibilityForLayer(floor.getTapeMeasureLayer(), enabled);
                }
                else if (floor.getFloorplanOverlayLayerWithName(layerName) !== null) {
                    this.toggleVisibilityForLayer(floor.getFloorplanOverlayLayerWithName(layerName), enabled);
                }
            }
        }
        toggleVisibilityForLayer(layer, enabled) {
            if (enabled == null) {
                layer.animateVisible(!layer.isVisible());
            }
            else {
                layer.animateVisible(enabled);
            }
        }
        // @Override
        visibilityChanged(layer) {
            let layerName = this.getLayerNameForLayer(layer);
            let layerVisible = layer.isVisible();
            this.layerNameToVisible[layerName] = layerVisible;
            this.notifyRelutionMapObjectObservers("onLayerVisibilityChanged", [layerName, layerVisible]);
        }
        getLayerNameForLayer(layer) {
            let layerNames = Object.keys(this.layerNameToLayer);
            for (let i = 0; i < layerNames.length; i++) {
                let layerName = layerNames[i];
                let currentLayer = this.layerNameToLayer[layerName];
                if (currentLayer && currentLayer === layer) {
                    return layerName;
                }
            }
        }
        getLayerWithName(layerName) {
            if (this.layerNameToLayer.hasOwnProperty(layerName)) {
                return this.layerNameToLayer[layerName];
            }
            else {
                return null;
            }
        }
        // Event handling
        // Event-Handling: Relution map objects
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyRelutionMapObjectObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyRelutionMapObjectObservers("onObjectMovedToStock", [beacon]);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyRelutionMapObjectObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyRelutionMapObjectObservers("onObjectUnselected", [object]);
        }
        // @Override
        onObjectDoubleClicked(object) {
            this.notifyRelutionMapObjectObservers("onObjectDoubleClicked", [object]);
        }
        // Modes
        isEditModeActive() {
            return this.floors[0].getDeviceLayer().isEditModeActive();
        }
        setEditModeActive(editModeActive) {
            this.setMapLayerContainerClearlyVisible(editModeActive);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceLayer().setEditModeActive(editModeActive);
            }
        }
        isDeviceEditingEnabled() {
            return this.deviceEditingEnabled;
        }
        setDeviceEditingEnabled(enabled) {
            this.deviceEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceLayer().setEditModeActive(enabled);
            }
        }
        isSingleDeviceEditModeEnabled() {
            return this.singleDeviceEditModeEnabled;
        }
        setSingleDeviceEditModeEnabled(enabled, editableDeviceUuid) {
            this.singleDeviceEditModeEnabled = enabled;
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getSingleDeviceEditLayer().setEditModeActive(enabled, editableDeviceUuid);
            }
        }
        isGeofenceEditingEnabled() {
            return this.geofenceEditingEnabled;
        }
        setGeofenceEditingEnabled(enabled) {
            this.geofenceEditingEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getGeofenceLayer().setEditModeActive(enabled);
            }
        }
        setMapLayerContainerClearlyVisible(clearlyVisible) {
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                if (clearlyVisible) {
                    floor.getMapLayerContainer().animateAlphaToValue(1.0);
                }
                else {
                    floor.getMapLayerContainer().animateVisible(true);
                }
            }
        }
        isTaggingModeEnabled() {
            return this.taggingModeEnabled;
        }
        setTaggingModeEnabled(enabled) {
            this.taggingModeEnabled = enabled;
            this.setMapLayerContainerClearlyVisible(enabled);
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getDeviceTaggingLayer().setEditModeActive(enabled);
            }
        }
        isTapeMeasureEditModeEnabled() {
            return this.tapeMeasureEditModeEnabled;
        }
        setTapeMeasureEditModeEnabled(enabled) {
            this.tapeMeasureEditModeEnabled = enabled;
            for (let i = 0; i < this.floors.length; i++) {
                let floor = this.floors[i];
                floor.getTapeMeasureLayer().setEditModeActive(enabled);
            }
        }
        // Destruction
        // @Override
        destroy() {
            this.unregisterAsObserver();
            this.removeLayerVisibilityObservers();
        }
        // Getters and setters
        getConfig() {
            return this.config;
        }
    }
    exports.Building = Building;
    (function (Building) {
        class Config {
            constructor() {
                /**
                 * The default floor configuration.
                 */
                this.floor = new Floor_1.Floor.Config();
                /**
                 * Overrides the default visibility configuration for the
                 * specified Relution map object types.
                 * Maps the object type name (string) to its visibility (boolean).
                 */
                this.objectTypeVisibilities = new Map();
                /**
                 * Overrides the default visibility configuration for the layers specified by their names.
                 * Maps the layer name (string) to its visibility (boolean).
                 */
                this.layerVisibilities = new Map();
            }
        }
        Building.Config = Config;
    })(Building = exports.Building || (exports.Building = {}));
});
define("src/app/relution/view/hud/barLayer/beaconBar/BeaconBar", ["require", "exports", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/beaconBar/BeaconItem", "src/engine/general/AABB", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, Bar_1, BeaconItem_1, AABB_8, GraphicsObject_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconBar extends Bar_1.Bar {
        // Initialization
        constructor(environment, world, building) {
            super(environment, world.getScene().getCamera().getScreenWidth(), BeaconItem_1.BeaconItem.ITEM_HEIGHT);
            // Observation
            this.observers = new Array();
            this.beaconItems = new Array();
            // View: Moving
            this.userMovesBeacon = false;
            this.initModel(world, building);
            this.initView();
        }
        initModel(world, building) {
            this.world = world;
            this.building = building;
            this.building.addFloorObserver(this);
            this.registerAsObserver(this.building.getCurrentFloor());
        }
        registerAsObserver(currentFloor) {
            let deviceLayer = currentFloor.getDeviceLayer();
            deviceLayer.addObserver(this);
        }
        unregisterAsObserver(leftFloor) {
            let deviceLayer = leftFloor.getDeviceLayer();
            deviceLayer.removeObserver(this);
        }
        initView() {
            this.createView();
            this.layoutView();
        }
        createView() {
            this.initBar();
            this.initBackgroundView();
        }
        initBar() {
            this.setAutoFadeEnabled(false);
        }
        initBackgroundView() {
            this.backgroundView = new GraphicsObject_8.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.alpha = 0.25;
            this.getView().addChild(this.backgroundView);
        }
        layoutView() {
            this.layoutScrollableContainer();
            this.layoutBackgroundView();
        }
        layoutScrollableContainer() {
            let camera = this.world.getScene().getCamera();
            // Position
            this.getView().x = 0;
            this.getView().y = camera.getScreenHeight() - BeaconItem_1.BeaconItem.ITEM_HEIGHT;
        }
        layoutBackgroundView() {
            let camera = this.world.getScene().getCamera();
            let screenWidth = camera.getScreenWidth();
            this.backgroundView.clear();
            this.backgroundView.beginFill(0x95b507);
            this.backgroundView.drawRect(0, 0, screenWidth, BeaconItem_1.BeaconItem.ITEM_HEIGHT);
            this.backgroundView.endFill();
        }
        // Scene initialization
        // @Override
        initialize() {
            super.initialize();
            // Set bar to bottom
            let worldCamera = this.getScene().getCamera();
            let screenHeight = worldCamera.getScreenHeight();
            this.getView().y = screenHeight - this.getView().height;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        /**
         * @param {BeaconBar.Observer} observer
         * @returns
         * @memberof BeaconBar
         */
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Floor Event handling
        // @Override
        floorChanged(floorBefore, floorAfter) {
            this.unregisterAsObserver(floorBefore);
            this.registerAsObserver(floorAfter);
        }
        // Beacon-Layer Event-Handling
        // @Override
        onObjectsLoaded(devices) {
            this.resetItemPositions(false);
        }
        // @Override
        onObjectsUnloaded(devices) {
            let allBeacons = this.building.getCurrentFloor().getDeviceLayer().filterBeacons(devices);
            this.removeBeaconItemsForBeacons(allBeacons);
            this.resetItemPositions(false);
        }
        removeBeaconItemsForBeacons(beacons) {
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                let beaconItem = this.getBeaconItemForBeacon(beacon);
                if (beaconItem != null) {
                    this.removeBeaconItem(beaconItem);
                }
            }
        }
        // @Override
        onObjectSetToStock(beacon) {
            this.addBeaconItemAndResetPosition(beacon, false);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.addBeaconItemAndResetPosition(beacon, true);
        }
        addBeaconItemAndResetPosition(beacon, animate) {
            let beaconItem = this.addBeaconItem(beacon);
            this.resetBeaconItemPosition(beaconItem, animate);
            return beaconItem;
        }
        addBeaconItem(beacon) {
            this.initBeaconForBar(beacon);
            let beaconItem = this.createBeaconItem(beacon);
            this.reassignMovingBeaconItem(beaconItem);
            return beaconItem;
        }
        initBeaconForBar(beacon) {
            beacon.setFreezed(true);
        }
        createBeaconItem(beacon) {
            // Save beacon world position
            let beaconWorldPosition = new PIXI.Point(beacon.getView().x, beacon.getView().y);
            // Create beacon item
            let beaconItem = new BeaconItem_1.BeaconItem(this.getEnvironment(), beacon);
            this.getContentObject().addChild(beaconItem);
            this.beaconItems.push(beaconItem);
            this.updateScrollViewDimensions();
            // Set current position
            this.setInitialBeaconItemPositionToBeaconWorldPosition(beaconItem, beaconWorldPosition);
            // Set target position
            let itemIndex = this.beaconItems.length - 1;
            let itemPosition = this.getCurrentBeaconItemPositionForItemWithIndex(itemIndex);
            beaconItem.setTargetPosition(itemPosition);
            return beaconItem;
        }
        updateScrollViewDimensions() {
            let maxX = this.getMaxXBeaconItemPosition();
            let maxY = BeaconItem_1.BeaconItem.ITEM_HEIGHT;
            let aabb = new AABB_8.AABB(new PIXI.Point(0, 0), new PIXI.Point(maxX, maxY));
            this.updateContentObjectDimensions(aabb);
        }
        getMaxXBeaconItemPosition() {
            return this.getStartXPositionForBeaconItemIndex(this.beaconItems.length);
        }
        getStartXPositionForBeaconItemIndex(itemIndex) {
            let startX = 0.0;
            for (let i = 0; i < itemIndex; i++) {
                let beaconItem = this.beaconItems[i];
                startX += beaconItem.getItemWidth();
            }
            return startX;
        }
        setInitialBeaconItemPositionToBeaconWorldPosition(beaconItem, beaconWorldPosition) {
            // Set the beacons position in the bar as if it was still in the world.
            let beacon = beaconItem.getBeacon();
            let worldCamera = this.world.getScene().getCamera();
            let beaconWorldPositionInImageCoordinates = worldCamera.getImageCoordinateFromWorldPoint(beaconWorldPosition);
            let beaconLocalPosition = this.getContentObject().getView().pixi().toLocal(beaconWorldPositionInImageCoordinates);
            beaconItem.getView().x = beaconLocalPosition.x;
            beaconItem.getView().y = beaconLocalPosition.y;
        }
        resetBeaconItemPosition(beaconItem, animate) {
            if (animate) {
                // Do not play reset animation, if user moves the beacon
                if (this.movingBeaconItem == null || (this.movingBeaconItem.getBeacon() !== beaconItem.getBeacon())) {
                    beaconItem.startResetAnimation();
                }
            }
            else {
                beaconItem.resetPosition();
            }
        }
        reassignMovingBeaconItem(beaconItem) {
            // Change the moving beacon item, if the beacon was moved to the bar again
            if (this.movingBeaconItem != null && this.movingBeaconItem.getBeacon() === beaconItem.getBeacon()) {
                this.movingBeaconItem = beaconItem;
            }
        }
        getCurrentBeaconItemPositionForItemWithIndex(index) {
            let beaconItem = this.beaconItems[index];
            let startX = this.getStartXPositionForBeaconItemIndex(index);
            let x = startX + beaconItem.getPivotX();
            let y = beaconItem.getPivotY();
            return new PIXI.Point(x, y);
        }
        // @Override
        onObjectSetToMap(beacon) {
            this.onObjectMovedToMap(beacon);
        }
        // @Override
        onObjectMovedToMap(beacon) {
            let beaconItem = this.getBeaconItemForBeacon(beacon);
            if (beaconItem != null) {
                this.removeBeaconItem(beaconItem);
                this.resetItemPositions();
                // Disable freezing the beacon
                beacon.setFreezed(false);
            }
        }
        getBeaconItemForBeacon(beacon) {
            for (let i = 0; i < this.beaconItems.length; i++) {
                let beaconItem = this.beaconItems[i];
                if (beaconItem.getBeacon() === beacon) {
                    return beaconItem;
                }
            }
            return null;
        }
        removeBeaconItem(beaconItem) {
            let index = this.beaconItems.indexOf(beaconItem);
            this.beaconItems.splice(index, 1);
            this.getContentObject().removeChild(beaconItem);
            this.updateScrollViewDimensions();
        }
        // @Override
        onObjectMoveStarted(beacon, x, y) {
            // We move the beacon to the stock and instantly to the map again.
            // Observers in the device layer should not notice any change, so we
            // unregister them during this process.
            let deviceLayerObservers = this.unregisterRemainingObserversFromDeviceLayer();
            let beaconPosition = new PIXI.Point(beacon.getView().x, beacon.getView().y);
            // 1. Move beacon instantly to stock
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(beacon);
            let beaconItem = this.getBeaconItemForBeacon(beacon);
            beaconItem.stopResetAnimation();
            beaconItem.resetPosition();
            // 2. Move beacon to world and change its position back to (x,y)
            this.notifyObservers("onBeaconEnteredWorld", []);
            this.movingPointInDeviceLocalTx = this.getMovingPointInDeviceLocalTexels(beaconPosition.x, beaconPosition.y, x, y);
            this.moveBeaconToMap(x, y, beaconItem);
            this.resetItemPositions();
            this.setBeaconPositionInMap(beaconItem.getBeacon(), x, y);
            // 3. Simulate panning start
            this.userMovesBeacon = true;
            this.movingBeaconItem = beaconItem;
            this.registerRemainingObserversFromDeviceLayer(deviceLayerObservers);
        }
        unregisterRemainingObserversFromDeviceLayer() {
            let observers = this.building.getCurrentFloor().getDeviceLayer().getObservers();
            let observersCopy = observers.slice();
            let unregisteredObservers = [];
            for (let i = 0; i < observersCopy.length; i++) {
                let observer = observersCopy[i];
                if (observer !== this && observer !== this.building.getCurrentFloor().getDeviceLayer()) {
                    this.building.getCurrentFloor().getDeviceLayer().removeObserver(observer);
                    unregisteredObservers.push(observer);
                }
            }
            return unregisteredObservers;
        }
        registerRemainingObserversFromDeviceLayer(deviceLayerObservers) {
            for (let i = 0; i < deviceLayerObservers.length; i++) {
                let observer = deviceLayerObservers[i];
                if (observer !== this) {
                    this.building.getCurrentFloor().getDeviceLayer().addObserver(observer);
                }
            }
        }
        // @Override
        onObjectMoveChanged(beacon, x, y) {
            this.onPanningMove(x, y);
        }
        // @Override
        onObjectMoveStopped(beacon, x, y) {
            this.onPanningEnd(x, y);
        }
        // Input Event-Handling
        // @Override: Beacon items define a non-scrollable area.
        isInScrollableArea(x, y) {
            let touchingBeaconItem = this.getTouchingBeaconItem(x, y);
            return touchingBeaconItem == null;
        }
        // @Override
        onPanningStart(x, y) {
            let handled = super.onPanningStart(x, y);
            if (handled) {
                return true;
            }
            let touchingBeaconItem = this.getTouchingBeaconItem(x, y);
            if (touchingBeaconItem != null) {
                this.userMovesBeacon = true;
                this.movingBeaconItem = touchingBeaconItem;
                let floorplanLayer = this.building.getCurrentFloor().getFloorplanLayer();
                let beacon = this.movingBeaconItem.getBeacon();
                if (beacon.getScene() === this.world.getScene()) {
                    this.movingPointInDeviceLocalTx = this.getMovingPointInDeviceLocalTexels(beacon.getView().x, beacon.getView().y, x, y);
                }
                else {
                    this.movingPointInDeviceLocalTx = new PIXI.Point();
                }
                return true;
            }
            else {
                return false;
            }
        }
        getTouchingBeaconItem(touchX, touchY) {
            for (let i = 0; i < this.beaconItems.length; i++) {
                let beaconItem = this.beaconItems[i];
                let beacon = beaconItem.getBeacon();
                if (this.isPointInsideBeacon(touchX, touchY, beacon, beaconItem)) {
                    return beaconItem;
                }
            }
            return null;
        }
        isPointInsideBeacon(xInImage, yInImage, beacon, beaconItem) {
            let beaconGlobalPos = beacon.getView().pixi().toGlobal(new PIXI.Point(), new PIXI.Point());
            let beaconCenterX = beaconGlobalPos.x + beacon.getView().width / 2;
            let beaconCenterY = beaconGlobalPos.y + beacon.getView().height / 2;
            let collisionMinX = beaconCenterX - beaconItem.getItemWidth() / 2;
            let collisionMaxX = beaconCenterX + beaconItem.getItemWidth() / 2;
            let collisionMinY = beaconCenterY - beaconItem.getItemHeight() / 2;
            // To lower part of the bar should not trigger beacon movement to be able to scroll the bar!
            let collisionMaxY = beaconCenterY;
            return xInImage >= collisionMinX && xInImage <= collisionMaxX &&
                yInImage >= collisionMinY && yInImage <= collisionMaxY;
        }
        /**
         * Returns the difference vector of the beacon's anchor point and the mouse in world coordinates.
         * This is equal to the touch point on the beacon in the beacon's local coordinate system.
         * @param beaconXInTexels
         * @param beaconYInTexels
         * @param mouseXInScreen
         * @param mouseYInScreen
         */
        getMovingPointInDeviceLocalTexels(beaconXInTexels, beaconYInTexels, mouseXInScreen, mouseYInScreen) {
            let floorplanLayer = this.building.getCurrentFloor().getFloorplanLayer();
            let mouseInTx = floorplanLayer.getTexelsFromScreenPixels(new PIXI.Point(mouseXInScreen, mouseYInScreen));
            let movingPointInDeviceLocalTx = new PIXI.Point(mouseInTx.x - beaconXInTexels, mouseInTx.y - beaconYInTexels);
            return movingPointInDeviceLocalTx;
        }
        // @Override
        onTouchStart(x, y, touchIndex) {
            let handled = super.onTouchStart(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesBeacon) {
                    this.onPanningStart(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            let handled = super.onTouchMove(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesBeacon) {
                    this.onPanningMove(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            let handled = super.onTouchEnd(x, y, touchIndex);
            if (!handled) {
                // Block touch events inside the bar
                if (this.isPanning() || this.userMovesBeacon) {
                    this.onPanningEnd(x, y);
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return handled;
            }
        }
        // @Override
        onPanningMove(x, y) {
            let handled = super.onPanningMove(x, y);
            if (handled) {
                return true;
            }
            if (this.userMovesBeacon) {
                if (this.movingBeaconItem.getBeacon().getScene()) {
                    if (this.touchPointInsideBar(x, y)) {
                        // If beacon was in world before, move it to the bar's scene.
                        if (this.beaconIsInWorld(this.movingBeaconItem.getBeacon())) {
                            this.notifyObservers("onBeaconLeftWorld", []);
                            this.moveBeaconToStock(x, y, this.movingBeaconItem);
                        }
                        this.setBeaconItemPositionInBar(this.movingBeaconItem, x, y);
                        this.repositionItemsIfNecessary();
                    }
                    else {
                        // If beacon was in bar before, move it to the world scene.
                        if (this.beaconIsInBar(this.movingBeaconItem.getBeacon())) {
                            this.notifyObservers("onBeaconEnteredWorld", []);
                            this.moveBeaconToMap(x, y, this.movingBeaconItem);
                            this.resetItemPositions();
                        }
                        this.setBeaconPositionInMap(this.movingBeaconItem.getBeacon(), x, y);
                    }
                }
                return true;
            }
            else {
                return false;
            }
        }
        touchPointInsideBar(x, y) {
            return this.touchPointInsideContainer(x, y);
        }
        beaconIsInWorld(beacon) {
            return beacon.getScene() === this.world.getScene();
        }
        moveBeaconToStock(x, y, beaconItem) {
            // Add beacon to stock
            let beacon = beaconItem.getBeacon();
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(beacon);
            this.setBeaconItemPositionInBar(beaconItem, x, y);
        }
        setBeaconItemPositionInBar(beaconItem, imageX, imageY) {
            let pointInBar = this.getContentObject().getView().pixi().toLocal(new PIXI.Point(imageX, imageY));
            beaconItem.getView().x = pointInBar.x;
            beaconItem.getView().y = pointInBar.y;
        }
        repositionItemsIfNecessary() {
            // 1. Remove moving beacon item from list
            let index = this.beaconItems.indexOf(this.movingBeaconItem);
            if (index > -1) {
                this.beaconItems.splice(index, 1);
            }
            // 2. Reorder beacon item list
            let itemInserted = false;
            let movingItemX = this.movingBeaconItem.getView().x;
            for (let i = 0; i < this.beaconItems.length; i++) {
                let beaconItem = this.beaconItems[i];
                let currentItemX = beaconItem.getView().x;
                if (currentItemX > movingItemX) {
                    // Insert beacon to this index.
                    this.beaconItems.splice(i, 0, this.movingBeaconItem);
                    itemInserted = true;
                    break;
                }
            }
            // If item was not inserted, it must be the last element in the list
            if (!itemInserted) {
                this.beaconItems.push(this.movingBeaconItem);
            }
            // 3. Reposition the items
            this.resetItemPositions();
        }
        resetItemPositions(animate = true) {
            for (let i = 0; i < this.beaconItems.length; i++) {
                let beaconItem = this.beaconItems[i];
                let position = this.getCurrentBeaconItemPositionForItemWithIndex(i);
                beaconItem.setTargetPosition(position);
                // We do not want to reset the position of the moving beacon item,
                // because the user wants to move it.
                if (this.movingBeaconItem !== beaconItem) {
                    if (animate) {
                        beaconItem.startResetAnimation();
                    }
                    else {
                        beaconItem.resetPosition();
                    }
                }
            }
        }
        beaconIsInBar(beacon) {
            return !this.beaconIsInWorld(beacon);
        }
        moveBeaconToMap(imageX, imageY, beaconItem) {
            let beacon = beaconItem.getBeacon();
            this.building.getCurrentFloor().getDeviceLayer().moveObjectToMap(beacon);
            this.setBeaconPositionInMap(beacon, imageX, imageY);
        }
        setBeaconPositionInMap(beacon, imageX, imageY) {
            let worldCamera = this.world.getScene().getCamera();
            let mouseInScreenPx = new PIXI.Point(imageX, imageY);
            let mouseInTx = worldCamera.getWorldCoordinateFromImagePoint(mouseInScreenPx);
            beacon.getView().x = mouseInTx.x - this.movingPointInDeviceLocalTx.x;
            beacon.getView().y = mouseInTx.y - this.movingPointInDeviceLocalTx.y;
            beacon.updateModelPositionFromViewPosition();
        }
        // @Override
        onPanningEnd(x, y) {
            let handled = super.onPanningEnd(x, y);
            if (handled) {
                return true;
            }
            if (this.userMovesBeacon) {
                if (this.movingBeaconItem.getBeacon().getScene()) {
                    if (this.touchPointInsideBar(x, y)) {
                        this.movingBeaconItem.startResetAnimation();
                    }
                    else {
                        // If beacon was in bar before, move it to the world scene.
                        if (this.beaconIsInBar(this.movingBeaconItem.getBeacon())) {
                            this.moveBeaconToMap(x, y, this.movingBeaconItem);
                        }
                        this.setBeaconPositionInMap(this.movingBeaconItem.getBeacon(), x, y);
                        // Finally we need to ensure, that the device is not outside the world.
                        this.movingBeaconItem.getBeacon().updateModelPositionFromViewPositionAndConsiderWorldConstraints();
                    }
                }
                this.userMovesBeacon = false;
                this.notifyObservers("onObjectMoveStopped", []);
                this.movingBeaconItem = null;
                this.movingPointInDeviceLocalTx = null;
                return true;
            }
            else {
                return false;
            }
        }
        // Resize - Event handling
        // @Override
        onResize() {
            super.onResize();
            // Relayout scrollable view
            this.setSize(this.world.getScene().getCamera().getScreenWidth(), BeaconItem_1.BeaconItem.ITEM_HEIGHT);
            // Relayout action bar views
            this.layoutView();
        }
    }
    exports.BeaconBar = BeaconBar;
});
define("src/engine/input/InputEvent", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Represents a generic input event that can be recycled
    // to avoid memory allocations when used in an input event pool.
    class InputEvent {
        constructor() {
            this.values = [0.0, 0.0, 0.0, 0.0, 0.0];
        }
        // Setters
        setConfiguration(gesture, action, values) {
            this.gesture = gesture;
            this.action = action;
            this.timestampInMs = Date.now();
            this.values = values;
        }
        // Getters
        getGesture() {
            return this.gesture;
        }
        getAction() {
            return this.action;
        }
        getTimestampInMs() {
            return this.timestampInMs;
        }
        getValues() {
            return this.values;
        }
    }
    exports.InputEvent = InputEvent;
    (function (InputEvent) {
        let Gesture;
        (function (Gesture) {
            Gesture[Gesture["MOUSELEAVING"] = 0] = "MOUSELEAVING";
            Gesture[Gesture["HOVERING"] = 1] = "HOVERING";
            Gesture[Gesture["TOUCHING"] = 2] = "TOUCHING";
            Gesture[Gesture["KEYING"] = 3] = "KEYING";
            Gesture[Gesture["WHEELING"] = 4] = "WHEELING";
            Gesture[Gesture["PANNING"] = 5] = "PANNING";
            Gesture[Gesture["PINCHING"] = 6] = "PINCHING";
            Gesture[Gesture["ROTATING"] = 7] = "ROTATING";
            Gesture[Gesture["TAPPING"] = 8] = "TAPPING";
        })(Gesture = InputEvent.Gesture || (InputEvent.Gesture = {}));
        let Action;
        (function (Action) {
            Action[Action["NONE"] = 0] = "NONE";
            Action[Action["STARTED"] = 1] = "STARTED";
            Action[Action["MOVING"] = 2] = "MOVING";
            Action[Action["ENDING"] = 3] = "ENDING";
        })(Action = InputEvent.Action || (InputEvent.Action = {}));
    })(InputEvent = exports.InputEvent || (exports.InputEvent = {}));
});
define("src/engine/input/InputSystem", ["require", "exports", "src/engine/scene/GameObject", "src/engine/input/InputEvent", "src/engine/input/GestureRecognizer", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, GameObject_4, InputEvent_1, GestureRecognizer_3, GraphicsObject_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // The input system receives all input events and
    // pushes them to an input queue. Using the input queue
    // one can obtain all events in a single thread.
    class InputSystem extends GameObject_4.GameObject {
        constructor(environment, htmlCanvasElement) {
            super(environment);
            this.initInteractionView();
            this.initInputPool();
            this.initInputQueue();
            this.registerEvents(htmlCanvasElement);
        }
        initInteractionView() {
            // The input view is the view that captures all input events.
            this.inputView = new GraphicsObject_9.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.layoutInputView();
            this.inputView.alpha = 0;
            this.inputView.interactive = true;
        }
        layoutInputView() {
            this.inputView.clear();
            this.inputView.beginFill(0xffffff);
            this.inputView.drawRect(0, 0, this.getEnvironment().canvasSize.x, this.getEnvironment().canvasSize.y);
            this.inputView.endFill();
        }
        initInputPool() {
            this.inputPool = new Array();
            // Fill the pool with a fixed numer of input events.
            for (let i = 0; i < InputSystem.QUEUE_CAPACITY; i++) {
                this.inputPool.push(new InputEvent_1.InputEvent());
            }
        }
        initInputQueue() {
            this.inputQueue = new Array();
        }
        registerEvents(htmlCanvasElement) {
            this.gestureRecognizer = new GestureRecognizer_3.GestureRecognizer(this.inputView, htmlCanvasElement);
            this.gestureRecognizer.callbackReceiver = this;
            this.gestureRecognizer.onMouseInCallbacks.push(this.mouseIn);
            this.gestureRecognizer.onMouseOutCallbacks.push(this.mouseOut);
            this.gestureRecognizer.onMouseStartedCallbacks.push(this.mouseStarted);
            this.gestureRecognizer.onMouseMovedCallbacks.push(this.mouseMoved);
            this.gestureRecognizer.onMouseStoppedCallbacks.push(this.mouseStopped);
            this.gestureRecognizer.onTouchStartedCallbacks.push(this.touchStarted);
            this.gestureRecognizer.onTouchMovedCallbacks.push(this.touchMoved);
            this.gestureRecognizer.onTouchEndCallbacks.push(this.touchEnded);
            this.gestureRecognizer.onKeyDownCallbacks.push(this.keyDown);
            this.gestureRecognizer.onKeyUpCallbacks.push(this.keyUp);
            this.gestureRecognizer.onMouseWheelCallbacks.push(this.mouseWheel);
            this.gestureRecognizer.onPanningStartedCallbacks.push(this.panningStarted);
            this.gestureRecognizer.onPanningMoveCallbacks.push(this.panningMoved);
            this.gestureRecognizer.onPanningEndCallbacks.push(this.panningEnded);
            this.gestureRecognizer.onPinchingStartedCallbacks.push(this.pinchingStarted);
            this.gestureRecognizer.onPinchingMoveCallbacks.push(this.pinchingMoved);
            this.gestureRecognizer.onPinchingEndCallbacks.push(this.pinchingEnded);
            this.gestureRecognizer.onRotatingStartedCallbacks.push(this.rotatingStarted);
            this.gestureRecognizer.onRotatingMoveCallbacks.push(this.rotatingMoved);
            this.gestureRecognizer.onRotatingEndCallbacks.push(this.rotatingEnded);
            this.gestureRecognizer.onTapCallbacks.push(this.tapped);
        }
        mouseIn(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.MOUSELEAVING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        mouseOut(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.MOUSELEAVING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        mouseStarted(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        mouseMoved(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        mouseStopped(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.HOVERING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        touchStarted(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        touchMoved(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        touchEnded(x, y, touchIndex) {
            let values = [x, y, touchIndex];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TOUCHING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        keyDown(keyCode) {
            let values = [keyCode];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.KEYING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        keyUp(keyCode) {
            let values = [keyCode];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.KEYING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        mouseWheel(delta, mouseX, mouseY) {
            let values = [delta, mouseX, mouseY];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.WHEELING, InputEvent_1.InputEvent.Action.NONE, values);
        }
        panningStarted(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        panningMoved(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        panningEnded(x, y) {
            let values = [x, y];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PANNING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        pinchingStarted(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        pinchingMoved(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        pinchingEnded(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.PINCHING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        rotatingStarted(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.STARTED, values);
        }
        rotatingMoved(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.MOVING, values);
        }
        rotatingEnded(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            let values = [rotation, pinchFocusX, pinchFocusY, distance, scaleFactor];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.ROTATING, InputEvent_1.InputEvent.Action.ENDING, values);
        }
        tapped(x, y, numTaps) {
            let values = [x, y, numTaps];
            this.addInputEvent(InputEvent_1.InputEvent.Gesture.TAPPING, InputEvent_1.InputEvent.Action.NONE, values);
        }
        addInputEvent(gesture, action, values) {
            // Reuse input event using object pool.
            let inputEvent = this.inputPool.pop();
            if (inputEvent == null) {
                // Queue is full. Hence, we discard this input event.
                return;
            }
            // Configure the generic input event with the specific values.
            inputEvent.setConfiguration(gesture, action, values);
            // Insert input event to the input queue.
            this.inputQueue.unshift(inputEvent);
        }
        peekEvent() {
            return this.inputQueue[this.inputQueue.length - 1];
        }
        popEvent() {
            // Removes the event from the input queue and adds it
            // to the input pool to make it reusable.
            let inputEvent = this.inputQueue.pop();
            this.inputPool.push(inputEvent);
        }
        update(lastFrametime) {
            super.update(lastFrametime);
            // We need to update the gesture recognizer to
            // correctly recognize time based gestures.
            this.gestureRecognizer.update();
        }
        // Resizing
        // @Override
        onResize() {
            this.layoutInputView();
        }
        // Getters and setters
        getView() {
            return this.inputView;
        }
    }
    // Constants
    InputSystem.QUEUE_CAPACITY = 128;
    exports.InputSystem = InputSystem;
});
define("src/engine/Game", ["require", "exports", "src/engine/input/InputSystem", "src/engine/input/InputEvent", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, InputSystem_1, InputEvent_2, GraphicsObject_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Game {
        // Initialization
        constructor() {
            // Game loop
            this.running = false;
            this.paused = false;
            this.lastTimestampInMs = -1;
            this.useFixedTimesteps = false;
            this.extrapolationEnabled = false;
            this.lag = 0.0;
            this.MS_PER_UPDATE = 1000 / 60;
            // Sceneless game objects
            this.gameObjects = new Array();
            // Scene
            this.scenes = new Array();
            // Nothing to do
        }
        initEngine(environment, parentHtmlElement) {
            this.environment = environment;
            this.initRenderer(parentHtmlElement);
            this.initInputSystem();
            this.initLoadingScreen();
            this.initResources();
        }
        initRenderer(parentHtmlElement) {
            // Do not log pixi logo to the console.
            PIXI.utils.skipHello();
            // Creates the renderer and determines, whether to use WebGL or Canvas.
            // On Retina monitors, sprites look sometimes blurry. Thus, we
            // render it in the double size and rescale it to get sharp edges
            // (resolution, autoResize and PIXI.Resolution).
            let options = {
                antialias: true,
                resolution: this.environment.pixelRatio < 1 ? 1.0 : this.environment.pixelRatio || 1,
                autoResize: true,
            };
            this.renderer = PIXI.autoDetectRenderer(this.environment.canvasSize.x, this.environment.canvasSize.y, options);
            this.renderer.backgroundColor = 0xffffff;
            // Adds the render view to the DOM.
            parentHtmlElement.appendChild(this.renderer.view);
            // We use a custom WebGL shader for rendering sprites to
            // get sharper images when using mipmapping. More precisely,
            // we change the LOD bias to 1.0. When
            // https://github.com/pixijs/pixi.js/issues/2277
            // has been merged to master, the custom shader implementation
            // can be replaced by the default one.
        }
        initInputSystem() {
            this.inputSystem = new InputSystem_1.InputSystem(this.environment, this.renderer.view);
            this.addScenelessGameObject(this.inputSystem);
        }
        initLoadingScreen() {
            let loadingScreenView = new GraphicsObject_10.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            loadingScreenView.beginFill(0xffffff);
            loadingScreenView.drawRect(0, 0, this.getCanvasWidth(), this.getCanvasHeight());
            loadingScreenView.endFill();
            this.renderer.clearBeforeRender = true;
            this.renderer.render(loadingScreenView.pixi());
        }
        initResources() {
            let that = this;
            let loader = PIXI.loader;
            if (loader) {
                PIXI.loader.reset();
                loader = this.preloadResources();
                loader.load(function () {
                    that.initGame();
                });
            }
            else {
                setTimeout(function () {
                    that.initGame();
                }, 0);
            }
        }
        reloadGame() {
            this.destroyGame();
            this.initGame();
        }
        destroyGame() {
            this.destroyScenes();
        }
        initGame() {
            this.createScenes();
            this.initializeScenes();
            this.initializeScenelessObjects();
            this.updateLocalization();
            // onInitialized must be called after all other initializations, but notice it can stop rendering immediately
            let wasRunning = this.running;
            this.running = true;
            this.onInitialized();
            if (!wasRunning && this.running) {
                this.gameLoop();
            }
        }
        addScenelessGameObject(gameObject) {
            this.gameObjects.push(gameObject);
        }
        addScene(scene) {
            this.scenes.push(scene);
        }
        removeScene(scene) {
            let index = this.scenes.indexOf(scene);
            if (index > -1) {
                this.scenes.splice(index, 1);
            }
        }
        initializeScenes() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.initialize();
            }
        }
        initializeScenelessObjects() {
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.initialize();
            }
        }
        updateLocalization() {
            // Scene game objects
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.changeLocalization(this.environment.localization);
                scene.onLocalizationChanged();
            }
            // Sceneless game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.changeLocalization(this.environment.localization);
                gameObject.onLocalizationChanged();
            }
        }
        /**
         * Will be called, before game loop is started
         */
        onInitialized() {
            // Empty default implementation.
        }
        // Game loop
        gameLoop() {
            if (this.running) {
                // Loop this function 60 times per second
                window.requestAnimationFrame(() => {
                    this.gameLoop();
                });
                if (!this.paused) {
                    let frametimeInMs = this.computeFrametime();
                    this.processInput();
                    if (this.useFixedTimesteps) {
                        this.fixedTimestepCycle(frametimeInMs);
                    }
                    else {
                        this.variableTimestepCycle(frametimeInMs);
                    }
                }
            }
        }
        computeFrametime() {
            let nowInMs = Date.now();
            if (this.lastTimestampInMs === -1) {
                // Initial frametime = 16 ms
                this.lastTimestampInMs = nowInMs;
                return (1.0 / 60) * 1000;
            }
            else {
                let frametimeInMs = nowInMs - this.lastTimestampInMs;
                this.lastTimestampInMs = nowInMs;
                return frametimeInMs;
            }
        }
        processInput() {
            let event = this.inputSystem.peekEvent();
            while (event != null) {
                this.inputSystem.popEvent();
                this.dispatchInputEvent(event);
                event = this.inputSystem.peekEvent();
            }
        }
        dispatchInputEvent(inputEvent) {
            let gesture = inputEvent.getGesture();
            if (gesture === InputEvent_2.InputEvent.Gesture.MOUSELEAVING) {
                this.handleMouseLeavingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.HOVERING) {
                this.handleHoveringInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.TOUCHING) {
                this.handleTouchingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.KEYING) {
                this.handleKeyingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.WHEELING) {
                this.handleWheelingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.PANNING) {
                this.handlePanningInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.PINCHING) {
                this.handlePinchingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.ROTATING) {
                this.handleRotatingInputEvent(inputEvent);
            }
            else if (gesture === InputEvent_2.InputEvent.Gesture.TAPPING) {
                this.handleTappingInputEvent(inputEvent);
            }
        }
        handleMouseLeavingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onMouseIn", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onMouseOut", inputEvent.getValues());
            }
        }
        handleHoveringInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onMouseStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onMouseMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onMouseEnd", inputEvent.getValues());
            }
        }
        handleTouchingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onTouchStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onTouchMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onTouchEnd", inputEvent.getValues());
            }
        }
        handleKeyingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onKeyDown", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onKeyUp", inputEvent.getValues());
            }
        }
        handleWheelingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.NONE) {
                this.handleInputEvent("onMouseWheel", inputEvent.getValues());
            }
        }
        handlePanningInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onPanningStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onPanningMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onPanningEnd", inputEvent.getValues());
            }
        }
        handlePinchingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onPinchingStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onPinchingMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onPinchingEnd", inputEvent.getValues());
            }
        }
        handleRotatingInputEvent(inputEvent) {
            let action = inputEvent.getAction();
            if (action === InputEvent_2.InputEvent.Action.STARTED) {
                this.handleInputEvent("onRotatingStart", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.MOVING) {
                this.handleInputEvent("onRotatingMove", inputEvent.getValues());
            }
            else if (action === InputEvent_2.InputEvent.Action.ENDING) {
                this.handleInputEvent("onRotatingEnd", inputEvent.getValues());
            }
        }
        handleTappingInputEvent(inputEvent) {
            this.handleInputEvent("onTap", inputEvent.getValues());
        }
        handleInputEvent(handlerName, values) {
            // Let stateless game objects handle the input event.
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                let handled = gameObject[handlerName].apply(gameObject, values);
                if (handled) {
                    return;
                }
            }
            // Let scenes handle the input event.
            // Iterate backwards to the scenes. The scenes
            // that will be displayed in front will receive
            // the input events first. If they handle the input event,
            // the subsequent scenes will not have the possibility
            // to handle the event.
            for (let i = this.scenes.length - 1; i >= 0; i--) {
                let scene = this.scenes[i];
                let handled = scene.handleInputEvent(handlerName, values);
                if (handled) {
                    return;
                }
            }
        }
        fixedTimestepCycle(frametimeInMs) {
            this.lag += frametimeInMs;
            this.lag = Math.min(this.lag, this.MS_PER_UPDATE * 5);
            while (this.lag >= this.MS_PER_UPDATE) {
                if (this.extrapolationEnabled && (this.lag - this.MS_PER_UPDATE) < this.MS_PER_UPDATE) {
                    this.rememberPreviousPositions();
                }
                this.update(frametimeInMs);
                this.lag -= this.MS_PER_UPDATE;
            }
            if (this.extrapolationEnabled) {
                let lagOffset = this.lag / this.MS_PER_UPDATE;
                this.rememberCurrentPositions();
                this.extrapolate(lagOffset);
                this.render();
                this.resetToCurrentPositions();
            }
            else {
                this.render();
            }
        }
        variableTimestepCycle(frametimeInMs) {
            this.update(frametimeInMs);
            this.render();
        }
        rememberPreviousPositions() {
            // Remember the previous positions to be able to extrapolate
            // the positions to reduce lag problems occuring when
            // a game loop with fixed timesteps is used.
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.previousX = displayObject.x;
                    displayObject.previousY = displayObject.y;
                    displayObject.previousScaleX = displayObject.scale.x;
                    displayObject.previousScaleY = displayObject.scale.y;
                }
            }
        }
        update(lastFrametime) {
            // Update game
            this.onUpdate(lastFrametime);
            // Update scenes
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                scene.update(lastFrametime);
            }
            // Update game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.update(lastFrametime);
            }
        }
        // @Override
        onUpdate(lastFrametime) {
            // Empty default implementation
        }
        rememberCurrentPositions() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.currentX = displayObject.x;
                    displayObject.currentY = displayObject.y;
                    displayObject.currentScaleX = displayObject.scale.x;
                    displayObject.currentScaleY = displayObject.scale.y;
                }
            }
        }
        extrapolate(lagOffset) {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    if ("previousX" in displayObject) {
                        displayObject.x
                            = displayObject.x + ((displayObject.x - displayObject.previousX) * lagOffset);
                    }
                    if ("previousY" in displayObject) {
                        displayObject.y
                            = displayObject.y + ((displayObject.y - displayObject.previousY) * lagOffset);
                    }
                    if ("previousScaleX" in displayObject) {
                        displayObject.scale.x
                            = displayObject.scale.x + ((displayObject.scale.x - displayObject.previousScaleX) * lagOffset);
                    }
                    if ("previousScaleY" in displayObject) {
                        displayObject.scale.y
                            = displayObject.scale.y + ((displayObject.scale.y - displayObject.previousScaleY) * lagOffset);
                    }
                }
            }
        }
        render() {
            // If no render object set the dirty flag to true, the rendering stage
            // will not be triggered to minimize the CPU and GPU utilization.
            // This slient rendering loop strategy is especially important for mobile devices,
            // if the scene is static most of the time.
            if (this.getEnvironment().renderingEnvironment.dirty) {
                // Renders the stage on the renderer's canvas.
                this.renderer.clearBeforeRender = true;
                for (let i = 0; i < this.scenes.length; i++) {
                    let scene = this.scenes[i];
                    let roundPixels = scene.isRoundPixels();
                    this.renderer.roundPixels = roundPixels;
                    this.renderer.render(scene.getSceneGraph().getRenderView().pixi());
                    this.renderer.clearBeforeRender = false;
                }
                // In order to get input events, we have to render
                // the invisible input view.
                this.renderer.render(this.inputSystem.getView().pixi());
            }
            this.getEnvironment().renderingEnvironment.dirty = false;
        }
        resetToCurrentPositions() {
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    let displayObject = sceneObject.getView();
                    displayObject.x = displayObject.currentX;
                    displayObject.y = displayObject.currentY;
                    displayObject.scale.x = displayObject.currentScaleX;
                    displayObject.scale.y = displayObject.currentScaleY;
                }
            }
        }
        // Scene events
        /**
         * Publishes events to each game object.
         * @param callbackName The callback should start with "on". Please do not
         * use the same name than the caller to avoid endless recursions.
         * @param args The arguments that will be passed to the subscriber.
         */
        publishSceneEvent(callbackName, args) {
            // Publish event on game
            if (typeof this["" + callbackName] === "function") {
                this["" + callbackName].apply(this, args);
            }
            // Update scenes
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                for (let j = 0; j < scene.getSceneObjects().length; j++) {
                    let sceneObject = scene.getSceneObjects()[j];
                    if (typeof sceneObject["" + callbackName] === "function") {
                        sceneObject["" + callbackName].apply(sceneObject, args);
                    }
                }
            }
            // Update game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                if (typeof gameObject["" + callbackName] === "function") {
                    gameObject["" + callbackName].apply(gameObject, args);
                }
            }
        }
        // Destruction
        destroy() {
            // Stop game
            this.stopGame();
            // Destroy all scene graphs with their corresponding display objects
            for (let i = 0; i < this.scenes.length; i++) {
                let scene = this.scenes[i];
                let rootView = scene.getSceneGraph().getView();
                rootView.destroy(true);
            }
            this.renderer.destroy(true);
            this.destroyAllTextures();
        }
        destroyAllTextures() {
            // Reset the loader
            PIXI.loader.reset();
            // Destroy texture cache
            PIXI.utils.destroyTextureCache();
        }
        stopGame() {
            this.running = false;
        }
        // Rendering
        /**
         * Resizes the game to the specified size.
         */
        setCanvasSize(widthInPx, heightInPx) {
            this.environment.canvasSize.x = widthInPx;
            this.environment.canvasSize.y = heightInPx;
            this.resize();
        }
        resize() {
            // Resize canvas
            this.renderer.resize(this.environment.canvasSize.x, this.environment.canvasSize.y);
            // Stateless game objects
            for (let i = 0; i < this.gameObjects.length; i++) {
                let gameObject = this.gameObjects[i];
                gameObject.setCanvasSizeInPx(this.environment.canvasSize.x, this.environment.canvasSize.y);
                gameObject.onResize();
            }
            // Scene objects
            for (let i = this.scenes.length - 1; i >= 0; i--) {
                let scene = this.scenes[i];
                scene.handleResizeEvent(this.environment.canvasSize.x, this.environment.canvasSize.y);
            }
        }
        // State
        pause() {
            this.paused = true;
        }
        resume() {
            this.paused = false;
        }
        // Getters and setters
        getRenderer() {
            return this.renderer;
        }
        getEnvironment() {
            return this.environment;
        }
        getCanvasWidth() {
            return this.environment.canvasSize.x;
        }
        getCanvasHeight() {
            return this.environment.canvasSize.y;
        }
        getInputSystem() {
            return this.inputSystem;
        }
        getLocalization() {
            return this.environment.localization;
        }
        setLocalization(localization) {
            this.environment.localization = localization;
            this.updateLocalization();
        }
    }
    exports.Game = Game;
});
define("src/map/view/hud/Hud", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Hud extends Layer_7.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
        }
        // @Override
        initialize() {
            super.initialize();
            // Use pixel alignment for all objects in th HUD.
            this.getScene().setRoundPixels(true);
        }
    }
    exports.Hud = Hud;
});
define("src/map/FruityMap", ["require", "exports", "src/engine/Game", "src/engine/scene/Scene", "src/map/view/world/objects/WorldCamera", "src/map/view/world/World", "src/map/view/hud/Hud", "src/engine/animation/Animation", "src/engine/animation/LinearInterpolator"], function (require, exports, Game_1, Scene_1, WorldCamera_2, World_1, Hud_1, Animation_9, LinearInterpolator_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FruityMap extends Game_1.Game {
        // Initialization
        constructor(options, environment, initializedCallback) {
            super();
            // Animation
            this.animation = new Animation_9.Animation(new LinearInterpolator_8.LinearInterpolator());
            this.animationPaused = false;
            // Observation
            this.initializedCallback = null;
            this.config = options;
            this.sceneEnvironment = environment.scene;
            this.imageResources = options.preloadingImages;
            this.initializedCallback = initializedCallback;
            this.initEngine(this.sceneEnvironment, options.parentHtmlElement);
            this.preventDefaultEventBehaviour();
        }
        preventDefaultEventBehaviour() {
            this.preventMouseWheelEventDefaultBehaviour();
            this.preventKeyDefaultBehaviour();
        }
        preventMouseWheelEventDefaultBehaviour() {
            let handleMouseWheelEvent = function (e) {
                if (e.altKey || e.shiftKey || e.ctrlKey || window.macKeys.cmdKey) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };
            let canvasElement = this.getRenderer().view;
            if (canvasElement.addEventListener) {
                // IE9, Chrome, Safari, Opera
                canvasElement.addEventListener("mousewheel", handleMouseWheelEvent, false);
                // Firefox
                canvasElement.addEventListener("DOMMouseScroll", handleMouseWheelEvent, false);
            }
            else {
                // IE 6/7/8
                canvasElement.attachEvent("onmousewheel", handleMouseWheelEvent);
            }
        }
        preventKeyDefaultBehaviour() {
            window.addEventListener("keydown", function (e) {
                if (document.activeElement === window.document.body) {
                    let ONE_KEYCODE = 48;
                    let NINE_KEYCODE = 57;
                    if (e.keyCode >= ONE_KEYCODE && e.keyCode <= NINE_KEYCODE) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }, false);
        }
        // @Override
        preloadResources() {
            let options = {
                crossOrigin: false,
                // Forces the loader to load URLs without extension as PNG.
                loadType: PIXI.loaders.Resource.LOAD_TYPE.IMAGE,
                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.BLOB,
            };
            if (this.imageResources.length > 0) {
                // Preload all resources
                for (let i = 0; i < this.imageResources.length; i++) {
                    let image = this.imageResources[i];
                    let resourceName = image.resourceName;
                    let url = image.url;
                    if (PIXI.utils.TextureCache[resourceName]) {
                        PIXI.utils.TextureCache[resourceName].destroy(true);
                    }
                    PIXI.loader.add(resourceName, url, options);
                }
                return PIXI.loader;
            }
            else {
                return null;
            }
        }
        // @Override
        createScenes() {
            // World scene
            this.worldScene = new Scene_1.Scene(this.sceneEnvironment);
            this.worldCamera = new WorldCamera_2.WorldCamera(this.config.camera, this.sceneEnvironment);
            this.worldScene.setCamera(this.worldCamera);
            this.world = new World_1.World(this.sceneEnvironment);
            this.worldScene.addSceneObject(this.world);
            this.addScene(this.worldScene);
            // HUD scene
            this.hudScene = new Scene_1.Scene(this.sceneEnvironment);
            this.hud = new Hud_1.Hud(this.sceneEnvironment);
            this.hudScene.addSceneObject(this.hud);
            this.addScene(this.hudScene);
        }
        // @Override
        destroyScenes() {
            // HUD scene
            this.removeScene(this.hudScene);
            this.hudScene = null;
            // World Scene
            this.removeScene(this.worldScene);
            this.worldScene = null;
            this.worldCamera = null;
        }
        // @Override
        onInitialized() {
            if (this.initializedCallback != null) {
                this.initializedCallback();
                this.initializedCallback = null;
            }
        }
        // Animation
        setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback) {
            this.animationConfiguration = {
                startTimeInSec: startTimeInSec,
                endTimeInSec: endTimeInSec,
                durationInMs: durationInMs,
                progressCallback: progressCallback,
            };
        }
        getAnimationConfiguration() {
            return this.animationConfiguration;
        }
        startAnimation() {
            // Animation
            let startValue = 0.0;
            let endValue = 1.0;
            let delayInMs = 0.0;
            this.animation.start(startValue, endValue, this.animationConfiguration.durationInMs, delayInMs);
            // Pause state
            this.animationPaused = false;
            // Layer state
            this.setAnimationModeEnabled(true);
            this.updateAnimationFrameWithProgress(0);
        }
        stopAnimation() {
            // Animation
            this.animation.stop();
            // Pause state
            this.animationPaused = false;
            // Layer state
            this.setAnimationModeEnabled(false);
        }
        pauseAnimation() {
            // Pause state
            this.animationPaused = true;
            // Layer state
            let elapsedTimeInMs = this.animation.getElapsedTimeInMs();
            let progress = elapsedTimeInMs / this.animationConfiguration.durationInMs;
            this.updateAnimationFrameWithProgress(progress);
        }
        resumeAnimation() {
            // Pause state
            this.animationPaused = false;
            // Layer state
            let elapsedTimeInMs = this.animation.getElapsedTimeInMs();
            let progress = elapsedTimeInMs / this.animationConfiguration.durationInMs;
            this.updateAnimationFrameWithProgress(progress);
        }
        seekAnimation(progress) {
            if (progress === 1) {
                this.stopAnimation();
            }
            else {
                // Animation
                if (!this.animation.isCurrentlyAnimating()) {
                    this.startAnimation();
                }
                let elapsedTimeInMs = progress * this.animationConfiguration.durationInMs;
                this.animation.setElapsedTimeInMs(elapsedTimeInMs);
                // Pause state
                this.animationPaused = true;
                // Layer state
                this.setAnimationModeEnabled(true);
                this.updateAnimationFrameWithProgress(progress);
            }
        }
        setAnimationModeEnabled(enabled) {
            this.publishSceneEvent("onAnimationModeEnabled", [enabled]);
        }
        updateAnimationFrameWithProgress(progress) {
            let timeInSec = this.animationConfiguration.startTimeInSec
                + (progress * (this.animationConfiguration.endTimeInSec - this.animationConfiguration.startTimeInSec));
            this.publishSceneEvent("onUpdateAnimationFrame", [timeInSec]);
        }
        // Updating
        // @Override
        onUpdate(lastFrametime) {
            if (this.animation.isCurrentlyAnimating()) {
                if (!this.animationPaused) {
                    let progress = this.animation.getValue(lastFrametime);
                    if (this.animationConfiguration.progressCallback != null) {
                        let start = this.animationConfiguration.startTimeInSec;
                        let end = this.animationConfiguration.endTimeInSec;
                        let currentTimeInSec = start + progress * (end - start);
                        this.animationConfiguration.progressCallback(progress, currentTimeInSec);
                    }
                    this.updateAnimationFrameWithProgress(progress);
                    // We explicitly call stop, to ensure that the stop callback will
                    // be called after the last animation update has completed.
                    if (progress === 1) {
                        this.stopAnimation();
                    }
                }
            }
        }
        // Resizing
        // @Override
        resize() {
            let oldCameraFrustum = this.worldCamera.getFrustum();
            this.worldCamera.setScreenWidth(this.getEnvironment().canvasSize.x);
            this.worldCamera.setScreenHeight(this.getEnvironment().canvasSize.y);
            this.worldCamera.setFrustum(oldCameraFrustum);
            this.worldCamera.resolveCollisionsWithWorldBorders();
            super.resize();
        }
        // Getters and setters
        getWorld() {
            return this.world;
        }
        getHud() {
            return this.hud;
        }
        getEnvironment() {
            return this.sceneEnvironment;
        }
    }
    exports.FruityMap = FruityMap;
    (function (FruityMap) {
        class Options {
            constructor() {
                this.camera = new WorldCamera_2.WorldCamera.Config();
            }
        }
        FruityMap.Options = Options;
        class Environment {
        }
        FruityMap.Environment = Environment;
    })(FruityMap = exports.FruityMap || (exports.FruityMap = {}));
});
define("src/app/relution/view/hud/selectionLayer/SelectionLayer", ["require", "exports", "src/map/view/Layer", "src/map/utils/DeviceUtils", "src/engine/input/GestureRecognizer", "src/engine/general/AABB", "src/app/relution/utils/MouseUtils", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, Layer_8, DeviceUtils_14, GestureRecognizer_4, AABB_9, MouseUtils_2, GraphicsObject_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A layer that makes relution world objects selectable.
     *
     * @export
     * @class SelectionLayer
     * @extends {Layer}
     */
    class SelectionLayer extends Layer_8.Layer {
        // Initialization
        constructor(config, environment, building) {
            super(environment);
            this.startX = 0;
            this.startY = 0;
            this.currentX = 0;
            this.currentY = 0;
            this.userIsSelecting = false;
            this.onlyTapSelectionCurrentlyAllowed = false;
            // Observing
            this.observers = new Array();
            this.selectionLayerConfig = config;
            this.initModel(building);
            this.initView();
        }
        initModel(building) {
            this.building = building;
        }
        initView() {
            this.selectionRectangle = new GraphicsObject_11.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.selectionRectangle.visible = false;
            this.selectionRectangle.alpha = 0.25;
            this.getView().addChild(this.selectionRectangle);
        }
        // Observing
        addObserver(observer) {
            this.observers.push(observer);
        }
        removeObserver(observer) {
            if (!observer || !this.observers || !this.observers.length) {
                return false;
            }
            let index = this.observers.indexOf(observer);
            if (index !== -1) {
                this.observers.splice(index, 1);
            }
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Key Event-Handling
        // @Override
        onKeyUp(keyCode) {
            if (this.selectionLayerConfig.enabled) {
                if (keyCode === SelectionLayer.DEL_KEY_CODE) {
                    if (this.isDeleteSelectedBeaconsAllowed()) {
                        this.deleteSelectedBeacons();
                    }
                }
            }
            return false;
        }
        deleteSelectedBeacons() {
            let beacons = this.building.getCurrentFloor().getDeviceLayer().getVisibleBeaconsOnMap();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (beacon.isSelected()) {
                    this.building.getCurrentFloor().getDeviceLayer().moveObjectToStock(beacon);
                }
            }
        }
        // Mouse Event-Handling
        // @Override
        onMouseMove(x, y) {
            if (this.selectionLayerConfig.enabled) {
                this.showOrHideHandMouseCursor(x, y);
            }
            return false;
        }
        showOrHideHandMouseCursor(x, y) {
            let object = this.building.getCurrentFloor().getCollidingObject(x, y);
            if (object != null) {
                if (MouseUtils_2.MouseUtils.isDefaultCursorStyle()) {
                    MouseUtils_2.MouseUtils.changeToHandCursorStyle();
                }
            }
            else {
                if (MouseUtils_2.MouseUtils.isHandCursorStyle()) {
                    MouseUtils_2.MouseUtils.changeToDefaultCursorStyle();
                }
            }
        }
        // @Override
        onTouchStart(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (!DeviceUtils_14.DeviceUtils.isMobileDevice() && !GestureRecognizer_4.GestureRecognizer.isCtrlPressed()) {
                    if (this.selectionCanBeStartedFromPoint(x, y)) {
                        this.onSelectionRectangleStart(x, y);
                        this.onlyTapSelectionCurrentlyAllowed = false;
                        return true;
                    }
                    else {
                        this.onSelectionRectangleStart(x, y);
                        this.onlyTapSelectionCurrentlyAllowed = true;
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        onSelectionRectangleStart(x, y) {
            this.userIsSelecting = true;
            this.startX = x;
            this.startY = y;
            this.currentX = x;
            this.currentY = y;
            this.redrawSelectionRectangle();
            this.selectionRectangle.visible = true;
        }
        selectionCanBeStartedFromPoint(x, y) {
            let object = this.building.getCurrentFloor().getCollidingObject(x, y);
            if (object !== null) {
                let objectLayer = this.getLayerForObject(object);
                return !objectLayer.isEditModeActive();
            }
            else {
                return true;
            }
        }
        getLayerForObject(object) {
            for (let i = 0; i < this.building.getCurrentFloor().getObjectLayers().length; i++) {
                let layer = this.building.getCurrentFloor().getObjectLayers()[i];
                if (layer.existsObject(object)) {
                    return layer;
                }
            }
            return null;
        }
        // @Override
        onTouchMove(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (this.userIsSelecting) {
                    if (!this.onlyTapSelectionCurrentlyAllowed) {
                        this.onSelectionRectangleMove(x, y);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        onSelectionRectangleMove(x, y) {
            this.currentX = x;
            this.currentY = y;
            this.redrawSelectionRectangle();
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.selectionLayerConfig.enabled) {
                if (this.userIsSelecting) {
                    if (this.onlyTapSelectionCurrentlyAllowed) {
                        // If only tap selection was allowed, check if coordinates have
                        // changed since start. Select the object only, if the coordinates
                        // have not changed.
                        if (this.isTapSelection(x, y)) {
                            this.onSelectionRectangleStop(x, y);
                        }
                        return false;
                    }
                    else {
                        this.onSelectionRectangleStop(x, y);
                        return true;
                    }
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        isTapSelection(x, y) {
            return this.startX === x && this.startY === y;
        }
        onSelectionRectangleStop(x, y) {
            this.currentX = x;
            this.currentY = y;
            if (!GestureRecognizer_4.GestureRecognizer.isShiftPressed()) {
                this.unselectAllObjects();
            }
            let intersectingObjects = this.getIntersectingObjectsOnMap();
            this.invertObjectSelection(intersectingObjects);
            this.resetSelectionRectangle();
        }
        redrawSelectionRectangle() {
            this.selectionRectangle.clear();
            this.selectionRectangle.beginFill(0x0000ff);
            // Draw border
            this.selectionRectangle.lineStyle(2, 0x0000ff);
            // Draw rectangle
            let width = this.currentX - this.startX;
            let height = this.currentY - this.startY;
            // To avoid obscure graphic effects, we do not draw
            // anything, if width or height is zero.
            if (!(width === 0 || height === 0)) {
                this.selectionRectangle.drawRect(this.startX, this.startY, width, height);
            }
            this.selectionRectangle.endFill();
        }
        unselectAllObjects() {
            let visibleObjects = this.building.getCurrentFloor().getAllVisibleObjects();
            for (let i = 0; i < visibleObjects.length; i++) {
                let object = visibleObjects[i];
                object.setSelected(false);
            }
        }
        getIntersectingObjectsOnMap() {
            if (this.selectionRectangleIsPoint()) {
                return this.getObjectsIntersectingWithSelectionPoint();
            }
            else {
                return this.getObjectsIntersectingWithSelectionRectangle();
            }
        }
        selectionRectangleIsPoint() {
            let selectionRectangle = this.getSelectionRectangle();
            return selectionRectangle.min.x === selectionRectangle.max.x && selectionRectangle.min.y === selectionRectangle.max.y;
        }
        getObjectsIntersectingWithSelectionPoint() {
            let intersectingObjects = new Array();
            let selectionRectangle = this.getSelectionRectangle();
            let collidingObject = this.building.getCurrentFloor().getCollidingObject(selectionRectangle.min.x, selectionRectangle.min.y);
            if (collidingObject !== null) {
                intersectingObjects.push(collidingObject);
            }
            return intersectingObjects;
        }
        getObjectsIntersectingWithSelectionRectangle() {
            let intersectingObjects = new Array();
            let visibleObjects = this.building.getCurrentFloor().getAllVisibleObjects();
            for (let i = 0; i < visibleObjects.length; i++) {
                let object = visibleObjects[i];
                if (object.isSelectable()) {
                    if (this.selectionIntersectsObject(object)) {
                        intersectingObjects.push(object);
                    }
                }
            }
            return intersectingObjects;
        }
        selectObjects(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.setSelected(true);
            }
        }
        invertObjectSelection(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.setSelected(!object.isSelected());
            }
        }
        selectionIntersectsObject(object) {
            // TODO: Test the intersection with the whole scene using a bounding volume hierarchy.
            let selectionAabb = this.getSelectionRectangle();
            return object.intersectsAabb(selectionAabb);
        }
        getSelectionRectangle() {
            let minPosX = Math.min(this.startX, this.currentX);
            let minPosY = Math.min(this.startY, this.currentY);
            let maxPosX = Math.max(this.startX, this.currentX);
            let maxPosY = Math.max(this.startY, this.currentY);
            return new AABB_9.AABB(new PIXI.Point(minPosX, minPosY), new PIXI.Point(maxPosX, maxPosY));
        }
        resetSelectionRectangle() {
            this.startX = 0;
            this.startY = 0;
            this.currentX = 0;
            this.currentY = 0;
            this.redrawSelectionRectangle();
            this.selectionRectangle.visible = false;
            this.userIsSelecting = false;
        }
        // Tap Event-Handling
        // @Override
        onTap(x, y, numTaps) {
            if (this.selectionLayerConfig.enabled) {
                if (numTaps === 1) {
                    this.onSelectionRectangleStart(x, y);
                    this.onSelectionRectangleMove(x, y);
                    this.onSelectionRectangleStop(x, y);
                }
                else if (numTaps === 2) {
                    if (this.isObjectDoubleClickAllowed()) {
                        let collidingObject = this.building.getCurrentFloor().getCollidingObject(x, y);
                        if (collidingObject) {
                            this.notifyObservers("onObjectDoubleClicked", [collidingObject]);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                return false;
            }
        }
        // Configuration
        isEnabled() {
            return this.selectionLayerConfig.enabled;
        }
        setEnabled(enabled) {
            this.selectionLayerConfig.enabled = enabled;
        }
        isDeleteSelectedBeaconsAllowed() {
            return this.selectionLayerConfig.deleteSelectedBeaconsAllowed;
        }
        setDeleteSelectedBeaconsAllowed(allowed) {
            this.selectionLayerConfig.deleteSelectedBeaconsAllowed = allowed;
        }
        isObjectDoubleClickAllowed() {
            return this.selectionLayerConfig.objectDoubleClickAllowed;
        }
        setObjectDoubleClickAllowed(allowed) {
            this.selectionLayerConfig.objectDoubleClickAllowed = allowed;
        }
    }
    // Controller
    SelectionLayer.DEL_KEY_CODE = 46;
    exports.SelectionLayer = SelectionLayer;
    (function (SelectionLayer) {
        class Config {
            constructor() {
                /**
                 * True, if this layer shall be enabled
                 *
                 * Default: true
                 */
                this.enabled = true;
                /**
                 * True, if the selected beacons may be removed from the map (e.g. using the delete key).
                 *
                 * Default: false
                 */
                this.deleteSelectedBeaconsAllowed = false;
                /**
                 * True, if double clicking yields a call on all registered observers.
                 *
                 * Default: true
                 */
                this.objectDoubleClickAllowed = true;
            }
        }
        SelectionLayer.Config = Config;
    })(SelectionLayer = exports.SelectionLayer || (exports.SelectionLayer = {}));
});
define("src/app/relution/view/world/RelutionMapWorld", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/world/Building"], function (require, exports, Layer_9, Building_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapWorld extends Layer_9.Layer {
        constructor(config, environment, world, floor) {
            super(environment);
            this.config = config;
            this.world = world;
            this.building = new Building_1.Building(config.building, environment, floor);
            this.addLayer(this.building);
        }
        getBuilding() {
            return this.building;
        }
        getCamera() {
            let worldCamera = this.getScene().getCamera();
            return worldCamera;
        }
        getWorld() {
            return this.world;
        }
    }
    exports.RelutionMapWorld = RelutionMapWorld;
    (function (RelutionMapWorld) {
        class Config {
            constructor() {
                this.building = new Building_1.Building.Config();
            }
        }
        RelutionMapWorld.Config = Config;
    })(RelutionMapWorld = exports.RelutionMapWorld || (exports.RelutionMapWorld = {}));
});
define("src/engine/animation/EaseIn", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class EaseIn {
        constructor(baseInterpolator) {
            this.baseInterpolator = baseInterpolator;
        }
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let easedT = Math.pow(t, 3);
            return this.baseInterpolator.getInterpolationValue(easedT);
        }
    }
    exports.EaseIn = EaseIn;
});
define("src/map/view/hud/layers/navigationLayer/NavigationLayer", ["require", "exports", "src/map/view/Layer", "src/engine/input/GestureRecognizer", "src/map/utils/DeviceUtils", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, Layer_10, GestureRecognizer_5, DeviceUtils_15, EaseIn_1, EaseOut_2, LinearInterpolator_9, GraphicsObject_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class NavigationLayer extends Layer_10.Layer {
        // Initialization
        constructor(config, environment, camera) {
            super(environment);
            // Navigation: Panning
            this.panning = false;
            this.lastPanXs = new Array();
            this.lastPanYs = new Array();
            this.lastPanTimestamps = new Array();
            this.panDelayInMs = 100;
            // Navigation: Pinching
            this.pinching = false;
            this.currentFocus = new PIXI.Point();
            this.currentScaleFactor = 1;
            // Navigation: Rotation
            this.rotating = false;
            this.currentRotation = 0;
            this.currentRotationTimestampInMs = 0;
            // Configuration
            this.interactionEnabled = true;
            this.config = config;
            // The camera to move
            this.camera = camera;
            this.camera.setWorldDimensionsToFitChildren();
            if (this.config.initialFrustum !== null) {
                this.camera.setFrustum(this.config.initialFrustum);
            }
            else {
                this.camera.showWholeWorld();
            }
            // Glass view
            this.navigationView = new GraphicsObject_12.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.relayoutNavigationView();
            this.navigationView.alpha = 0;
            this.getView().addChild(this.navigationView);
        }
        relayoutNavigationView() {
            this.navigationView.clear();
            this.navigationView.beginFill(0xffffff);
            this.navigationView.drawRect(0, 0, this.camera.getScreenWidth(), this.camera.getScreenHeight());
            this.navigationView.endFill();
        }
        onMouseWheel(delta, mouseX, mouseY) {
            if (this.isRotationKeyDown()) {
                // Rotate, when ctrl is pressed
                let rotationAngleInRad = 2 * Math.PI / 360; // 1 degree in rad
                const scalingFactor = 1.00;
                if (delta > 0) {
                    // Wheel up
                    rotationAngleInRad = -rotationAngleInRad;
                    this.onRotatingStart(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingMove(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingEnd(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                }
                else {
                    // Wheel down
                    rotationAngleInRad = +rotationAngleInRad;
                    this.onRotatingStart(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingMove(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                    this.onRotatingEnd(rotationAngleInRad, mouseX, mouseY, 1, scalingFactor);
                }
            }
            else if (this.isZoomingKeyDown()) {
                // Zoom, when ctrl is not pressed.
                const scalingFactor = 1.0 + (Math.abs(delta) * 0.08);
                if (delta > 0) {
                    // Wheel up
                    this.onPinchingStart(mouseX, mouseY, 1, scalingFactor);
                    this.onPinchingMove(mouseX, mouseY, 1, scalingFactor);
                    this.onPinchingEnd(mouseX, mouseY, 1, scalingFactor);
                }
                else {
                    // Wheel down
                    this.onPinchingStart(mouseX, mouseY, 1, 1.0 / scalingFactor);
                    this.onPinchingMove(mouseX, mouseY, 1, 1.0 / scalingFactor);
                    this.onPinchingEnd(mouseX, mouseY, 1, 1.0 / scalingFactor);
                }
            }
            return true;
        }
        isRotationKeyDown() {
            return GestureRecognizer_5.GestureRecognizer.isAltPressed();
        }
        isZoomingKeyDown() {
            return GestureRecognizer_5.GestureRecognizer.isCtrlPressed();
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            // If user is currently navigating using this layer, low level events
            // should not be delegated to lower layers. Instead
            // they will be blocked here.
            if (this.panning || this.pinching || this.rotating) {
                this.onTouchEnd(x, y, touchIndex);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningStart(x, y) {
            if (this.config.panningEnabled) {
                // Panning will only be considered, if no the navigation layer
                // is not disabled and no other key is pressed.
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_15.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        this.panning = true;
                        this.lastPanXs = new Array();
                        this.lastPanYs = new Array();
                        this.lastPanTimestamps = new Array();
                        this.lastPanXs.push(x);
                        this.lastPanYs.push(y);
                        this.lastPanTimestamps.push(Date.now());
                        this.camera.setBordersEnabled(false);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        // @Override
        onPanningMove(x, y) {
            if (this.config.panningEnabled) {
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_15.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        this.lastPanXs.push(x);
                        this.lastPanYs.push(y);
                        this.lastPanTimestamps.push(Date.now());
                        let currentX = this.lastPanXs[this.lastPanXs.length - 1];
                        let currentY = this.lastPanYs[this.lastPanYs.length - 1];
                        let currentTimestamp = this.lastPanTimestamps[this.lastPanTimestamps.length - 1];
                        let lastX = this.lastPanXs[this.lastPanXs.length - 2];
                        let lastY = this.lastPanYs[this.lastPanYs.length - 2];
                        let lastTimestamp = this.lastPanTimestamps[this.lastPanTimestamps.length - 2];
                        let velocity = new PIXI.Point(-(currentX - lastX), -(currentY - lastY));
                        this.camera.translate(velocity);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.config.panningEnabled) {
                if (this.isInteractionEnabled()) {
                    if (DeviceUtils_15.DeviceUtils.isMobileDevice() || this.isPanningKeyDown()) {
                        this.panning = false;
                        // Take current position as first reference
                        let currentX = this.lastPanXs[this.lastPanXs.length - 1];
                        let currentY = this.lastPanYs[this.lastPanYs.length - 1];
                        let currentTimestamp = this.lastPanTimestamps[this.lastPanTimestamps.length - 1];
                        // If last pan update is too old, user has stopped moving.
                        // So velocity should be set to zero.
                        if (Date.now() - currentTimestamp <= this.panDelayInMs) {
                            // Take the position "panDelay" milliseconds ago, as second reference
                            let i = this.lastPanTimestamps.length - 1;
                            while (currentTimestamp - this.lastPanTimestamps[i] < this.panDelayInMs && i > 0) {
                                i--;
                            }
                            let lastX = this.lastPanXs[i];
                            let lastY = this.lastPanYs[i];
                            let lastTimestamp = this.lastPanTimestamps[i];
                            // Add translation impulse
                            let durationInMs = currentTimestamp - lastTimestamp;
                            if (durationInMs > 0) {
                                let referenceDurationInMs = 10;
                                let velocity = new PIXI.Point(-(currentX - lastX) * (referenceDurationInMs / durationInMs), -(currentY - lastY) * (referenceDurationInMs / durationInMs));
                                this.addTranslationImpulse(velocity);
                            }
                        }
                        this.camera.setBordersEnabled(true);
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        isPanningKeyDown() {
            return GestureRecognizer_5.GestureRecognizer.isCtrlPressed();
        }
        onPinchingStart(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.pinching = true;
                    this.currentFocus = new PIXI.Point(pinchFocusX, pinchFocusY);
                    this.currentScaleTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
            }
            return false;
        }
        onPinchingMove(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.currentScaleFactor = 1 / scaleFactor;
                    this.camera.scale(this.currentScaleFactor, this.currentScaleFactor, this.currentFocus);
                    this.currentScaleTimestampInMs = Date.now();
                    return true;
                }
            }
            return false;
        }
        onPinchingEnd(pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.pinchingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.pinching = false;
                    this.addScaleImpulse(this.currentScaleFactor);
                    this.camera.setBordersEnabled(true);
                    return true;
                }
            }
            return false;
        }
        onRotatingStart(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.rotating = true;
                    this.currentFocus = new PIXI.Point(pinchFocusX, pinchFocusY);
                    this.currentScaleTimestampInMs = Date.now();
                    this.currentRotationTimestampInMs = Date.now();
                    this.camera.setBordersEnabled(false);
                    return true;
                }
            }
            return false;
        }
        onRotatingMove(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.currentScaleFactor = 1 / scaleFactor;
                    this.camera.scale(this.currentScaleFactor, this.currentScaleFactor, this.currentFocus);
                    this.currentScaleTimestampInMs = Date.now();
                    this.currentRotation = -rotation;
                    this.camera.rotate(this.currentRotation, this.currentFocus);
                    this.currentRotationTimestampInMs = Date.now();
                    return true;
                }
            }
            return false;
        }
        onRotatingEnd(rotation, pinchFocusX, pinchFocusY, distance, scaleFactor) {
            if (this.config.rotatingEnabled) {
                if (this.isInteractionEnabled()) {
                    this.rotating = false;
                    this.addScaleImpulse(this.currentScaleFactor);
                    this.addRotationImpulse(this.currentRotation);
                    this.camera.setBordersEnabled(true);
                    return true;
                }
            }
            return false;
        }
        addScaleImpulse(scaleFactor) {
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentScaleTimestampInMs;
            let referenceTimeDifferenceInMs = 60;
            let weight = 0;
            if (timeDifferenceInMs !== 0) {
                weight = Math.min(timeDifferenceInMs / referenceTimeDifferenceInMs, 1);
            }
            scaleFactor = scaleFactor - ((scaleFactor - 1) * weight);
            this.camera.addScaleImpulse(scaleFactor, this.currentFocus);
        }
        addRotationImpulse(rotation) {
            let timestamp = Date.now();
            let timeDifferenceInMs = timestamp - this.currentRotationTimestampInMs;
            let referenceTimeDifferenceInMs = 10;
            let weight = 1;
            if (timeDifferenceInMs !== 0) {
                weight = Math.min(referenceTimeDifferenceInMs / timeDifferenceInMs, 1);
            }
            rotation = rotation * weight;
            this.camera.addRotationImpulse(rotation, this.currentFocus);
        }
        addTranslationImpulse(translation) {
            // Decrease velocity if last pan move event was emitted a long time ago.
            this.camera.addTranslationImpulse(translation);
        }
        onTap(x, y, numTaps) {
            if (this.config.doubleTapZoomEnabled) {
                // Double tap to zoom in
                if (numTaps === 2) {
                    if (this.camera.getScaleX() > 1.0) {
                        // By default: Zoom in.
                        this.onPinchingStart(x, y, 0, 1.1);
                        this.onPinchingMove(x, y, 0, 1.1);
                        this.onPinchingEnd(x, y, 0, 1.1);
                    }
                    else {
                        // If zoom level has reached image resolution (1 pixel = 1 texel), zoom out again.
                        let interpolator = new EaseIn_1.EaseIn(new EaseOut_2.EaseOut(new LinearInterpolator_9.LinearInterpolator()));
                        let endObb = this.camera.getDefaultWorldBordersInWorldCoordinates();
                        let durationInMs = 1 * 1000;
                        let delayInMs = 0.0;
                        this.camera.startAnimation(interpolator, endObb, durationInMs, delayInMs);
                    }
                    return false;
                }
            }
            return false;
        }
        // Resizing
        // @Override
        onResize() {
            super.onResize();
            this.relayoutNavigationView();
        }
        //// Configuration
        isInteractionEnabled() {
            return this.interactionEnabled;
        }
        setInteractionEnabled(enabled) {
            this.interactionEnabled = enabled;
        }
        setDoubleTapZoomingEnabled(enabled) {
            this.config.doubleTapZoomEnabled = enabled;
        }
        isDoubleTapZoomingEnabled() {
            return this.config.doubleTapZoomEnabled;
        }
    }
    exports.NavigationLayer = NavigationLayer;
    (function (NavigationLayer) {
        class Config {
            constructor() {
                /**
                 * True, if panning is enabled.
                 *
                 * Default: true
                 */
                this.panningEnabled = true;
                /**
                 * True, if pinching is enabled.
                 *
                 * Default: true
                 */
                this.pinchingEnabled = true;
                /**
                 * True, if rotating is enabled.
                 *
                 * Default: true
                 */
                this.rotatingEnabled = true;
                /**
                 * True, if double tapping triggers a zoom in.
                 *
                 * Default: true
                 */
                this.doubleTapZoomEnabled = true;
                /**
                 * Focuses the camera to the specified oriented bounding box
                 * right after initialization. If null, the camera
                 * will show the whole map. The frustum coordinates
                 * are given in the world coordinate system:
                 * [[0, floorplanWidth], [0, floorplanHeight]]
                 *
                 * Default: null (displaying the whole world)
                 */
                this.initialFrustum = null;
            }
        }
        NavigationLayer.Config = Config;
    })(NavigationLayer = exports.NavigationLayer || (exports.NavigationLayer = {}));
});
define("src/map/view/hud/objects/ButtonObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture"], function (require, exports, SceneObject_9, SpriteObject_13, Texture_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ButtonObject extends SceneObject_9.SceneObject {
        // Initialization
        constructor(environment, normalTextureName, hoverColor = 0xffffff) {
            super(environment);
            this.hovering = false;
            this.clicking = false;
            // Observer
            this.buttonObservers = new Array();
            this.normalTextureName = normalTextureName;
            this.hoverColor = hoverColor;
            this.initView();
        }
        initView() {
            // Texture
            this.spriteView = new SpriteObject_13.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.loadTexture();
            this.colorizeTexture();
        }
        loadTexture() {
            let texture = PIXI.loader.resources["" + this.normalTextureName].texture;
            texture.baseTexture.mipmap = true;
            this.spriteView.texture = new Texture_13.Texture(texture, this.getEnvironment().renderingEnvironment);
        }
        colorizeTexture() {
            if (this.isHovering()) {
                this.spriteView.tint = this.hoverColor;
            }
            else {
                this.spriteView.tint = 0xffffff;
            }
        }
        // Observers
        addObserver(observer) {
            this.buttonObservers.push(observer);
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.buttonObservers.length; i++) {
                let observer = this.buttonObservers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // View
        // @Override
        getView() {
            return this.spriteView;
        }
        // Event-Handling: User
        // @Override
        onMouseMove(x, y) {
            if (this.pointInside(x, y)) {
                if (!this.isHovering()) {
                    this.hovering = true;
                    this.colorizeTexture();
                }
            }
            else {
                if (this.isHovering()) {
                    this.hovering = false;
                    this.colorizeTexture();
                }
            }
            return false;
        }
        // @Override
        onTouchStart(x, y) {
            if (this.pointInside(x, y)) {
                this.clicking = true;
                this.notifyObservers("onButtonPressed", [this]);
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.clicking) {
                if (this.pointInside(x, y)) {
                    this.notifyObservers("onButtonClicked", [this]);
                }
                this.clicking = false;
            }
            return false;
        }
        // @Override
        onTap(x, y, numTaps) {
            // Block taps
            if (this.pointInside(x, y)) {
                return true;
            }
            else {
                return false;
            }
        }
        // @Override
        onPanningStart(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        // @Override
        onPanningMove(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        // @Override
        onPanningEnd(x, y) {
            // Disable panning when button is in click state.
            return this.clicking;
        }
        pointInside(x, y) {
            let bounds = this.getView().pixi().getBounds();
            let minX = bounds.x;
            let minY = bounds.y;
            let maxX = bounds.x + bounds.width;
            let maxY = bounds.y + bounds.height;
            return ((x >= minX) && (x < maxX) && (y >= minY) && (y < maxY));
        }
        // Getters and setters
        isClicking() {
            return this.clicking;
        }
        isHovering() {
            return this.hovering;
        }
    }
    exports.ButtonObject = ButtonObject;
});
define("src/map/view/hud/layers/controlLayer/ZoomObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/hud/objects/ButtonObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_10, ButtonObject_1, DisplayObjectContainer_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ZoomObject extends SceneObject_10.SceneObject {
        // Initialization
        constructor(environment, worldCamera, buttonSizeInPx) {
            super(environment);
            this.scaleFactor = 1.02;
            this.buttonSizeInPx = buttonSizeInPx;
            this.initModel(worldCamera);
            this.initView();
        }
        initModel(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initView() {
            this.container = new DisplayObjectContainer_15.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.initPlusButton();
            this.initMinusButton();
        }
        initPlusButton() {
            this.plusButton = new ButtonObject_1.ButtonObject(this.getEnvironment(), "plus_normal", ZoomObject.HOVER_COLOR);
            this.addChild(this.plusButton);
            // Scale
            this.plusButton.getView().width = this.buttonSizeInPx;
            this.plusButton.getView().height = this.buttonSizeInPx;
            // Position
            this.plusButton.getView().x = 0;
            this.plusButton.getView().y = 0;
            // Observer
            this.plusButton.addObserver(this);
        }
        initMinusButton() {
            this.minusButton = new ButtonObject_1.ButtonObject(this.getEnvironment(), "minus_normal", ZoomObject.HOVER_COLOR);
            this.addChild(this.minusButton);
            // Scale
            this.minusButton.getView().width = this.buttonSizeInPx;
            this.minusButton.getView().height = this.buttonSizeInPx;
            // Position
            this.minusButton.getView().x = 0;
            // -> height-1 to avoid two borders.
            this.minusButton.getView().y = this.plusButton.getView().height - 1;
            // Observer
            this.minusButton.addObserver(this);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.plusButton === button) {
                this.scaleCameraWithScaleFactor(1.0 / this.scaleFactor);
            }
            else if (this.minusButton === button) {
                this.scaleCameraWithScaleFactor(this.scaleFactor);
            }
        }
        scaleCameraWithScaleFactor(scalingFactor) {
            let screenWidth = this.worldCamera.getScreenWidth();
            let screenHeight = this.worldCamera.getScreenHeight();
            this.worldCamera.addScaleImpulse(scalingFactor, new PIXI.Point(screenWidth / 2, screenHeight / 2));
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.plusButton.isClicking()) {
                this.scaleCameraWithScaleFactor(1.0 / this.scaleFactor);
            }
            else if (this.minusButton.isClicking()) {
                this.scaleCameraWithScaleFactor(this.scaleFactor);
            }
        }
    }
    // Constants
    ZoomObject.HOVER_COLOR = 0xe4e4e4;
    exports.ZoomObject = ZoomObject;
});
define("src/map/view/hud/layers/controlLayer/PanObject", ["require", "exports", "src/engine/scene/SceneObject", "src/map/view/hud/objects/ButtonObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_11, ButtonObject_2, DisplayObjectContainer_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PanObject extends SceneObject_11.SceneObject {
        // Initialization
        constructor(environment, worldCamera, buttonSizeInPx) {
            super(environment);
            // Configuration
            this.translationImpulse = 5;
            this.buttonSizeInPx = buttonSizeInPx;
            this.initModel(worldCamera);
            this.initView();
        }
        initModel(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initView() {
            this.container = new DisplayObjectContainer_16.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.centerButton = this.initButton("pan_center", 0xffffff, this.buttonSizeInPx * 1 + 0, this.buttonSizeInPx * 1 + 0);
            this.upButton = this.initButton("pan_up", PanObject.HOVER_COLOR, this.buttonSizeInPx * 1 + 0, this.buttonSizeInPx * 0 + 0);
            this.downButton = this.initButton("pan_down", PanObject.HOVER_COLOR, this.buttonSizeInPx * 1 + 0, this.buttonSizeInPx * 2 - 0);
            this.leftButton = this.initButton("pan_left", PanObject.HOVER_COLOR, this.buttonSizeInPx * 0 + 0, this.buttonSizeInPx * 1 + 0);
            this.rightButton = this.initButton("pan_right", PanObject.HOVER_COLOR, this.buttonSizeInPx * 2 - 0, this.buttonSizeInPx * 1 + 0);
        }
        initButton(imageName, hoverColor, x, y) {
            let button = new ButtonObject_2.ButtonObject(this.getEnvironment(), imageName, hoverColor);
            this.addChild(button);
            // Scale
            button.getView().width = this.buttonSizeInPx;
            button.getView().height = this.buttonSizeInPx;
            // Position
            button.getView().x = x;
            button.getView().y = y;
            // Observer
            button.addObserver(this);
            return button;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.upButton === button) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(0, -this.translationImpulse));
            }
            else if (this.downButton === button) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(0, +this.translationImpulse));
            }
            else if (this.leftButton === button) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(-this.translationImpulse, 0));
            }
            else if (this.rightButton === button) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(+this.translationImpulse, 0));
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.upButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(0, -this.translationImpulse));
            }
            else if (this.downButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(0, +this.translationImpulse));
            }
            else if (this.leftButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(-this.translationImpulse, 0));
            }
            else if (this.rightButton.isClicking()) {
                this.worldCamera.addTranslationImpulse(new PIXI.Point(+this.translationImpulse, 0));
            }
        }
        // Getters and setters
        getWidth() {
            return this.buttonSizeInPx * 3;
        }
        getHeight() {
            return this.buttonSizeInPx * 3;
        }
    }
    // Constants
    PanObject.HOVER_COLOR = 0xe4e4e4;
    exports.PanObject = PanObject;
});
define("src/map/view/hud/layers/controlLayer/Compass", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/animation/Animation", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/map/utils/DeviceUtils", "src/engine/rendering/objects/DisplayObjectContainer", "src/map/view/hud/objects/ButtonObject"], function (require, exports, SceneObject_12, Animation_10, EaseOut_3, LinearInterpolator_10, DeviceUtils_16, DisplayObjectContainer_17, ButtonObject_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Compass extends SceneObject_12.SceneObject {
        // Initialization
        constructor(environment, worldCamera) {
            super(environment);
            this.initWorldCamera(worldCamera);
            this.initCameraReset();
            this.initContainer();
            this.initCompassButton();
        }
        initWorldCamera(worldCamera) {
            this.worldCamera = worldCamera;
        }
        initCameraReset() {
            this.resetAnimation = new Animation_10.Animation(new EaseOut_3.EaseOut(new LinearInterpolator_10.LinearInterpolator()));
            this.alphaAnimation = new Animation_10.Animation(new EaseOut_3.EaseOut(new LinearInterpolator_10.LinearInterpolator()));
        }
        initContainer() {
            this.container = new DisplayObjectContainer_17.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
        }
        initCompassButton() {
            this.compassButton = new ButtonObject_3.ButtonObject(this.getEnvironment(), "compass");
            this.addChild(this.compassButton);
            // Scale
            const oldWidth = this.compassButton.getView().width;
            const oldHeight = this.compassButton.getView().height;
            this.compassButton.getView().width = DeviceUtils_16.DeviceUtils.getPhysicalPixelsFromLogical(32);
            this.compassButton.getView().height = this.compassButton.getView().width * (oldHeight / oldWidth);
            // Adjust anchor
            this.compassButton.getView().anchor.x = 0.5;
            this.compassButton.getView().anchor.y = 0.5;
            // Adjust position
            this.compassButton.getView().x = this.compassButton.getView().width / 2;
            this.compassButton.getView().y = this.compassButton.getView().height / 2;
            // Observer
            this.compassButton.addObserver(this);
        }
        // View
        getView() {
            return this.container;
        }
        // Event-Handling: Button
        // @Override
        onButtonClicked(button) {
            if (this.compassButton === button) {
                this.resetWorldCamera();
            }
        }
        resetWorldCamera() {
            let startValue = this.worldCamera.getRotation();
            let stopValue = 0.0;
            let durationInMs = 2 * 1000;
            let delayInMs = 0.0;
            this.resetAnimation.start(startValue, stopValue, durationInMs, delayInMs);
        }
        // Updating
        // @Override
        update(lastFrametime) {
            this.updateOrientation();
            this.updateAlpha(lastFrametime);
            this.updateResetAnimation(lastFrametime);
        }
        updateOrientation() {
            let worldOrientation = this.worldCamera.getRotation();
            this.compassButton.getView().rotation = -worldOrientation;
        }
        updateAlpha(lastFrametime) {
            this.startAlphaAnimationIfNecessary();
            this.updateAlphaAnimation(lastFrametime);
        }
        startAlphaAnimationIfNecessary() {
            if (this.compassButton.getView().rotation === 0 && this.compassButton.getView().alpha !== 0) {
                if (!this.alphaAnimation.isCurrentlyAnimating()) {
                    let startValue = 1.0;
                    let endValue = 0.0;
                    let durationInMs = 1000;
                    let delayInMs = 0.0;
                    this.alphaAnimation.start(startValue, endValue, durationInMs, delayInMs);
                }
            }
            else if (this.compassButton.getView().rotation !== 0 && this.compassButton.getView().alpha === 0) {
                if (!this.alphaAnimation.isCurrentlyAnimating()) {
                    let startValue = 0.0;
                    let endValue = 1.0;
                    let durationInMs = 1000;
                    let delayInMs = 0.0;
                    this.alphaAnimation.start(startValue, endValue, durationInMs, delayInMs);
                }
            }
        }
        updateAlphaAnimation(lastFrametime) {
            if (this.alphaAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.alphaAnimation.getValue(lastFrametime);
                this.compassButton.getView().alpha = currentAlpha;
            }
        }
        updateResetAnimation(lastFrametime) {
            if (this.resetAnimation.isCurrentlyAnimating()) {
                let lastOrientation = this.worldCamera.getRotation();
                let currentOrientation = this.resetAnimation.getValue(lastFrametime);
                let rotation = currentOrientation - lastOrientation;
                let focusPoint = new PIXI.Point(this.worldCamera.getScreenWidth() / 2, this.worldCamera.getScreenHeight() / 2);
                this.worldCamera.rotate(rotation, focusPoint);
            }
        }
    }
    exports.Compass = Compass;
});
define("src/map/view/hud/layers/controlLayer/ControlLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/hud/layers/controlLayer/ZoomObject", "src/map/view/hud/layers/controlLayer/PanObject", "src/map/view/hud/layers/controlLayer/Compass", "src/map/utils/DeviceUtils"], function (require, exports, Layer_11, ZoomObject_1, PanObject_1, Compass_1, DeviceUtils_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ControlLayer extends Layer_11.Layer {
        // Construction
        constructor(config = new ControlLayer.Config(), environment, worldCamera) {
            super(environment);
            // View
            this.zoomObject = null;
            this.panObject = null;
            this.compass = null;
            this.padding = DeviceUtils_17.DeviceUtils.getPhysicalPixelsFromLogical(10);
            this.panButtonSizeInPx = DeviceUtils_17.DeviceUtils.getPhysicalPixelsFromLogical(24);
            this.zoomButtonSizeInPx = DeviceUtils_17.DeviceUtils.getPhysicalPixelsFromLogical(32);
            this.config = config;
            this.initView(worldCamera);
        }
        initView(worldCamera) {
            this.createView(worldCamera);
            this.layoutView();
        }
        createView(worldCamera) {
            this.initPanObject(worldCamera);
            this.initZoomObject(worldCamera);
            this.initCompass(worldCamera);
        }
        initPanObject(worldCamera) {
            this.panObject = new PanObject_1.PanObject(this.getEnvironment(), worldCamera, this.panButtonSizeInPx);
            if (this.config.panControlVisible) {
                this.addChild(this.panObject);
            }
        }
        initZoomObject(worldCamera) {
            this.zoomObject = new ZoomObject_1.ZoomObject(this.getEnvironment(), worldCamera, this.zoomButtonSizeInPx);
            if (this.config.zoomControlVisible) {
                this.addChild(this.zoomObject);
            }
        }
        initCompass(worldCamera) {
            this.compass = new Compass_1.Compass(this.getEnvironment(), worldCamera);
            if (this.config.rotationControlVisible) {
                this.addChild(this.compass);
            }
        }
        // Construction: Layout
        layoutView() {
            if (this.config.panControlVisible) {
                this.layoutPanObject();
            }
            if (this.config.zoomControlVisible) {
                this.layoutZoomObject();
            }
            if (this.config.rotationControlVisible) {
                this.layoutCompassObject();
            }
        }
        layoutPanObject() {
            let screenWidth = this.getCanvasWidthInPx();
            this.panObject.getView().x = screenWidth - this.panObject.getView().width - this.padding;
            this.panObject.getView().y = this.padding;
        }
        layoutZoomObject() {
            let screenWidth = this.getCanvasWidthInPx();
            let yOffset = 0;
            let xOffset = 0;
            if (this.config.panControlVisible) {
                yOffset += this.panObject.getHeight() + this.padding;
            }
            if (this.config.panControlVisible) {
                xOffset += this.panObject.getWidth() / 2 + this.zoomButtonSizeInPx / 2;
            }
            else {
                xOffset += this.zoomButtonSizeInPx;
            }
            this.zoomObject.getView().x = screenWidth - xOffset - this.padding + 1;
            this.zoomObject.getView().y = this.padding + yOffset;
        }
        layoutCompassObject() {
            let screenWidth = this.getCanvasWidthInPx();
            let yOffset = 0;
            let xOffset = 0;
            if (this.config.panControlVisible) {
                yOffset += this.panObject.getHeight() + this.padding;
            }
            if (this.config.zoomControlVisible) {
                yOffset += this.zoomObject.getView().height + this.padding;
            }
            if (this.config.panControlVisible) {
                xOffset += this.panObject.getWidth() / 2 + this.zoomButtonSizeInPx / 2;
            }
            else {
                xOffset += this.zoomButtonSizeInPx;
            }
            this.compass.getView().x = screenWidth - xOffset - this.padding + 1;
            this.compass.getView().y = this.padding + yOffset;
        }
        // Events: Resize
        //@Override
        onResize() {
            this.layoutView();
        }
    }
    exports.ControlLayer = ControlLayer;
    (function (ControlLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the pan control elements (arrows) for panning
                 * via mouse clicks should be visible.
                 *
                 * Default: true
                 */
                this.panControlVisible = true;
                /**
                 * True, if the zoom control elements (+/-) buttons for zooming
                 * via mouse clicks should be visible.
                 *
                 * Default: true
                 */
                this.zoomControlVisible = true;
                /**
                 * True, if the rotation control element (compass needle) for resetting the
                 * camera orientation via mouse click should be visible.
                 *
                 * Default: true. The compass, however, will only be visible,
                 * when the map's orientation is not adjusted to north direction.
                 */
                this.rotationControlVisible = true;
            }
        }
        ControlLayer.Config = Config;
    })(ControlLayer = exports.ControlLayer || (exports.ControlLayer = {}));
});
define("src/app/relution/view/hud/barLayer/actionBar/Action", ["require", "exports", "src/engine/scene/SceneObject", "src/map/utils/DeviceUtils", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_13, DeviceUtils_18, GraphicsObject_13, SpriteObject_14, TextObject_4, DisplayObjectContainer_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Action extends SceneObject_13.SceneObject {
        // Initialization
        constructor(environment, resourceName, descriptionPlaceholder) {
            super(environment);
            // Model
            this.descriptionPlaceholder = null;
            this.hovering = false;
            this.touching = false;
            // Observers
            this.observers = new Array();
            this.descriptionPlaceholder = descriptionPlaceholder;
            this.initContainer();
            this.initBackgroundView();
            this.initSpriteView(resourceName);
            this.initTooltipView();
        }
        initContainer() {
            this.container = new DisplayObjectContainer_18.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
        }
        initBackgroundView() {
            this.backgroundView = new GraphicsObject_13.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.beginFill(0x95b507);
            this.backgroundView.drawRect(0, 0, Action.WIDTH, Action.HEIGHT);
            this.backgroundView.endFill();
            this.backgroundView.alpha = Action.BG_ALPHA_NORMAL;
            this.container.addChild(this.backgroundView);
        }
        initSpriteView(resourceName) {
            // Load texture
            let texture = PIXI.loader.resources["" + resourceName].texture;
            // Load sprite
            this.iconView = new SpriteObject_14.SpriteObject(new PIXI.Sprite(texture), this.getEnvironment().renderingEnvironment);
            // Pivot
            this.iconView.pivot.x = this.iconView.width / 2;
            this.iconView.pivot.y = this.iconView.height / 2;
            // Scale
            this.iconView.width = Action.IMAGE_WIDTH;
            this.iconView.height = Action.IMAGE_HEIGHT;
            // Position
            this.iconView.x = Action.WIDTH / 2;
            this.iconView.y = Action.HEIGHT / 2;
            this.container.addChild(this.iconView);
        }
        initTooltipView() {
            if (this.tooltipView != null) {
                this.getView().removeChild(this.tooltipView);
            }
            let fontSize = DeviceUtils_18.DeviceUtils.getPhysicalPixelsFromLogical(14);
            let style = { fontFamily: "Arial", fontSize: fontSize, fill: 0x000000, align: "center" };
            let description = this.getLocalizedStringFor(this.descriptionPlaceholder);
            this.tooltipView = new TextObject_4.TextObject(new PIXI.Text("" + description, style), this.getEnvironment().renderingEnvironment);
            this.tooltipView.alpha = 0;
            this.container.addChild(this.tooltipView);
            // Position
            this.tooltipView.x = 0;
            this.tooltipView.y = Action.HEIGHT;
        }
        // Observation
        addObserver(observer) {
            this.observers.push(observer);
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
        updateViewState() {
            if (this.touching) {
                this.backgroundView.alpha = Action.BG_ALPHA_TOUCHING;
            }
            else if (this.hovering) {
                this.backgroundView.alpha = Action.BG_ALPHA_HOVER;
            }
            else {
                this.backgroundView.alpha = Action.BG_ALPHA_NORMAL;
            }
        }
        showTooltip(show) {
            if (show) {
                this.tooltipView.alpha = 1.0;
            }
            else {
                this.tooltipView.alpha = 0.0;
            }
        }
        // Localization: Event-Handling
        // @Override
        onLocalizationChanged() {
            this.initTooltipView();
            return false;
        }
        // Input Event-Handling
        // @Override
        onMouseMove(x, y) {
            if (this.touchCollides(x, y)) {
                if (!this.hovering) {
                    this.hovering = true;
                    this.updateViewState();
                    this.showTooltip(true);
                }
            }
            else {
                if (this.hovering) {
                    this.hovering = false;
                    this.updateViewState();
                    this.showTooltip(false);
                }
            }
            return false;
        }
        // @Override
        onTouchStart(x, y) {
            if (this.touchCollides(x, y)) {
                this.touching = true;
                this.updateViewState();
                this.notifyObserversAboutButtonClicked();
                return true;
            }
            else {
                return false;
            }
        }
        touchCollides(x, y) {
            let itemPositionInImage = this.getView().pixi().toGlobal(new PIXI.Point(), new PIXI.Point());
            let minX = itemPositionInImage.x;
            let minY = itemPositionInImage.y;
            let maxX = itemPositionInImage.x + Action.WIDTH;
            let maxY = itemPositionInImage.y + Action.HEIGHT;
            return ((x >= minX) && (x < maxX) &&
                (y >= minY) && (y < maxY));
        }
        notifyObserversAboutButtonClicked() {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                observer.onActionClicked(this);
            }
        }
        // @Override
        onTouchEnd(x, y) {
            if (this.touching) {
                this.touching = false;
                this.updateViewState();
                return true;
            }
            else {
                return false;
            }
        }
    }
    // View: Dimensions
    Action.WIDTH = DeviceUtils_18.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.HEIGHT = DeviceUtils_18.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.IMAGE_WIDTH = DeviceUtils_18.DeviceUtils.getPhysicalPixelsFromLogical(40);
    Action.IMAGE_HEIGHT = DeviceUtils_18.DeviceUtils.getPhysicalPixelsFromLogical(40);
    // View: Hovering
    Action.BG_ALPHA_NORMAL = 0.00;
    Action.BG_ALPHA_HOVER = 0.25;
    // View: Clicking
    Action.BG_ALPHA_TOUCHING = 0.50;
    exports.Action = Action;
});
define("src/app/relution/view/hud/helpLayer/HelpLayer", ["require", "exports", "src/map/view/Layer", "src/map/utils/DeviceUtils", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/TextObject"], function (require, exports, Layer_12, DeviceUtils_19, GraphicsObject_14, TextObject_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HelpLayer extends Layer_12.Layer {
        // Initialization
        constructor(environment) {
            super(environment);
        }
        // @Override
        initialize() {
            super.initialize();
            this.initView();
        }
        initView() {
            this.createView();
            this.layoutView();
            this.setVisible(false);
        }
        createView() {
            this.initBackgroundView();
            this.initTextView();
        }
        initBackgroundView() {
            this.backgroundView = new GraphicsObject_14.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.alpha = 0.75;
            this.getView().addChild(this.backgroundView);
        }
        initTextView() {
            if (this.textView != null) {
                this.getView().removeChild(this.textView);
            }
            let localization = this.getLocalization();
            let text = null;
            if (DeviceUtils_19.DeviceUtils.isMobileDevice()) {
                text = this.getLocalizedStringFor("help_layer_mobile_device_description");
            }
            else {
                text = this.getLocalizedStringFor("help_layer_non_mobile_device_description");
            }
            let fontSize = DeviceUtils_19.DeviceUtils.getPhysicalPixelsFromLogical(18);
            let style = {
                fontSize: fontSize,
            };
            this.textView = new TextObject_5.TextObject(new PIXI.Text(text, style), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.textView);
        }
        layoutView() {
            this.layoutBackgroundView();
            this.layoutTextView();
        }
        layoutBackgroundView() {
            this.backgroundView.clear();
            this.backgroundView.beginFill(0xffffff);
            this.backgroundView.lineStyle(1, 0x000000);
            this.backgroundView.drawRect(0, 0, this.getEnvironment().canvasSize.x, this.getEnvironment().canvasSize.y);
            this.backgroundView.endFill();
        }
        layoutTextView() {
            this.textView.x = this.getEnvironment().canvasSize.x / 2 - this.textView.width / 2;
            this.textView.y = this.getEnvironment().canvasSize.y / 2 - this.textView.height / 2;
        }
        // Localization Event-Handling
        // @Override
        onLocalizationChanged() {
            this.initTextView();
            return false;
        }
        // Resize Event-Handling
        // @Override
        onResize() {
            this.layoutView();
        }
        // Input: Event-Handling
        // @Override
        onTouchStart(x, y) {
            if (this.isVisible()) {
                this.animateVisible(false);
                return true;
            }
            else {
                return false;
            }
        }
    }
    exports.HelpLayer = HelpLayer;
});
define("src/app/relution/view/hud/barLayer/actionBar/ToggleAction", ["require", "exports", "src/app/relution/view/hud/barLayer/actionBar/Action"], function (require, exports, Action_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ToggleAction extends Action_1.Action {
        // Initialization
        constructor(environment, resourceName, description) {
            super(environment, resourceName, description);
            this.enabled = false;
        }
        // Getters and setters
        setEnabled(enabled) {
            this.enabled = enabled;
            this.updateViewState();
        }
        isEnabled() {
            return this.enabled;
        }
        // @Override
        updateViewState() {
            super.updateViewState();
            if (this.isEnabled()) {
                this.backgroundView.alpha = Action_1.Action.BG_ALPHA_TOUCHING;
            }
        }
    }
    exports.ToggleAction = ToggleAction;
});
define("src/app/relution/view/hud/barLayer/actionBar/ActionBar", ["require", "exports", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/actionBar/Action", "src/app/relution/view/hud/barLayer/actionBar/ToggleAction", "src/map/utils/DeviceUtils", "src/engine/general/AABB", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, Bar_2, Action_2, ToggleAction_1, DeviceUtils_20, AABB_10, GraphicsObject_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ActionBar extends Bar_2.Bar {
        // Initialization
        constructor(environment, world, helpLayer, beaconRangeLayer, beaconConnectionsLayer, deviceTrackLayer, heatmapLayer) {
            super(environment, world.getScene().getCamera().getScreenWidth(), Action_2.Action.HEIGHT);
            this.actions = new Array();
            this.helpLayer = helpLayer;
            this.beaconRangeLayer = beaconRangeLayer;
            this.beaconConnectionsLayer = beaconConnectionsLayer;
            this.deviceTrackLayer = this.deviceTrackLayer;
            this.heatmapLayer = this.heatmapLayer;
            this.world = world;
        }
        // @Override
        initialize() {
            super.initialize();
            this.initModel();
            this.initView();
        }
        initModel() {
            this.helpLayer.addVisiblityObserver(this);
            this.beaconRangeLayer.addVisiblityObserver(this);
            this.beaconConnectionsLayer.addVisiblityObserver(this);
            this.deviceTrackLayer.addVisiblityObserver(this);
            this.heatmapLayer.addVisiblityObserver(this);
        }
        initView() {
            this.createView();
            this.layoutView();
            this.setHorizontalScrollingEnabled(false);
            this.setVerticalScrollingEnabled(false);
        }
        createView() {
            this.initBar();
            this.initBackgroundView();
            this.initActions();
        }
        initBar() {
            // On mobile devices the action bar should not hide
            if (DeviceUtils_20.DeviceUtils.isMobileDevice()) {
                this.setAutoFadeEnabled(false);
            }
            else {
                this.setAutoFadeEnabled(true);
            }
        }
        initBackgroundView() {
            this.backgroundView = new GraphicsObject_15.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.backgroundView.alpha = 1;
            this.getView().addChild(this.backgroundView);
        }
        initActions() {
            this.helpAction = this.addToggleAction("action_help", "action_bar_show_help_action");
            this.syncToggleActionWithLayerVisibility(this.helpAction, this.helpLayer);
            this.showBeaconRangeAction = this.addToggleAction("action_range", "action_bar_show_beacon_ranges_action");
            this.syncToggleActionWithLayerVisibility(this.showBeaconRangeAction, this.beaconRangeLayer);
            this.showBeaconConnectionsAction = this.addToggleAction("action_connections", "action_bar_show_connections_action");
            this.syncToggleActionWithLayerVisibility(this.showBeaconConnectionsAction, this.beaconConnectionsLayer);
            this.showDeviceTrackAction = this.addToggleAction("action_track", "action_bar_show_device_tracks_action");
            this.syncToggleActionWithLayerVisibility(this.showDeviceTrackAction, this.deviceTrackLayer);
            this.showHeatmapAction = this.addToggleAction("action_heatmap", "action_bar_show_heatmap_action");
            this.syncToggleActionWithLayerVisibility(this.showHeatmapAction, this.heatmapLayer);
        }
        addToggleAction(resourceName, description) {
            let action = new ToggleAction_1.ToggleAction(this.getEnvironment(), resourceName, description);
            action.addObserver(this);
            this.getContentObject().addChild(action);
            this.actions.push(action);
            let position = this.getNextActionPosition();
            action.getView().x = position.x;
            action.getView().y = position.y;
            this.updateScrollViewDimensions();
            return action;
        }
        getNextActionPosition() {
            let x = ((this.actions.length - 1) * Action_2.Action.WIDTH);
            let y = 0;
            return new PIXI.Point(x, y);
        }
        updateScrollViewDimensions() {
            let maxX = ((this.actions.length + 1) * Action_2.Action.WIDTH);
            let maxY = Action_2.Action.HEIGHT;
            let aabb = new AABB_10.AABB(new PIXI.Point(0, 0), new PIXI.Point(maxX, maxY));
            this.updateContentObjectDimensions(aabb);
        }
        layoutView() {
            this.layoutBackgroundView();
        }
        layoutBackgroundView() {
            let camera = this.world.getScene().getCamera();
            let screenWidth = camera.getScreenWidth();
            this.backgroundView.clear();
            this.backgroundView.beginFill(0x95b507, 0);
            this.backgroundView.lineStyle(1, 0x000000, 0.15);
            this.backgroundView.drawRect(0, 0, screenWidth, Action_2.Action.HEIGHT);
            this.backgroundView.endFill();
        }
        // Event-Handling: User
        // @Override
        onPanningMove(x, y) {
            let handled = super.onPanningMove(x, y);
            if (handled) {
                return true;
            }
        }
        // @Override
        onTap(x, y, numTaps) {
            // Block taps inside the scrollable area.
            if (this.touchPointInsideContainer(x, y)) {
                return true;
            }
            else {
                return false;
            }
        }
        // Event-Handling: Action
        // @Override
        onActionClicked(action) {
            if (action === this.helpAction) {
                this.onHelpActionClicked();
            }
            else if (action === this.showBeaconRangeAction) {
                this.onShowBeaconRangeActionClicked();
            }
            else if (action === this.showBeaconConnectionsAction) {
                this.onShowBeaconConnectionsActionClicked();
            }
            else if (action === this.showDeviceTrackAction) {
                this.onShowDeviceTrackActionClicked();
            }
            else if (action === this.showHeatmapAction) {
                this.onShowHeatmapActionClicked();
            }
        }
        onHelpActionClicked() {
            this.toggleLayerVisibility(this.helpAction, this.helpLayer);
        }
        onShowBeaconRangeActionClicked() {
            this.toggleLayerVisibility(this.showBeaconRangeAction, this.beaconRangeLayer);
        }
        onShowBeaconConnectionsActionClicked() {
            this.toggleLayerVisibility(this.showBeaconConnectionsAction, this.beaconConnectionsLayer);
        }
        onShowDeviceTrackActionClicked() {
            this.toggleLayerVisibility(this.showDeviceTrackAction, this.deviceTrackLayer);
        }
        onShowHeatmapActionClicked() {
            this.toggleLayerVisibility(this.showHeatmapAction, this.heatmapLayer);
        }
        toggleLayerVisibility(toggleAction, layer) {
            if (toggleAction.isEnabled()) {
                layer.animateVisible(false);
                toggleAction.setEnabled(false);
            }
            else {
                layer.animateVisible(true);
                toggleAction.setEnabled(true);
            }
        }
        // Event-Handling: Layer visibility
        // @Override
        visibilityChanged(layer) {
            if (layer === this.helpLayer) {
                this.syncToggleActionWithLayerVisibility(this.helpAction, layer);
            }
            else if (layer === this.beaconRangeLayer) {
                this.syncToggleActionWithLayerVisibility(this.showBeaconRangeAction, layer);
            }
            else if (layer === this.beaconConnectionsLayer) {
                this.syncToggleActionWithLayerVisibility(this.showBeaconConnectionsAction, layer);
            }
            else if (layer === this.deviceTrackLayer) {
                this.syncToggleActionWithLayerVisibility(this.showDeviceTrackAction, layer);
            }
            else if (layer === this.heatmapLayer) {
                this.syncToggleActionWithLayerVisibility(this.showHeatmapAction, layer);
            }
        }
        syncToggleActionWithLayerVisibility(toggleAction, layer) {
            if (layer.isVisible()) {
                toggleAction.setEnabled(true);
            }
            else {
                toggleAction.setEnabled(false);
            }
        }
        // Resize - Event handling
        // @Override
        onResize() {
            super.onResize();
            // Relayout scrollable view
            this.setSize(this.world.getScene().getCamera().getScreenWidth(), Action_2.Action.HEIGHT);
            // Relayout action bar views
            this.layoutView();
        }
        // Getters and setters
        getBackgroundView() {
            return this.backgroundView;
        }
    }
    exports.ActionBar = ActionBar;
});
define("src/app/relution/view/hud/barLayer/BarLayer", ["require", "exports", "src/map/view/Layer", "src/app/relution/view/hud/barLayer/beaconBar/BeaconBar"], function (require, exports, Layer_13, BeaconBar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BarLayer extends Layer_13.Layer {
        // Initialilzation
        constructor(environment, world, building) {
            super(environment);
            this.initView(world, building);
        }
        initView(world, building) {
            // this.actionBar = new ActionBar(helpLayer, world);
            // this.addChild(this.actionBar);
            this.beaconBar = new BeaconBar_1.BeaconBar(this.getEnvironment(), world, building);
        }
        // Enabling beacon bar
        makeBeaconBarVisible(enabled) {
            let beaconBar = this.beaconBar;
            if (enabled) {
                if (!this.hasChild(beaconBar)) {
                    this.addChild(beaconBar);
                }
            }
            else {
                if (this.hasChild(beaconBar)) {
                    this.removeChild(beaconBar);
                }
            }
        }
        isBeaconBarVisible() {
            return this.hasChild(this.beaconBar);
        }
        // Getters and setters
        getActionBar() {
            return this.actionBar;
        }
        getBeaconBar() {
            return this.beaconBar;
        }
    }
    exports.BarLayer = BarLayer;
});
define("src/app/relution/view/hud/popupLayer/PopupLayer", ["require", "exports", "src/map/view/Layer", "src/engine/animation/Animation", "src/map/utils/DeviceUtils", "src/engine/animation/LinearInterpolator", "src/engine/input/GestureRecognizer", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/pixi/HighResText"], function (require, exports, Layer_14, Animation_11, DeviceUtils_21, LinearInterpolator_11, GestureRecognizer_6, HighResTextObject_4, GraphicsObject_16, HighResText_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PopupLayer extends Layer_14.Layer {
        // Initialization
        constructor(config, environment, building) {
            super(environment);
            this.hoveringObject = null;
            // View: Size
            this.paddingWidthInPx = 10;
            this.paddingHeightInPx = 10;
            // View: Mobile Tap
            this.tapWorldPositionInTx = null;
            // View: Updating
            this.lastPopupUpdateInMs = -1;
            this.config = config;
            this.initModel(building);
            this.initView();
        }
        initModel(building) {
            this.building = building;
            this.building.addFloorObserver(this);
            this.observeObjectLayers(this.building.getCurrentFloor());
        }
        observeObjectLayers(currentFloor) {
            let objectLayers = currentFloor.getObjectLayers();
            for (let i = 0; i < objectLayers.length; i++) {
                let objectLayer = objectLayers[i];
                objectLayer.addObserver(this);
            }
        }
        unobserveObjectLayers(leftFloor) {
            let objectLayers = leftFloor.getObjectLayers();
            for (let i = 0; i < objectLayers.length; i++) {
                let objectLayer = objectLayers[i];
                objectLayer.removeObserver(this);
            }
        }
        initView() {
            this.initBackgroundView();
            this.initContentView();
            this.initBlendAnimation();
            this.setPopupVisible(false);
        }
        initBackgroundView() {
            this.backgroundView = new GraphicsObject_16.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.backgroundView);
        }
        initContentView() {
            let fontSize = DeviceUtils_21.DeviceUtils.getPhysicalPixelsFromLogical(12);
            let style = {
                fill: 0x000000,
                fontFamily: "Arial",
                fontSize: fontSize,
            };
            this.contentView = new HighResTextObject_4.HighResTextObject(new HighResText_4.HighResText(2, "", style), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.contentView);
            // Translation
            this.contentView.x = this.paddingWidthInPx;
            this.contentView.y = this.paddingHeightInPx;
        }
        initBlendAnimation() {
            this.blendAnimation = new Animation_11.Animation(new LinearInterpolator_11.LinearInterpolator());
        }
        // Redrawing
        redrawBackgroundViewToFitWithContent() {
            let width = this.contentView.width + this.paddingWidthInPx * 2;
            let height = this.contentView.height + this.paddingHeightInPx * 2;
            this.redrawBackgroundView(width, height);
        }
        redrawBackgroundView(width, height) {
            this.backgroundView.clear();
            this.backgroundView.beginFill(0xffffff);
            this.backgroundView.lineStyle(1, 0x000000);
            this.backgroundView.drawRect(0, 0, width, height);
            this.backgroundView.endFill();
        }
        // Input Event-Handling
        // @Override
        onMouseStart(x, y) {
            super.onMouseStart(x, y);
            return false;
        }
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            this.updatePopupIfNecessary(x, y);
            if (this.hoveringObject !== null) {
                this.movePopupToObject();
            }
            return false;
        }
        updatePopupIfNecessary(x, y) {
            let collidingObject = this.building.getCurrentFloor().getCollidingObject(x, y, (object) => {
                return object.isPopupInfoSupported();
            });
            if (collidingObject !== null) {
                if (this.hoveringObject !== collidingObject) {
                    this.hoveringObject = collidingObject;
                    this.preparePopupForObject(this.hoveringObject);
                    this.setPopupVisible(true);
                }
            }
            else {
                if (this.hoveringObject !== null) {
                    this.hoveringObject = null;
                    this.setPopupVisible(false);
                }
            }
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            super.onTouchMove(x, y, touchIndex);
            if (this.popupIsVisible()) {
                if (this.hoveringObject != null) {
                    this.movePopupToObject();
                }
            }
            return false;
        }
        // @Override
        onMouseEnd(x, y) {
            super.onMouseEnd(x, y);
            return false;
        }
        preparePopupForObject(object) {
            this.fillPopupContentForObject(object);
            this.redrawBackgroundViewToFitWithContent();
            this.movePopupToObject();
        }
        fillPopupContentForObject(object) {
            let content = this.getContentForObject(object);
            this.contentView.text = "" + content;
        }
        movePopupToObject() {
            if (DeviceUtils_21.DeviceUtils.isMobileDevice()) {
                if (this.config.showPopupsOnTapForMobileDevices) {
                    this.movePopupToObjectMobile();
                }
            }
            else {
                this.movePopupToObjectDesktop();
            }
        }
        movePopupToObjectMobile() {
            let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
            let positionInScreenPx = worldCamera.getImageCoordinateFromWorldPoint(this.tapWorldPositionInTx);
            // Set the position.
            this.getView().x = positionInScreenPx.x;
            this.getView().y = positionInScreenPx.y;
        }
        movePopupToObjectDesktop() {
            let positionInScreenPx = new PIXI.Point(GestureRecognizer_6.GestureRecognizer.getMousePositionX(), GestureRecognizer_6.GestureRecognizer.getMousePositionY());
            // Rectangle should not go out of the screen.
            let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
            if (positionInScreenPx.x + this.backgroundView.width > worldCamera.getScreenWidth()) {
                positionInScreenPx.x -= this.backgroundView.width;
            }
            if (positionInScreenPx.y + this.backgroundView.height > worldCamera.getScreenHeight()) {
                positionInScreenPx.y -= this.backgroundView.height;
            }
            // Set the position.
            this.getView().x = positionInScreenPx.x;
            this.getView().y = positionInScreenPx.y;
        }
        // Tapping
        // @Override
        onTap(x, y, numTaps) {
            const handled = super.onTap(x, y, numTaps);
            if (this.config.showPopupsOnTapForMobileDevices) {
                if (DeviceUtils_21.DeviceUtils.isMobileDevice()) {
                    if (numTaps === 1) {
                        let worldCamera = this.building.getCurrentFloor().getScene().getCamera();
                        this.tapWorldPositionInTx = worldCamera.getWorldCoordinateFromImagePoint(new PIXI.Point(x, y));
                        // Act like a mouse move event on desktop browsers.
                        this.onMouseMove(x, y);
                    }
                }
            }
            return handled;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.updateAnimation(lastFrametime);
            this.updatePopupIfVisible(lastFrametime);
        }
        updateAnimation(lastFrametime) {
            if (this.blendAnimation.isCurrentlyAnimating()) {
                let currentAlpha = this.blendAnimation.getValue(lastFrametime);
                this.getView().alpha = currentAlpha;
            }
        }
        updatePopupIfVisible(lastFrametime) {
            if (this.hoveringObject != null) {
                let nowInMs = Date.now();
                if (nowInMs - this.lastPopupUpdateInMs > 1000) {
                    this.lastPopupUpdateInMs = nowInMs;
                    this.preparePopupForObject(this.hoveringObject);
                }
                this.movePopupToObject();
            }
        }
        // Floor Event handling
        // @Override
        floorChanged(floorBefore, floorAfter) {
            this.unobserveObjectLayers(floorBefore);
            this.observeObjectLayers(floorAfter);
        }
        // Event handling: Relution Map object layer changes
        // @Override
        onObjectsLoaded(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.getModel().addObserver(this);
            }
        }
        onObjectsUnloaded(objects) {
            for (let i = 0; i < objects.length; i++) {
                let object = objects[i];
                object.getModel().removeObserver(this);
            }
        }
        // Event handling: Relution object model changed
        // @Override
        modelChanged(model) {
            if (this.hoveringObject != null) {
                if (this.hoveringObject.getModel() === model) {
                    this.preparePopupForObject(this.hoveringObject);
                }
            }
        }
        // Event handling: Resizing
        // @Override
        onResize() {
            super.onResize();
            this.movePopupToObject();
        }
        // Getters and setters
        popupIsVisible() {
            return this.getView().alpha > 0;
        }
        setPopupVisible(visible) {
            let startValue = this.getView().alpha;
            let endValue = 0;
            if (visible) {
                endValue = PopupLayer.MAX_ALPHA;
            }
            else {
                endValue = 0.0;
            }
            let durationInMs = 1;
            let delayInMs = 0.0;
            this.blendAnimation.start(startValue, endValue, durationInMs, delayInMs);
        }
        setEnabled(enabled) {
            this.getRenderView().visible = enabled;
        }
        isEnabled() {
            return this.getRenderView().visible;
        }
    }
    PopupLayer.MAX_ALPHA = 0.8;
    exports.PopupLayer = PopupLayer;
    (function (PopupLayer) {
        class Config {
            constructor() {
                /**
                 * True, if a popup should appear on mobile devices, whenever the user taps on
                 * a Relution Map object.
                 *
                 * Default: true
                 */
                this.showPopupsOnTapForMobileDevices = true;
            }
        }
        PopupLayer.Config = Config;
    })(PopupLayer = exports.PopupLayer || (exports.PopupLayer = {}));
});
define("src/app/relution/view/hud/popupLayer/RelutionMapObjectPopupLayer", ["require", "exports", "src/app/relution/view/hud/popupLayer/PopupLayer"], function (require, exports, PopupLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapObjectPopupLayer extends PopupLayer_1.PopupLayer {
        // Initialization
        constructor(config, environment, building) {
            super(config, environment, building);
            this.observeHeatmapLayer(building.getCurrentFloor());
        }
        observeHeatmapLayer(currentFloor) {
            let heatmapLayer = currentFloor.getHeatmapLayer();
            heatmapLayer.addHeatmapObserver(this);
        }
        unobserveHeatmapLayer(leftFloor) {
            let heatmapLayer = leftFloor.getHeatmapLayer();
            heatmapLayer.removeHeatmapObserver(this);
        }
        // Updating content
        // @Override
        getContentForObject(object) {
            return object.getPopupInfo();
        }
        // Floor Event handling
        // @Override
        floorChanged(floorBefore, floorAfter) {
            super.floorChanged(floorBefore, floorAfter);
            this.unobserveHeatmapLayer(floorBefore);
            this.observeHeatmapLayer(floorAfter);
        }
        // Event-Handling: Updating heatmap model
        currentHeatmapModelChanged(heatmapLayer) {
            if (this.hoveringObject != null) {
                this.preparePopupForObject(this.hoveringObject);
            }
        }
    }
    exports.RelutionMapObjectPopupLayer = RelutionMapObjectPopupLayer;
});
define("src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer", ["require", "exports", "src/map/view/Layer"], function (require, exports, Layer_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Head-up-display layer part of the tape measure.
     *
     * <p>
     * This layer extends the [[TapeMeasureWorldLayer]] in the HUD scene by
     * preventing touch and pan events to be absorbed by the succeeding HUD layers
     * so that moving the edit points of the tape measure world layer is possible.
     * </p>
     */
    class TapeMeasureHudLayer extends Layer_15.Layer {
        // Construction
        constructor(environment, building) {
            super(environment);
            // Configuration
            this.enabled = false;
            // State
            this.touching = false;
            this.building = building;
        }
        // Event delegation: Low level events
        // @Override
        onTouchStart(x, y, touchIndex) {
            if (this.enabled) {
                if (this.shouldDragTapeMeasureEditPoints(x, y)) {
                    this.touching = true;
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchStart(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // @Override
        onTouchMove(x, y, touchIndex) {
            if (this.enabled) {
                if (this.touching) {
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchMove(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // @Override
        onTouchEnd(x, y, touchIndex) {
            if (this.enabled) {
                if (this.touching) {
                    this.touching = false;
                    // Delegate this event to the corresponding world layer
                    this.building.getCurrentFloor().getTapeMeasureLayer().onTouchEnd(x, y, touchIndex);
                    return true;
                }
            }
            return false;
        }
        // Event delegation: High level events
        // @Override
        onPanningStart(x, y) {
            if (this.enabled) {
                if (this.shouldDragTapeMeasureEditPoints(x, y)) {
                    this.touching = true;
                    return true;
                }
            }
            return false;
        }
        // @Override
        onPanningMove(x, y) {
            if (this.enabled) {
                if (this.touching) {
                    return true;
                }
            }
            return false;
        }
        // @Override
        onPanningEnd(x, y) {
            if (this.enabled) {
                if (this.touching) {
                    this.touching = false;
                    return true;
                }
            }
            return false;
        }
        // Helper methods
        shouldDragTapeMeasureEditPoints(x, y) {
            if (this.enabled) {
                const tapeMeasureWorldLayer = this.building.getCurrentFloor().getTapeMeasureLayer();
                return tapeMeasureWorldLayer.pointIsCloseToEditableArea(x, y);
            }
            return false;
        }
        // Getters and setters
        setEnabled(enabled) {
            this.enabled = enabled;
        }
        isEnabled() {
            return this.enabled;
        }
    }
    exports.TapeMeasureHudLayer = TapeMeasureHudLayer;
});
define("src/app/relution/view/hud/RelutionMapHud", ["require", "exports", "src/app/relution/view/hud/selectionLayer/SelectionLayer", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/app/relution/view/hud/barLayer/BarLayer", "src/app/relution/view/hud/helpLayer/HelpLayer", "src/map/view/Layer", "src/app/relution/view/hud/popupLayer/RelutionMapObjectPopupLayer", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer"], function (require, exports, SelectionLayer_1, NavigationLayer_1, ControlLayer_1, BarLayer_1, HelpLayer_1, Layer_16, RelutionMapObjectPopupLayer_1, PopupLayer_2, TapeMeasureHudLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapHud extends Layer_16.Layer {
        // Construction
        constructor(config, environment, relutionMapWorld) {
            super(environment);
            this.hudConfig = config;
            this.selectionLayer = new SelectionLayer_1.SelectionLayer(this.hudConfig.selectionLayer, environment, relutionMapWorld.getBuilding());
            this.navigationLayer = new NavigationLayer_1.NavigationLayer(this.hudConfig.navigationLayer, environment, relutionMapWorld.getCamera());
            this.popupLayer = new RelutionMapObjectPopupLayer_1.RelutionMapObjectPopupLayer(this.hudConfig.popupLayer, environment, relutionMapWorld.getBuilding());
            this.tapeMeasureLayer = new TapeMeasureHudLayer_1.TapeMeasureHudLayer(environment, relutionMapWorld.getBuilding());
            this.controlLayer = new ControlLayer_1.ControlLayer(this.hudConfig.controlLayer, environment, relutionMapWorld.getCamera());
            this.helpLayer = new HelpLayer_1.HelpLayer(environment);
            this.barLayer = new BarLayer_1.BarLayer(environment, relutionMapWorld.getWorld(), relutionMapWorld.getBuilding());
            this.addLayer(this.selectionLayer);
            this.addLayer(this.navigationLayer);
            this.addLayer(this.popupLayer);
            this.addLayer(this.tapeMeasureLayer);
            this.addLayer(this.controlLayer);
            this.addLayer(this.barLayer);
            this.addLayer(this.helpLayer);
        }
    }
    exports.RelutionMapHud = RelutionMapHud;
    (function (RelutionMapHud) {
        class Config {
            constructor() {
                this.selectionLayer = new SelectionLayer_1.SelectionLayer.Config();
                this.navigationLayer = new NavigationLayer_1.NavigationLayer.Config();
                this.popupLayer = new PopupLayer_2.PopupLayer.Config();
                this.controlLayer = new ControlLayer_1.ControlLayer.Config();
            }
        }
        RelutionMapHud.Config = Config;
    })(RelutionMapHud = exports.RelutionMapHud || (exports.RelutionMapHud = {}));
});
define("src/app/relution/modes/RelutionMapMode", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            // Configuration
            this.enabled = false;
            this.relutionMapWorld = relutionMapWorld;
            this.relutionMapHud = relutionMapHud;
        }
        // Getters and setters
        setEnabled(enabled) {
            if (enabled !== this.enabled) {
                this.enabled = enabled;
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        isEnabled() {
            return this.enabled;
        }
    }
    exports.RelutionMapMode = RelutionMapMode;
});
define("src/app/relution/modes/DeviceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceEditMode extends RelutionMapMode_1.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setDeviceEditingEnabled(enabled);
        }
        setModeEnabledInHud(enabled) {
            this.relutionMapHud.selectionLayer.setDeleteSelectedBeaconsAllowed(enabled);
            this.relutionMapHud.barLayer.makeBeaconBarVisible(enabled);
        }
    }
    exports.DeviceEditMode = DeviceEditMode;
});
define("src/app/relution/modes/GeofenceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class GeofenceEditMode extends RelutionMapMode_2.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            if (enabled) {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility("geofence", enabled);
            }
            this.relutionMapWorld.getBuilding().setGeofenceEditingEnabled(enabled);
        }
    }
    exports.GeofenceEditMode = GeofenceEditMode;
});
define("src/app/relution/utils/KeyUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class KeyUtils {
        static getKeyCodeForNumberKey(num) {
            return 48 + num;
        }
        static getKeyCodeForChar(char) {
            var keyCode = char.charCodeAt(0);
            if (keyCode > 90) { // 90 is keyCode for 'z'
                return keyCode - 32;
            }
            return keyCode;
        }
        static isCtrlKey(num) {
            return 17;
        }
    }
    exports.KeyUtils = KeyUtils;
});
define("src/app/relution/modes/DeviceTaggingMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode"], function (require, exports, RelutionMapMode_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class DeviceTaggingMode extends RelutionMapMode_3.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enabling/Disabling mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        setModeEnabled(enabled) {
            this.relutionMapWorld.getBuilding().toggleLayerVisibility("tagging", enabled);
            this.relutionMapWorld.getBuilding().setTaggingModeEnabled(enabled);
        }
    }
    exports.DeviceTaggingMode = DeviceTaggingMode;
});
define("src/app/relution/locale/LocalizationEn", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LocalizationEn extends Localization_2.Localization {
        constructor() {
            super();
            this.mapping = [];
            this.defineLocalization();
        }
        defineLocalization() {
            // Help
            this.mapping["device_info_average_users"] =
                "Average users";
            this.mapping["help_layer_mobile_device_description"] =
                "Zoom: Pinch\n" +
                    "Rotate: Pinch and Rotate\n" +
                    "Move: Pan\n" +
                    "Show beacon information: Tap\n";
            this.mapping["help_layer_non_mobile_device_description"] =
                "Zoom: Ctrl/Cmd + Mouse wheel\n" +
                    "Rotate: Alt + Shift + Mouse wheel\n" +
                    "Move: Ctrl/Cmd + Mouse\n" +
                    "Select: Mouse\n" +
                    "Multi-Select: Shift + Mouse\n" +
                    "Move Beacon: Alt + Shift + Mouse\n" +
                    "Move Beacon to stock: Del\n" +
                    "Turn on/off Layers: 1-9";
            // Action Bar
            this.mapping["action_bar_show_help_action"] = "Show help";
            this.mapping["action_bar_show_beacon_ranges_action"] = "Show beacon ranges";
            this.mapping["action_bar_show_connections_action"] = "Show beacon connections";
            this.mapping["action_bar_show_beacon_infos_action"] = "Show beacon infos";
            this.mapping["action_bar_show_device_tracks_action"] = "Show device tracks";
            this.mapping["action_bar_show_heatmap_action"] = "Show heatmap";
            // Popup: General
            this.mapping["popup_time_unit_prefix"] = "";
            this.mapping["popup_time_unit_postfix"] = " ago";
            this.mapping["popup_time_unit_year"] = "year";
            this.mapping["popup_time_unit_years"] = "years";
            this.mapping["popup_time_unit_month"] = "month";
            this.mapping["popup_time_unit_months"] = "months";
            this.mapping["popup_time_unit_day"] = "day";
            this.mapping["popup_time_unit_days"] = "days";
            this.mapping["popup_time_unit_hour"] = "h";
            this.mapping["popup_time_unit_hours"] = "h";
            this.mapping["popup_time_unit_minute"] = "min";
            this.mapping["popup_time_unit_minutes"] = "min";
            this.mapping["popup_time_unit_second"] = "s";
            this.mapping["popup_time_unit_seconds"] = "s";
            // Popup Layer: Device
            this.mapping["popup_device_name"] = "Name";
            this.mapping["popup_device_serial"] = "Serial";
            this.mapping["popup_device_last_connected"] = "Last connected";
            this.mapping["popup_device_node_id"] = "Node-ID";
            this.mapping["popup_device_version"] = "Beacon version";
            this.mapping["popup_device_meshgw_version"] = "MeshGateway version";
            this.mapping["popup_device_asset_id"] = "Asset-ID";
            this.mapping["popup_device_user_count"] = "User count";
            // Popup Layer: Geofence
            this.mapping["popup_geofence_name"] = "Name";
            this.mapping["popup_geofence_time_threshold"] = "Time threshold";
            this.mapping["popup_geofence_accuracy_threshold"] = "Accuracy threshold";
        }
        getLocalizedStringFor(placeholderString) {
            return this.mapping["" + placeholderString];
        }
    }
    exports.LocalizationEn = LocalizationEn;
});
define("src/app/relution/modes/SingleDeviceEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode", "src/map/utils/DeviceUtils"], function (require, exports, RelutionMapMode_4, DeviceUtils_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SingleDeviceEditMode extends RelutionMapMode_4.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
            // Configuration
            this.editableDeviceUuid = null;
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setSingleDeviceEditModeEnabled(enabled, this.editableDeviceUuid);
        }
        setModeEnabledInHud(enabled) {
            if (DeviceUtils_22.DeviceUtils.isMobileDevice()) {
                this.relutionMapHud.popupLayer.setEnabled(!enabled);
            }
            this.relutionMapHud.selectionLayer.setEnabled(!enabled);
        }
        // Getters and setters
        setEditableDevice(deviceUuid) {
            this.editableDeviceUuid = deviceUuid;
        }
    }
    exports.SingleDeviceEditMode = SingleDeviceEditMode;
});
define("src/app/relution/modes/TapeMeasureEditMode", ["require", "exports", "src/app/relution/modes/RelutionMapMode", "src/map/utils/DeviceUtils"], function (require, exports, RelutionMapMode_5, DeviceUtils_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A Relution map mode making creating and modifying the tape measure possible.
     */
    class TapeMeasureEditMode extends RelutionMapMode_5.RelutionMapMode {
        // Construction
        constructor(relutionMapWorld, relutionMapHud) {
            super(relutionMapWorld, relutionMapHud);
        }
        // Enable/disable mode
        // @Override
        enable() {
            this.setModeEnabled(true);
        }
        // @Override
        disable() {
            this.setModeEnabled(false);
        }
        // Helper methods
        setModeEnabled(enabled) {
            this.setModeEnabledInWorld(enabled);
            this.setModeEnabledInHud(enabled);
        }
        setModeEnabledInWorld(enabled) {
            this.relutionMapWorld.getBuilding().setTapeMeasureEditModeEnabled(enabled);
        }
        setModeEnabledInHud(enabled) {
            if (DeviceUtils_23.DeviceUtils.isMobileDevice()) {
                this.relutionMapHud.popupLayer.setEnabled(!enabled);
            }
            this.relutionMapHud.selectionLayer.setEnabled(!enabled);
            this.relutionMapHud.navigationLayer.setDoubleTapZoomingEnabled(!enabled);
            this.relutionMapHud.tapeMeasureLayer.setEnabled(enabled);
        }
    }
    exports.TapeMeasureEditMode = TapeMeasureEditMode;
});
define("src/app/relution/RelutionMap", ["require", "exports", "src/engine/scene/GameObject", "src/map/FruityMap", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/engine/input/GestureRecognizer", "src/app/relution/view/world/Floor", "src/app/relution/modes/DeviceEditMode", "src/app/relution/modes/GeofenceEditMode", "src/app/relution/view/world/RelutionMapWorld", "src/app/relution/view/hud/RelutionMapHud", "src/app/relution/utils/KeyUtils", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/modes/DeviceTaggingMode", "src/engine/scene/SceneObject", "src/app/relution/locale/LocalizationEn", "src/map/view/world/objects/WorldCamera", "src/app/relution/modes/SingleDeviceEditMode", "src/app/relution/modes/TapeMeasureEditMode"], function (require, exports, GameObject_5, FruityMap_1, Beacon_8, GestureRecognizer_7, Floor_2, DeviceEditMode_1, GeofenceEditMode_1, RelutionMapWorld_1, RelutionMapHud_1, KeyUtils_1, Asset_5, DeviceTaggingMode_1, SceneObject_14, LocalizationEn_1, WorldCamera_3, SingleDeviceEditMode_1, TapeMeasureEditMode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Relution map is a map application that is based on the FruityMap engine.
     *
     * <p>
     * It is used to display sites, beacons, assets, geofences and other site
     * specific elements in Relution. The FruityMap engine is used as a base layer
     * to manage rendering, scene graph construction, input event handling and
     * camera dynamics.
     * </p>
     *
     * <p>
     * The map basically contains two scenes:
     * </p>
     * <h3>1. Relution World</h3>
     * This scene contains a camera that can be moved both kinematically and dynamically (by applying impulses/forces).
     * All views inside the Relution world scene use world coordinates that correspond with the texels of the corresponding floorplan.
     * The Relution world builds up a highly nested view hierarchy, containing floors, and layers inside.
     * The leaf elements of this tree are mostly Relution map objects (e.g. beacons, geofences) and their corresponding
     * Relution map object attributes (e.g. beacon connections, ranges etc.).
     *
     * <h3>2. Relution HUD</h3>
     * This scene contains all the elements that should not move with the world camera. Thus, it uses its own static camera.
     * This scene is build up of many layers, like the selection layer that creates a selection rectangle, used for
     * selecting Relution map objects.
     *
     * <h3>Relution Map modes</h3>
     * <p>
     * The map can be set to a specific mode, e.g. device edit mode, geofence edit mode, tape measure edit mode etc.
     * Notice, that enabling a mode, will disable all other modes before, i.e. modes are mutually exclusive, as they
     * configure the the layers in the scenes by their demands. Combining multiple modes is currently not supported.
     * </p>
     */
    class RelutionMap {
        // Construction
        /**
         * Creates a new Relution map.
         * @param options See RelutionMap.Options for more information
         * @param floor The Relution map requires at least on floor. You must instantiate a floor first,
         * before you can create a Relution map.
         * @param initializedCallback This callback will be called, after the Relution Map has been initialized.
         * The initialization of the Relution Map includes creating a WebGL canvas, initializing the game and rendering engine,
         * building up the Relution World and Relution HUD scenes.
         */
        constructor(options) {
            // Configuration
            this.config = new RelutionMap.Options();
            // Observation
            this.observers = new Array();
            // Modes
            this.modes = new Array();
            this.config = options;
            this.environment = this.initEnvironment();
        }
        initEnvironment() {
            let environment = new RelutionMap.Environment();
            environment.scene.canvasSize.x = this.config.canvasWidth;
            environment.scene.canvasSize.y = this.config.canvasHeight;
            environment.scene.pixelRatio = this.config.pixelRatio;
            environment.scene.localization = this.config.localization;
            return environment;
        }
        /**
         * Creates a floor with name ```floorName``` and model ```floorModel```.
         * The config parameter is optional. If the config is null, the default floor configuration
         * specified in the building configuration will be used. If the config is not null, the default
         * floor configuration will be overridden by this one.
         * @param floorName
         * @param floorModel
         * @param config
         */
        createFloor(floorName, floorModel, config = null) {
            if (config === null) {
                config = this.config.world.building.floor;
            }
            let floor = new Floor_2.Floor(this.environment.scene, floorName, floorModel, config);
            return floor;
        }
        /**
         * Initializes the map. This loads all textures into the GPU and starts the rendering loop.
         * @param floor
         * @param initializedCallback
         */
        load(floor, initializedCallback) {
            // Create options
            let fruityMapOptions = new FruityMap_1.FruityMap.Options();
            fruityMapOptions.parentHtmlElement = this.config.parentHtmlElement;
            fruityMapOptions.camera = this.config.camera;
            fruityMapOptions.preloadingImages = this.getPreloadingImages(this.config.pathToImages);
            // Create map
            this.fruityMap = new FruityMap_1.FruityMap(fruityMapOptions, this.environment, () => {
                this.registerForInteractionEvents();
                this.initWorldLayers(floor);
                this.initHudLayers();
                this.initModes();
                this.addVisibilityObservers();
                initializedCallback();
            });
        }
        getPreloadingImages(pathToImages) {
            let images = [];
            let preloadingImageNames = this.getPreloadingImageNames();
            for (let i = 0; i < preloadingImageNames.length; i++) {
                let name = preloadingImageNames[i];
                images.push(this.getPreloadingImage(name, pathToImages));
            }
            return images;
        }
        // @Override
        getPreloadingImageNames() {
            return [
                "compass",
                "plus_normal",
                "minus_normal",
                "pan_center",
                "pan_down",
                "pan_up",
                "pan_left",
                "pan_right",
                "beacon_white",
                "range",
                "asset_device_white",
                "arrow_head",
                "arrow_head_transparent",
                "arrow_body"
            ];
        }
        getPreloadingImage(imageName, pathToImages) {
            return { resourceName: imageName, url: "" + pathToImages + "" + imageName + ".png" };
        }
        registerForInteractionEvents() {
            let that = this;
            this.fruityMap.addScenelessGameObject(new class extends GameObject_5.GameObject {
                constructor(environment) {
                    super(environment);
                }
                // @Override
                onKeyDown(keyCode) {
                    super.onKeyDown(keyCode);
                    that.updateEditMode();
                    that.changeFloorIfNecessary(keyCode);
                    that.updateLayerVisibility(keyCode);
                    return false;
                }
                // @Override
                onKeyUp(keyCode) {
                    super.onKeyUp(keyCode);
                    that.updateEditMode();
                    return false;
                }
                // @Override
                onMouseMove(x, y) {
                    super.onMouseMove(x, y);
                    // This event is used to disable edit mode if key up event
                    // was lost, because the user moved out of the window while
                    // holding the edit button.
                    that.updateEditMode();
                    return false;
                }
            }(this.fruityMap.getEnvironment()));
        }
        initWorldLayers(floor) {
            let world = this.fruityMap.getWorld();
            this.relutionMapWorld = new RelutionMapWorld_1.RelutionMapWorld(this.config.world, this.fruityMap.getEnvironment(), world, floor);
            world.addLayer(this.relutionMapWorld);
            this.relutionMapWorld.getBuilding().addRelutionMapObjectObserver(this);
        }
        initHudLayers() {
            let hud = this.fruityMap.getHud();
            this.relutionMapHud = new RelutionMapHud_1.RelutionMapHud(this.config.hud, this.fruityMap.getEnvironment(), this.relutionMapWorld);
            hud.addLayer(this.relutionMapHud);
            this.relutionMapHud.selectionLayer.addObserver(this);
            this.relutionMapHud.barLayer.getBeaconBar().addObserver(this);
        }
        initModes() {
            // Device edit mode
            this.deviceEditMode = new DeviceEditMode_1.DeviceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.deviceEditMode);
            // Single device edit mode
            this.singleDeviceEditMode = new SingleDeviceEditMode_1.SingleDeviceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.singleDeviceEditMode);
            if (this.config.world.building.floor.singleDeviceEditLayer.enabled) {
                this.singleDeviceEditMode.setEditableDevice(this.config.world.building.floor.singleDeviceEditLayer.editableDeviceUuid);
                this.singleDeviceEditMode.setEnabled(this.config.world.building.floor.singleDeviceEditLayer.enabled);
            }
            // Geofence edit mode
            this.geofenceEditMode = new GeofenceEditMode_1.GeofenceEditMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.geofenceEditMode);
            // Device tagging mode
            this.deviceTaggingMode = new DeviceTaggingMode_1.DeviceTaggingMode(this.relutionMapWorld, this.relutionMapHud);
            this.modes.push(this.deviceTaggingMode);
            // Tape measure edit mode
            this.tapeMeasureEditMode = new TapeMeasureEditMode_1.TapeMeasureEditMode(this.relutionMapWorld, this.relutionMapHud);
            if (this.config.world.building.floor.tapeMeasureLayer.editModeEnabled) {
                this.tapeMeasureEditMode.setEnabled(this.config.world.building.floor.tapeMeasureLayer.editModeEnabled);
            }
            this.modes.push(this.tapeMeasureEditMode);
        }
        addVisibilityObservers() {
            this.relutionMapHud.helpLayer.addVisiblityObserver(this);
        }
        // Destruction
        /**
         * In single page applications, it is necessary to completely destroy the map, whenever
         * the user changes the page and the map should be reloaded. A map destruction will release
         * all textures from the GPU and unregister all observers.
         */
        destroy() {
            this.unregisterAsObserver();
            this.unregisterVisibilityObservers();
            this.fruityMap.destroy();
        }
        unregisterAsObserver() {
            if (this.relutionMapHud.selectionLayer !== undefined) {
                this.relutionMapHud.selectionLayer.removeObserver(this);
            }
            if (this.relutionMapHud.barLayer !== undefined) {
                const beaconBar = this.relutionMapHud.barLayer.getBeaconBar();
                if (beaconBar) {
                    beaconBar.removeObserver(this);
                }
            }
            if (this.relutionMapWorld.getBuilding() !== undefined) {
                this.relutionMapWorld.getBuilding().removeRelutionMapObjectObserver(this);
            }
        }
        unregisterVisibilityObservers() {
            this.relutionMapHud.helpLayer.removeVisibilityObserver(this);
        }
        // Observation
        /**
         * Adds an observer to the list of observers. The observer will
         * get informed about all map events.
         * @param observer
         */
        addObserver(observer) {
            this.observers.push(observer);
        }
        notifyObservers(callback, args) {
            for (let i = 0; i < this.observers.length; i++) {
                let observer = this.observers[i];
                if (callback in observer) {
                    observer[callback].apply(observer, args);
                }
            }
        }
        // Time
        /**
         *
         * Configures the map animation.
         * @param startTimeInSec The start time of the animation given as a UNIX timestamp (in seconds).
         * @param endTimeInSec The end time of the animation given as a UNIX timestamp (in seconds).
         * @param durationInMs The duration of the animation (in milliseconds).
         * @param progressCallback A callback that will be called, whenever the progress changes.
         */
        setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback) {
            this.fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback);
        }
        /**
         * Returns the current animation configuration.
         */
        getAnimationConfiguration() {
            return this.fruityMap.getAnimationConfiguration();
        }
        /**
         * Starts the map animation starting with the start time given in the
         * animation's configuration.
         */
        startAnimation() {
            this.fruityMap.startAnimation();
        }
        /**
         * Stops the map animation.
         */
        stopAnimation() {
            this.fruityMap.stopAnimation();
        }
        /**
         * Pauses the map animation.
         */
        pauseAnimation() {
            this.fruityMap.pauseAnimation();
        }
        /**
         * Resumes the map animation.
         */
        resumeAnimation() {
            this.fruityMap.resumeAnimation();
        }
        /**
         * Sets the animation progress to the passed argument.
         * @param progress the animation progress in [0,1].
         */
        seekAnimation(progress) {
            this.fruityMap.seekAnimation(progress);
        }
        // Locale
        /**
         * Sets the map's locale to the passed argument
         * @param localization E.g. an instance of LocalizationDe or LocalizationEn
         */
        setLocalization(localization) {
            this.fruityMap.setLocalization(localization);
        }
        // Layers
        /**
         * Toggles the visibility of the given layer.
         *
         * @param layerName The layer's name. Possible values are:
         * "help": The layer containing the quick guide (tutorial).
         * "devices" The layer holding all devices (and their corresponding attributes)
         * "ranges": The beacon range layer
         * "info": The beacon info layer
         * "connections": The beacon connection layer
         * "tracking": The device tracking layer (position estimate paths for the assets).
         * "heatmap": The heatmap layer for the user count measurements.
         * "geofence": The geofence layer
         * @param enabled Optional argument. If it is missing the layer visibility will be toggled.
         * Otherwise the layer will be set visible, if "true" is passed, invisible, if the value is "false".
         */
        toggleLayerVisibility(layerName, enabled) {
            if (layerName === "help") {
                let layer = this.relutionMapHud.helpLayer;
                this.toggleLayer(layer, enabled);
            }
            else {
                this.relutionMapWorld.getBuilding().toggleLayerVisibility(layerName, enabled);
            }
        }
        toggleLayer(layer, enabled) {
            if (enabled == null) {
                layer.animateVisible(!layer.isVisible());
            }
            else {
                layer.animateVisible(enabled);
            }
        }
        // @Override
        visibilityChanged(layer) {
            if (layer == this.relutionMapHud.helpLayer) {
                let layerName = "help";
                let layerVisible = layer.isVisible();
                this.notifyObservers("onLayerVisibilityChanged", [layerName, layerVisible]);
            }
        }
        // Relution map objects
        /**
         * Toggles the visibility of all RelutionMap objects of type "objectTypeName".
         * Possible object type names: "beacon", "asset"
         * @param objectTypeName
         * @param visible
         */
        toggleRelutionMapObjectTypeVisibility(objectTypeName, visible) {
            this.relutionMapWorld.getBuilding().toggleRelutionMapObjectTypeVisibility(objectTypeName, visible, false);
        }
        toggleRelutionMapObjectTypeVisibilityWithNotification(objectTypeName, visible) {
            this.relutionMapWorld.getBuilding().toggleRelutionMapObjectTypeVisibility(objectTypeName, visible, true);
        }
        // Event-Handling
        // Events: World and HUD
        // @Override
        onBeaconEnteredWorld() {
            this.setEditModeActive(true);
        }
        // @Override
        onBeaconLeftWorld() {
            this.setEditModeActive(false);
        }
        // @Override
        onUserStoppedMovingBeacon() {
            this.setEditModeActive(false);
        }
        // @Override
        onObjectSelected(object) {
            this.notifyObservers("onObjectSelected", [object]);
        }
        // @Override
        onObjectUnselected(object) {
            this.notifyObservers("onObjectUnselected", [object]);
        }
        // @Override
        onObjectDoubleClicked(object) {
            this.notifyObservers("onObjectDoubleClicked", [object]);
        }
        // Beacon adding/removing
        // @Override
        onObjectMovedToMap(beacon) {
            this.notifyObservers("onObjectMovedToMap", [beacon]);
        }
        // @Override
        onObjectMovedToStock(beacon) {
            this.notifyObservers("onObjectMovedToStock", [beacon]);
        }
        // Object type visibility
        // @Override
        onObjectTypeVisibilityChanged(objectTypeName, visible) {
            this.notifyObservers("onObjectTypeVisibilityChanged", [objectTypeName, visible]);
        }
        // Layer visibility
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            this.notifyObservers("onLayerVisibilityChanged", [layerName, visible]);
        }
        // Event-Handling: Key events
        changeFloorIfNecessary(keyCode) {
            const arrowUpKeyCode = 38;
            const arrowDownKeyCode = 40;
            if (GestureRecognizer_7.GestureRecognizer.isCtrlPressed()) {
                if (keyCode === arrowUpKeyCode) {
                    this.getBuilding().changeToUpperFloor();
                }
                else if (keyCode === arrowDownKeyCode) {
                    this.getBuilding().changeToLowerFloor();
                }
            }
        }
        updateLayerVisibility(keyCode) {
            if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(1)) {
                this.toggleLayerVisibility("help");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(2)) {
                this.toggleLayerVisibility("wallplan");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(3)) {
                this.toggleLayerVisibility("devices");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(4)) {
                this.toggleLayerVisibility("geofence");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(5)) {
                this.toggleRelutionMapObjectTypeVisibilityWithNotification(Beacon_8.Beacon.name);
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(6)) {
                this.toggleRelutionMapObjectTypeVisibilityWithNotification(Asset_5.Asset.name);
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(7)) {
                this.toggleLayerVisibility("info");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(8)) {
                this.toggleLayerVisibility("ranges");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(9)) {
                this.toggleLayerVisibility("connections");
            }
            else if (keyCode === KeyUtils_1.KeyUtils.getKeyCodeForNumberKey(0)) {
                this.toggleLayerVisibility("tracking");
            }
        }
        updateEditMode() {
            if (GestureRecognizer_7.GestureRecognizer.isAltPressed()) {
                this.setEditModeActive(true);
            }
            else if (this.isEditModeActive() && !GestureRecognizer_7.GestureRecognizer.isAltPressed()) {
                this.setEditModeActive(false);
            }
        }
        // Modes
        /**
         * Returns true, if the edit mode is currently active.
         */
        isEditModeActive() {
            return this.relutionMapWorld.getBuilding().isEditModeActive();
        }
        /**
         * Sets the edit mode to active, if true was passed.
         * @param editModeActive
         */
        setEditModeActive(editModeActive) {
            if (!this.isDeviceEditModeEnabled()) {
                this.relutionMapWorld.getBuilding().setEditModeActive(editModeActive);
            }
        }
        /**
         * Enables/disables the geofence edit mode.
         *
         * <p>
         * In the geofence edit mode, geofences can be moved on the map. Moreover,
         * the shape of the geofences can be edited.
         * </p>
         *
         * @param enabled
         */
        setGeofenceEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.geofenceEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the geofence edit mode is enabled.
         */
        isGeofenceEditModeEnabled() {
            return this.geofenceEditMode.isEnabled();
        }
        /**
         * Enables/disables the device edit mode.
         *
         * <p>
         * In the device edit mode, devices can be moved on the map. Moreover, the
         * beacon bar is enabled in this mode making it possible to move beacon from
         * the stock into the map and vice versa.
         * </p>
         *
         * @param deviceEditModeEnabled
         */
        setDeviceEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.deviceEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the device edit mode is enabled.
         */
        isDeviceEditModeEnabled() {
            return this.deviceEditMode.isEnabled();
        }
        /**
         * Enables/disables the single device edit mode.
         *
         * <p>
         * This edit mode supports only editing one specific device. All other
         * devices will be locked.
         * </p>
         *
         * @param enabled true, if the edit mode should be enabled
         */
        setSingleDeviceEditModeEnabled(enabled, deviceUuid) {
            if (enabled) {
                this.disableAllModes();
            }
            this.singleDeviceEditMode.setEditableDevice(deviceUuid);
            this.singleDeviceEditMode.setEnabled(enabled);
        }
        /**
         * @see [[setSingleDeviceEditModeEnabled]]
         */
        isSingleDeviceEditModeEnabled() {
            return this.singleDeviceEditMode.isEnabled();
        }
        /**
         * Enables the tagging mode. In tagging mode the user can
         * move devices to their "real" positions which is used
         * to calibrate the indoor positioning system.
         * @param enabled
         */
        setDeviceTaggingModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.deviceTaggingMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the tagging mode is enabled.
         */
        isTaggingModeEnabled() {
            return this.deviceTaggingMode.isEnabled();
        }
        /**
         * Sets the tape measure edit mode to enabled/disabled.
         *
         * <p>
         * The tape measure edit mode makes it possible to create a rectangular tape
         * measure showing the width and height and the diagonal length of the tape
         * measure. The rectangle can be created by sequentially tapping on two
         * positions on the map. A third tap will remove the tape measure rectangle.
         * Moreover, in the edit mode, it is possible to drag and drop the corners
         * of the rectangle. When leaving the edit mode, editing the corners is not
         * possible anymore. Hence, the tape measure rectangle is fixed.
         * </p>
         *
         * <p>
         * Notice, that leaving the tape measure edit mode will not make the tape
         * measure invisible. Only editing the tape measure rectangle is not
         * possible anymore.
         * </p>
         *
         * @param enabled true, if the tape measure edit mode should be enabled.
         */
        setTapeMeasureEditModeEnabled(enabled) {
            if (enabled) {
                this.disableAllModes();
            }
            this.tapeMeasureEditMode.setEnabled(enabled);
        }
        /**
         * Returns true, if the tape measure edit mode is enabled.
         *
         * @see [[RelutionMap#setTapeMeasureEditModeEnabled]]
         */
        isTapeMeasureEditModeEnabled() {
            return this.tapeMeasureEditMode.isEnabled();
        }
        disableAllModes() {
            for (let i = 0; i < this.modes.length; i++) {
                const mode = this.modes[i];
                if (mode.isEnabled()) {
                    mode.setEnabled(false);
                }
            }
        }
        // Rendering
        /**
         * Resizes the map's canvas to the specified width and height
         * @param width The target width (in pixels)
         * @param height The target height (in pixels)
         */
        setSize(width, height) {
            if (this.getWidth() !== width || this.getHeight() !== height) {
                this.fruityMap.setCanvasSize(width, height);
            }
        }
        /**
         * Returns the current canvas width of the map (in pixels).
         */
        getWidth() {
            return this.fruityMap.getCanvasWidth();
        }
        /**
         * Returns the current canvas height of the map (in pixels).
         */
        getHeight() {
            return this.fruityMap.getCanvasHeight();
        }
        // State
        /**
         * Pauses the map rendering and event handling
         */
        pause() {
            this.fruityMap.pause();
        }
        resume() {
            this.fruityMap.resume();
        }
        // Getters and setters
        getConfig() {
            return this.config;
        }
        /**
         * Returns the Relution map's building.
         */
        getBuilding() {
            return this.relutionMapWorld.getBuilding();
        }
        getDeviceInfoPopupLayer() {
            return this.relutionMapHud.popupLayer;
        }
    }
    exports.RelutionMap = RelutionMap;
    (function (RelutionMap) {
        /**
         * The options must be passt to the RelutionMaps constructor.
         */
        class Options {
            constructor() {
                // General
                // Rendering
                /**
                 * The width of the WebGL canvas given in pixels.
                 */
                this.canvasWidth = window.innerWidth;
                /**
                 * The height of the WebGL canvas given in pixels.
                 */
                this.canvasHeight = window.innerHeight;
                /**
                 * The ratio between physical pixels and device-independent pixels (dips) on the device.
                 *
                 * Default: window.devicePixelRatio
                 */
                this.pixelRatio = window.devicePixelRatio;
                // Localization
                /**
                 * The initial localization for english or german
                 * text translations.
                 * E.g. LocalizationDe or LocalizationEn
                 */
                this.localization = new LocalizationEn_1.LocalizationEn();
                // Camera
                /**
                 * Configuration of the world camera.
                 */
                this.camera = new WorldCamera_3.WorldCamera.Config();
                // HUD
                /**
                 * Config of the Relution map HUD.
                 */
                this.hud = new RelutionMapHud_1.RelutionMapHud.Config();
                // World
                /**
                 * Config of the Relution map world
                 */
                this.world = new RelutionMapWorld_1.RelutionMapWorld.Config();
            }
        }
        RelutionMap.Options = Options;
        class Environment {
            constructor() {
                this.scene = new SceneObject_14.SceneObject.Environment();
            }
        }
        RelutionMap.Environment = Environment;
    })(RelutionMap = exports.RelutionMap || (exports.RelutionMap = {}));
});
define("src/app/portal/PortalMap", ["require", "exports", "src/app/relution/RelutionMap"], function (require, exports, RelutionMap_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PortalMap extends RelutionMap_1.RelutionMap {
    }
    exports.PortalMap = PortalMap;
    (function (PortalMap) {
        class Options extends RelutionMap_1.RelutionMap.Options {
        }
        PortalMap.Options = Options;
    })(PortalMap = exports.PortalMap || (exports.PortalMap = {}));
});
define("src/app/relution/events/RelutionEventSystem", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The relution event system is used as the observer-mediator for decoupled event communication
     * between scene objects inside the relution map.
     *
     * Publish-Subscribe event system:
     * The event communication is based on a publish-subscribe mechanism.
     *
     * Event stickiness
     * Scene objects that are created at a later time, however, may miss important events,
     * like a change in the map mode. Thus, all events are "sticky, i.e. we always
     * provide getters and setters for the events so that subscribers may fetch the event
     * at a later time.
     *
     * @export
     * @class RelutionEventSystem
     */
    class RelutionEventSystem {
        // Construction
        constructor() {
            // Subscribers
            this.subscriptions = new Array();
            // Private -> Singleton
        }
        static getInstance() {
            if (RelutionEventSystem.instance == null) {
                RelutionEventSystem.instance = new RelutionEventSystem();
            }
            return RelutionEventSystem.instance;
        }
        // Subscription
        subscribe(eventName, subscriber) {
            if (!this.existsSubscription(eventName, subscriber)) {
                let subscription = new RelutionEventSystem.Subscription(eventName, subscriber);
                this.subscriptions.push(subscription);
            }
        }
        unsubscribe(eventName, subscriber) {
            let index = this.getIndexOfSubscription(eventName, subscriber);
            if (index > -1) {
                this.subscriptions.splice(index, 1);
            }
        }
        existsSubscription(eventName, subscriber) {
            return this.getIndexOfSubscription(eventName, subscriber) > -1;
        }
        getIndexOfSubscription(eventName, subscriber) {
            for (let i = 0; i < this.subscriptions.length; i++) {
                let subscription = this.subscriptions[i];
                if (subscription.eventName === eventName && subscription.subscriber === subscriber) {
                    return i;
                }
            }
            return -1;
        }
        // Publication
        publish(eventName) {
            for (let i = 0; i < this.subscriptions.length; i++) {
                let subscription = this.subscriptions[i];
                if (subscription.eventName === eventName) {
                    this.publishEventToSubscriber(eventName, subscription.subscriber);
                }
            }
        }
        publishEventToSubscriber(eventName, subscriber) {
            if (subscriber !== null) {
                const prefix = "onRelution";
                const callbackName = prefix + eventName;
                if (typeof subscriber["" + callbackName] === "function") {
                    subscriber["" + callbackName].apply(subscriber, []);
                }
            }
        }
        publishEventForProperty(propertyName) {
            this.publish(propertyName + "Changed");
        }
    }
    // Singleton instance
    RelutionEventSystem.instance = null;
    exports.RelutionEventSystem = RelutionEventSystem;
    (function (RelutionEventSystem) {
        class Subscription {
            constructor(eventName, subscriber) {
                this.eventName = eventName;
                this.subscriber = subscriber;
            }
        }
        RelutionEventSystem.Subscription = Subscription;
    })(RelutionEventSystem = exports.RelutionEventSystem || (exports.RelutionEventSystem = {}));
});
define("src/app/relution/locale/LocalizationDe", ["require", "exports", "src/engine/locale/Localization"], function (require, exports, Localization_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LocalizationDe extends Localization_3.Localization {
        constructor() {
            super();
            this.mapping = [];
            this.defineLocalization();
        }
        defineLocalization() {
            // Help
            this.mapping["device_info_average_users"] =
                "Durchschnittliche Benutzerzahl";
            this.mapping["help_layer_mobile_device_description"] =
                "Zoomen: Pinch-Geste\n" +
                    "Rotieren: Pinch- und Rotieren-Geste\n" +
                    "Bewegen: Pan-Geste\n" +
                    "Gerteinformationen anzeigen: Klicken\n";
            this.mapping["help_layer_non_mobile_device_description"] =
                "Zoomen: Strg/Cmd + Mausrad\n" +
                    "Rotieren: Alt + Shift + Mausrad\n" +
                    "Bewegen: Strg/Cmd + Maus\n" +
                    "Auswhlen: Maus\n" +
                    "Mehrfachauswahl: Shift + Maus\n" +
                    "Beacon bewegen: Alt + Shift + Maus\n" +
                    "Beacon ins Lager verschieben: Entf\n" +
                    "Ebenen ein-/ausschalten: 1-9";
            // Action Bar
            this.mapping["action_bar_show_help_action"] = "Hilfe anzeigen";
            this.mapping["action_bar_show_beacon_ranges_action"] = "Beaconkreise anzeigen";
            this.mapping["action_bar_show_connections_action"] = "Beaconverbindungen anzeigen";
            this.mapping["action_bar_show_beacon_infos_action"] = "Gerteinformationen anzeigen";
            this.mapping["action_bar_show_device_tracks_action"] = "Gertespuren anzeigen";
            this.mapping["action_bar_show_heatmap_action"] = "Heatmap anzeigen";
            // Popup: General
            this.mapping["popup_time_unit_prefix"] = "vor ";
            this.mapping["popup_time_unit_postfix"] = "";
            this.mapping["popup_time_unit_year"] = "Jahr";
            this.mapping["popup_time_unit_years"] = "Jahren";
            this.mapping["popup_time_unit_month"] = "Monat";
            this.mapping["popup_time_unit_months"] = "Monaten";
            this.mapping["popup_time_unit_day"] = "Tag";
            this.mapping["popup_time_unit_days"] = "Tagen";
            this.mapping["popup_time_unit_hour"] = "h";
            this.mapping["popup_time_unit_hours"] = "h";
            this.mapping["popup_time_unit_minute"] = "min";
            this.mapping["popup_time_unit_minutes"] = "min";
            this.mapping["popup_time_unit_second"] = "s";
            this.mapping["popup_time_unit_seconds"] = "s";
            // Popup Layer: Device
            this.mapping["popup_device_name"] = "Name";
            this.mapping["popup_device_serial"] = "Seriennummer";
            this.mapping["popup_device_last_connected"] = "Zuletzt gemeldet";
            this.mapping["popup_device_node_id"] = "Node-ID";
            this.mapping["popup_device_version"] = "Beacon-Version";
            this.mapping["popup_device_meshgw_version"] = "MeshGateway-Version";
            this.mapping["popup_device_asset_id"] = "Asset-ID";
            this.mapping["popup_device_user_count"] = "Benutzerzahl";
            // Popup Layer: Geofence
            this.mapping["popup_geofence_name"] = "Name";
            this.mapping["popup_geofence_time_threshold"] = "Mindestverweildauer";
            this.mapping["popup_geofence_accuracy_threshold"] = "Bentigte Schtzgenauigkeit";
        }
        getLocalizedStringFor(placeholderString) {
            return this.mapping["" + placeholderString];
        }
    }
    exports.LocalizationDe = LocalizationDe;
});
define("src/app/relution/model/RelutionMapModelLoader", ["require", "exports", "src/map/utils/Logger", "src/app/relution/model/Model"], function (require, exports, Logger_5, Model_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An object mapper that is able to deserialize/serialize JSON arrays/objects to arrays/objects of type @code{RelutionMapModel}.
     *
     * <h2>Model inheritance</h2>
     * <p>
     * The serialization/deserialization process considers both polymorphic structures,
     * if the model subclass is annotated correctly with @ModelTypeInfo and @ModelSubTypes decorators.
     * </p>
     *
     * <h2>Model composition</h2>
     * <p>
     * The serialization/deserialization process also considers compositions of @code{RelutionMapModel} objects.
     * This, however, requires the @ModelProperty annotated data field to pass an options, containing the correct class consturctor:
     * E.g.
     * </p>
     *
     * <p>
     * @ModelProperty({clazz: MySubModelClass})
     * private _x : MySubModelClass = 0;
     * </p>
     *
     * <p>
     * Moreover, you can also force the serialization/deserialization to cast to a specific type, e.g.:
     * </p>
     *
     * <p>
     * @ModelProperty({clazz: Number})
     * private _x : number = 0;
     * </p>
     *
     * If your model structure is flattened, you must use the {@code findInd} field in the options of @ModelProperty. E.g.
     *
     * <p>
     * @ModelProperty({findIn: "properties"})
     * private _x : number = 0;
     * </p>
     *
     * will map "jsonObject.properties.x" to model.x.
     *
     * @export
     * @class ModelLoader
     */
    class RelutionMapModelLoader {
        // Deserialization
        /**
         * Deserializes @code{jsonModels} and returns a list of models of the generic type @code{M}.
         * @param jsonModels An array containing models of type M
         * @param modelClassConstructor The constructor function to create models of type M
         * @param isPortalMode Set this value to true, if @code{jsonModels} is a collection from Relution portal.
         */
        static loadModels(jsonModels, modelClassConstructor, isPortalMode = false) {
            let models = Array();
            for (let i = 0; i < jsonModels.length; i++) {
                // Extract the object to be parsed.
                let jsonObject = jsonModels[i];
                // Load the model
                let model = RelutionMapModelLoader.loadModel(jsonObject, modelClassConstructor, isPortalMode);
                // Add object to array
                models.push(model);
            }
            return models;
        }
        static loadModel(jsonObject, modelClassConstructor, isPortalMode = false) {
            let object = null;
            if (isPortalMode) {
                object = jsonObject.attributes;
            }
            else {
                object = jsonObject;
            }
            let model = this.createInstanceOfCorrectSubclass(object, modelClassConstructor);
            this.assignJsonValuesToModel(object, model, isPortalMode);
            return model;
        }
        static createInstanceOfCorrectSubclass(jsonObject, modelClassConstructor) {
            // Load the subtype bindings by calling the default constructor
            let model = new modelClassConstructor();
            // Polymorphic deserialization if necessary.
            let typeFieldName = Model_10.Model.getTypeFieldForModelClass(modelClassConstructor);
            if (typeFieldName !== null) {
                if (jsonObject[typeFieldName] !== null && jsonObject[typeFieldName] !== undefined) {
                    let type = jsonObject[typeFieldName];
                    let subClassConstructor = Model_10.Model.getModelClassForType(type);
                    if (subClassConstructor !== null) {
                        model = new subClassConstructor();
                    }
                    else {
                        Logger_5.Logger.logDebug("Failed to map the type field \'" + typeFieldName
                            + "\'" + " with value \'" + type + "\' to a model class. Probably @ModelSubType is missing.");
                    }
                }
                else {
                    Logger_5.Logger.logDebug("Model could not be parsed. Type field \'"
                        + typeFieldName + "\' needed for polymorphic deserialization is missing.");
                }
            }
            return model;
        }
        static assignJsonValuesToModel(jsonObject, model, isPortalMode) {
            const classBindings = Model_10.Model.getPropertyBindingsForObject(model);
            for (let i = 0; i < classBindings.length; i++) {
                const classBinding = classBindings[i];
                for (let fieldName of Array.from(classBinding.propertyNameToOption.keys())) {
                    const propertyName = fieldName.substring(1, fieldName.length);
                    try {
                        const propertyOptions = classBinding.propertyNameToOption.get(fieldName);
                        if (propertyOptions !== undefined) {
                            const parentJsonObject = RelutionMapModelLoader.getParentJsonObject(jsonObject, propertyOptions);
                            if (propertyName in parentJsonObject && parentJsonObject[propertyName] !== null) {
                                RelutionMapModelLoader.assignJsonValueToModelProperty(propertyName, parentJsonObject, model, propertyOptions, isPortalMode);
                            }
                        }
                    }
                    catch (e) {
                        Logger_5.Logger.logDebug("Failed to deserialize model property \"" + propertyName + "\". " + e);
                    }
                }
            }
        }
        static getParentJsonObject(jsonObject, propertyOptions) {
            let object = jsonObject;
            if (propertyOptions.findIn !== undefined) {
                object = jsonObject[propertyOptions.findIn];
            }
            return object;
        }
        static assignJsonValueToModelProperty(propertyName, parentJsonObject, model, propertyOptions, isPortalMode) {
            if (propertyOptions.clazz !== undefined) {
                // Assignment with explicit casting
                if (propertyOptions.clazz === Number) {
                    if (typeof parentJsonObject[propertyName] === "string") {
                        model[propertyName] = Number.parseFloat(parentJsonObject[propertyName]);
                    }
                    else {
                        model[propertyName] = Number(parentJsonObject[propertyName]);
                    }
                }
                else if (propertyOptions.clazz === Boolean) {
                    if (typeof parentJsonObject[propertyName] === "string") {
                        model[propertyName] = parentJsonObject[propertyName] === "true" ? true : false;
                    }
                    else {
                        model[propertyName] = Boolean(parentJsonObject[propertyName]);
                    }
                }
                else {
                    if (Array.isArray(parentJsonObject[propertyName])) {
                        model[propertyName] = RelutionMapModelLoader.loadModels(parentJsonObject[propertyName], propertyOptions.clazz, isPortalMode);
                    }
                    else {
                        model[propertyName] = RelutionMapModelLoader.loadModel(parentJsonObject[propertyName], propertyOptions.clazz, isPortalMode);
                    }
                }
            }
            else {
                // Assignment with implicit casting
                if (Array.isArray(parentJsonObject[propertyName])) {
                    model[propertyName] = parentJsonObject[propertyName].slice();
                }
                else {
                    model[propertyName] = parentJsonObject[propertyName];
                }
            }
        }
        // Serialization
        /**
         * Synchronizes the 'jsonArray' with the Relution Map internal 'models'.
         * This method guarantees the jsonArray to have the same data field values as the ones contained in 'models'.
         * This method, however does not add or remove models from the JSON array!
         * @param models The Relution Map internal models
         * @param jsonArray A JSON array containing the models obtained from Relution.
         * @param isPortalMode True, if this method is called from Relution Portal
         */
        static syncModels(models, jsonArray, isPortalMode = false) {
            for (let i = 0; i < models.length; i++) {
                let model = models[i];
                let object = this.getJsonObjectForModel(model, jsonArray, isPortalMode);
                if (object !== null) {
                    this.syncModel(model, object, isPortalMode);
                }
            }
        }
        static getJsonObjectForModel(model, jsonArray, isPortalMode) {
            for (let i = 0; i < jsonArray.length; i++) {
                let jsonObject = jsonArray[i];
                let object = jsonObject;
                if (isPortalMode) {
                    object = jsonObject.attributes;
                }
                if (object.uuid === model.uuid) {
                    return jsonObject;
                }
            }
            return null;
        }
        static syncModel(model, jsonObject, isPortalMode = false) {
            let object = jsonObject;
            if (isPortalMode) {
                object = jsonObject.attributes;
            }
            this.assignModelPropertyValuesToJson(model, object, isPortalMode);
        }
        static assignModelPropertyValuesToJson(model, jsonObject, isPortalMode) {
            const classBindings = Model_10.Model.getPropertyBindingsForObject(model);
            for (let i = 0; i < classBindings.length; i++) {
                const classBinding = classBindings[i];
                for (let fieldName of Array.from(classBinding.propertyNameToOption.keys())) {
                    const propertyName = fieldName.substring(1, fieldName.length);
                    try {
                        const propertyOptions = classBinding.propertyNameToOption.get(fieldName);
                        if (propertyOptions !== undefined) {
                            const parentJsonObject = RelutionMapModelLoader.getParentJsonObject(jsonObject, propertyOptions);
                            if (propertyName in parentJsonObject) {
                                RelutionMapModelLoader.assignModelPropertyValueToJson(propertyName, parentJsonObject, model, propertyOptions, isPortalMode);
                            }
                        }
                    }
                    catch (e) {
                        Logger_5.Logger.logDebug("Failed to serialize model property \"" + propertyName + "\". " + e);
                    }
                }
            }
        }
        static assignModelPropertyValueToJson(propertyName, parentJsonObject, model, propertyOptions, isPortalMode) {
            if (propertyOptions.clazz !== undefined) {
                // Assignment with explicit casting
                if (propertyOptions.clazz === Number) {
                    if (typeof model[propertyName] === "string") {
                        parentJsonObject[propertyName] = Number.parseFloat(model[propertyName]);
                    }
                    else {
                        parentJsonObject[propertyName] = Number(model[propertyName]);
                    }
                }
                else if (propertyOptions.clazz === Boolean) {
                    if (typeof model[propertyName] === "string") {
                        parentJsonObject[propertyName] = model[propertyName] === "true" ? true : false;
                    }
                    else {
                        parentJsonObject[propertyName] = Boolean(model[propertyName]);
                    }
                }
                else {
                    if (Array.isArray(model[propertyName])) {
                        RelutionMapModelLoader.syncModels(model[propertyName], parentJsonObject[propertyName], isPortalMode);
                    }
                    else {
                        RelutionMapModelLoader.syncModel(model[propertyName], parentJsonObject[propertyName], isPortalMode);
                    }
                }
            }
            else {
                // Assignment with implicit casting
                if (Array.isArray(model[propertyName])) {
                    parentJsonObject[propertyName] = model[propertyName].slice();
                }
                else {
                    parentJsonObject[propertyName] = model[propertyName];
                }
            }
        }
    }
    exports.RelutionMapModelLoader = RelutionMapModelLoader;
});
define("src/app/relution/model/floor/FloorModelLoader", ["require", "exports", "src/app/relution/model/floor/FloorModel", "src/map/utils/Logger"], function (require, exports, FloorModel_1, Logger_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class FloorModelLoader {
        static loadFloor(options) {
            let object = options.jsonObject;
            if (options.isPortalMode) {
                object = options.jsonObject.attributes;
            }
            // Create new floor model
            let floorModel = new FloorModel_1.FloorModel();
            // Floorplan
            floorModel.floorplanImageUrl = options.pathToFloorplan;
            floorModel.wallplanImageUrl = options.wallplanUrl;
            if (options.floorplanOverlayNameToImageUrl === undefined) {
                floorModel.floorplanOverlayNameToImageUrl = new Map();
            }
            else {
                floorModel.floorplanOverlayNameToImageUrl = options.floorplanOverlayNameToImageUrl;
            }
            floorModel.floorplanUsesSvg = false;
            if (floorModel.floorplanUsesSvg) {
                this.loadSvg(floorModel);
            }
            // Position
            if ("latitude" in object) {
                floorModel.latitude = object.latitude;
            }
            if ("longitude" in object) {
                floorModel.longitude = object.longitude;
            }
            if ("floorBaseInMeter" in object) {
                floorModel.floorBaseInMeter = object.floorBaseInMeter;
            }
            if ("defaultSmartBeaconHeight" in object) {
                floorModel.defaultSmartBeaconHeight = object.defaultSmartBeaconHeight;
            }
            if ("defaultAssetHeight" in object) {
                floorModel.defaultAssetHeight = object.defaultAssetHeight;
            }
            // Scale
            if ("pixelPerMeter" in object) {
                floorModel.pixelPerMeter = object.pixelPerMeter;
            }
            if ("lengthInMeter" in object) {
                floorModel.lengthInMeter = object.lengthInMeter;
            }
            // Orientation
            if ("orientation" in object) {
                floorModel.orientation = object.orientation;
            }
            return floorModel;
        }
        static loadSvg(floorModel) {
            let client = new XMLHttpRequest();
            client.open("GET", "" + floorModel.floorplanImageUrl, false);
            client.onreadystatechange = function () {
                if (client.readyState === XMLHttpRequest.DONE) {
                    if (client.status === 200) {
                        floorModel.floorplanSvg = client.responseText;
                        floorModel.floorplanImageUrl = "data:image/svg+xml;base64," + window.btoa("" + floorModel.floorplanSvg);
                    }
                    else {
                        Logger_6.Logger.logDebug("Failed to load file");
                    }
                }
                floorModel.floorplanSvg = client.responseText;
            };
            client.send();
        }
    }
    exports.FloorModelLoader = FloorModelLoader;
    (function (FloorModelLoader) {
        class Options {
            constructor() {
                this.wallplanUrl = null;
                this.floorplanOverlayNameToImageUrl = new Map();
                this.isPortalMode = false;
            }
        }
        FloorModelLoader.Options = Options;
    })(FloorModelLoader = exports.FloorModelLoader || (exports.FloorModelLoader = {}));
});
define("src/app/relution/utils/ReflectionUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ReflectionUtils {
        static getAllPropertyNames(obj) {
            let props = [];
            do {
                Object.getOwnPropertyNames(obj).forEach(function (prop) {
                    if (props.indexOf(prop) === -1) {
                        props.push(prop);
                    }
                });
            } while (obj = Object.getPrototypeOf(obj));
            return props;
        }
    }
    exports.ReflectionUtils = ReflectionUtils;
});
define("src/app/relution/utils/SerialNumberUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SerialNumberUtils {
        static generateBeaconSerialForIndex(index) {
            let serial = "";
            while (serial.length < this.SERIAL_NUMBER_LENGTH) {
                let rest = index % this.ALPHABET.length;
                serial += this.ALPHABET.substring(rest, rest + 1);
                index /= this.ALPHABET.length;
            }
            return serial.split("").reverse().join("");
        }
        static generateAssetSerialForIndex(index) {
            let serial = this.generateBeaconSerialForIndex(index);
            if (index < 0 || serial.charAt(0) != 'B') {
                throw new Error("Index out of range");
            }
            return "A" + serial.substring(1, this.SERIAL_NUMBER_LENGTH);
        }
        static getIndexForSerial(serialNumber) {
            if (serialNumber.charAt(0) == 'A')
                serialNumber = serialNumber.substring(1, this.SERIAL_NUMBER_LENGTH);
            let index = 0;
            for (let i = 0; i < serialNumber.length; i++) {
                let currentChar = serialNumber.charAt(serialNumber.length - i - 1);
                let charValue = this.ALPHABET.indexOf(currentChar);
                if (charValue == -1)
                    return 0;
                index += Math.pow(this.ALPHABET.length, i) * charValue;
            }
            return index;
        }
    }
    SerialNumberUtils.SERIAL_NUMBER_LENGTH = 5;
    SerialNumberUtils.ALPHABET = "BCDFGHJKLMNPQRSTVWXYZ123456789";
    exports.SerialNumberUtils = SerialNumberUtils;
});
define("src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/engine/math/Vector2", "src/map/utils/Logger", "src/app/relution/view/world/RelutionMapAttributeObject", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture", "src/engine/rendering/pixi/HighResText"], function (require, exports, DeviceModel_4, ArrowObject_2, DeviceUtils_24, Vector2_11, Logger_7, RelutionMapAttributeObject_7, HighResTextObject_5, GraphicsObject_17, SpriteObject_15, Texture_14, HighResText_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconConnectionDetails extends RelutionMapAttributeObject_7.RelutionMapAttributeObject {
        // Initialization
        constructor(environment, sourceBeacon, deviceLayer) {
            super(environment, sourceBeacon);
            // View: Connections: Configuration
            this.referenceArrowLineWidth = 1.5; // In pixels
            this.connectionArrowHeadLengthInLogicalPx = 12;
            this.connectionArrowHeadMaxLengthInPercent = 0.2;
            this.connectionDirectionArrowHeadLengthInLogicalPx = 32;
            this.connectionDirectionArrowHeadMaxLengthInPercent = 0.4;
            this.connectionViews = new Array();
            // View: Update
            this.invalidated = true;
            this.redrawRequested = true;
            this.forceCompleteRedraw = true;
            this.lastScaleFactor = -1;
            this.lastScaleFactorForTranslation = -1;
            this.sendingMessageViewUpdateRequested = false;
            this.currentModel = new DeviceModel_4.BleNodeModel();
            this.deviceLayer = deviceLayer;
            this.sourceBeacon = sourceBeacon;
            this.initView();
            this.redraw();
        }
        initView() {
            this.initLedView();
            this.initClusterIndicatorRing();
            this.initConnectionViews();
            this.initConnectionDirectionView();
            this.initConnectionInfoView();
            this.initConnectionOwnMasterBitView();
            this.initConnectionPartnerMasterBitView();
            this.initNodeIdView();
            this.initSendingMessageView();
        }
        initLedView() {
            this.ledView = new SpriteObject_15.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.ledView);
            let texture = PIXI.loader.resources["light"].texture;
            texture.baseTexture.mipmap = true;
            this.ledView.texture = new Texture_14.Texture(texture, this.getEnvironment().renderingEnvironment);
            this.ledView.alpha = 0;
        }
        initClusterIndicatorRing() {
            this.clusterIndicatorRing = new GraphicsObject_17.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.clusterIndicatorRing);
        }
        initConnectionViews() {
            this.connectionViews = new Array();
        }
        initConnectionDirectionView() {
            let arrowObjectConfig = new ArrowObject_2.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head_transparent";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = this.connectionDirectionArrowHeadLengthInLogicalPx;
            arrowObjectConfig.maxArrowHeadLengthInPercent = this.connectionDirectionArrowHeadMaxLengthInPercent;
            this.connectionDirectionView = new ArrowObject_2.ArrowObject(arrowObjectConfig, this.getEnvironment());
            this.addChild(this.connectionDirectionView);
        }
        initConnectionInfoView() {
            let fontSize = DeviceUtils_24.DeviceUtils.getPhysicalPixelsFromLogical(15);
            this.connectionInfoView = new HighResTextObject_5.HighResTextObject(new HighResText_5.HighResText(2, "", { fontSize: fontSize }), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.connectionInfoView);
        }
        initConnectionOwnMasterBitView() {
            this.connectionOwnMasterBitView = this.initConnectionMasterBitView();
        }
        initConnectionPartnerMasterBitView() {
            this.connectionPartnerMasterBitView = this.initConnectionMasterBitView();
        }
        initConnectionMasterBitView() {
            // Create
            let masterBitView = new GraphicsObject_17.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            // Draw
            masterBitView.beginFill(0x000000);
            masterBitView.drawCircle(0, 0, 7);
            masterBitView.endFill();
            // Add to scene
            this.getView().addChild(masterBitView);
            // Alpha
            masterBitView.visible = false;
            return masterBitView;
        }
        initNodeIdView() {
            let fontSize = DeviceUtils_24.DeviceUtils.getPhysicalPixelsFromLogical(15);
            this.nodeIdView = new HighResTextObject_5.HighResTextObject(new HighResText_5.HighResText(2, "", { fontSize: fontSize }), this.getEnvironment().renderingEnvironment);
            ;
            this.getView().addChild(this.nodeIdView);
        }
        initSendingMessageView() {
            // Create
            this.sendingMessageView = new GraphicsObject_17.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            // Draw
            this.sendingMessageView.beginFill(0xff0000);
            this.sendingMessageView.drawCircle(0, 0, 1);
            this.sendingMessageView.endFill();
            this.sendingMessageView.alpha = 0.0;
            // Add to scene
            this.getView().addChild(this.sendingMessageView);
        }
        // View
        redraw() {
            this.invalidated = true;
            this.redrawRequested = true;
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.redrawViewsIfNecessary();
            this.syncWithSourceBeaconScale();
            this.syncWithCameraRotation();
            this.syncWithCameraTranslation();
            this.updateSendingMessageView();
            this.invalidated = false;
        }
        redrawViewsIfNecessary() {
            if (this.redrawRequested) {
                this.redrawRequested = false;
                this.redrawLedView();
                this.redrawClusterIndicatorRing();
                this.redrawConnectionViews();
                this.redrawConnectionDirectionView();
                this.redrawConnectionInfoView();
                this.redrawNodeIdView();
                this.currentModel = this.sourceBeacon.getModel().clone();
                this.forceCompleteRedraw = false;
            }
        }
        redrawLedView() {
            let ledOn = this.sourceBeacon.getModel().ledOn;
            if (ledOn) {
                // Alpha
                this.ledView.alpha = 1.0;
                // Pivot
                this.ledView.pivot.x = this.ledView.pixi().texture.baseTexture.width / 2;
                this.ledView.pivot.y = this.ledView.pixi().texture.baseTexture.height / 2;
                // Translate
                this.ledView.x = this.sourceBeacon.getView().x;
                this.ledView.y = this.sourceBeacon.getView().y;
            }
            else {
                this.ledView.alpha = 0.0;
            }
        }
        redrawClusterIndicatorRing() {
            let clusterId = this.sourceBeacon.getModel().clusterId;
            if (this.forceCompleteRedraw || this.currentModel.clusterId !== clusterId) {
                let colorString = this.getColorForClusterId(clusterId);
                let color = parseInt(colorString.replace(/^#/, ""), 16);
                this.clusterIndicatorRing.beginFill(color);
                this.clusterIndicatorRing.drawCircle(0, 0, 1);
                this.clusterIndicatorRing.endFill();
            }
        }
        getColorForClusterId(clusterId) {
            // Return cluster color if already exists.
            for (let i = 0; i < BeaconConnectionDetails.clusterColors.length; i++) {
                let c = BeaconConnectionDetails.clusterColors[i];
                if (c.clusterId === clusterId) {
                    return c.color;
                }
            }
            // If it does not exist, create a new cluster color.
            let randomColor = this.getRandomColor();
            let cluster = new BeaconConnectionDetails.Cluster(clusterId, randomColor);
            BeaconConnectionDetails.clusterColors.push(cluster);
            return cluster.color;
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "#";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        redrawConnectionViews() {
            if (this.forceCompleteRedraw || this.connectionsHaveChanged()) {
                this.removeAllConnectionViews();
                this.addConnectionViews();
            }
        }
        connectionsHaveChanged() {
            let modelConnections = this.sourceBeacon.getModel().connections;
            // Check length
            if (this.currentModel.connections == null || this.currentModel.connections.length !== modelConnections.length) {
                return true;
            }
            // Check connection targets
            for (let i = 0; i < modelConnections.length; i++) {
                let modelConnection = modelConnections[i];
                let connectionFound = false;
                for (let j = 0; j < this.currentModel.connections.length; j++) {
                    let currentConnection = this.currentModel.connections[j];
                    if (modelConnection.target === currentConnection.target) {
                        connectionFound = true;
                    }
                }
                if (!connectionFound) {
                    return true;
                }
            }
            return false;
        }
        removeAllConnectionViews() {
            for (let i = 0; i < this.connectionViews.length; i++) {
                let connectionView = this.connectionViews[i];
                this.removeChild(connectionView);
            }
            this.connectionViews = [];
        }
        addConnectionViews() {
            if (this.sourceBeacon.getModel().connections) {
                for (let i = 0; i < this.sourceBeacon.getModel().connections.length; i++) {
                    let arrowObjectConfig = new ArrowObject_2.ArrowObject.Config();
                    arrowObjectConfig.arrowBodyTextureName = "arrow_body";
                    arrowObjectConfig.arrowHeadTextureName = "arrow_head";
                    arrowObjectConfig.arrowHeadLengthInLogicalPx = this.connectionArrowHeadLengthInLogicalPx;
                    arrowObjectConfig.maxArrowHeadLengthInPercent = this.connectionArrowHeadMaxLengthInPercent;
                    let connectionView = new ArrowObject_2.ArrowObject(arrowObjectConfig, this.getEnvironment());
                    this.addChild(connectionView);
                    this.connectionViews.push(connectionView);
                }
            }
        }
        redrawConnectionDirectionView() {
            if (this.sourceBeacon.getModel().inConnectionPartner === 0) {
                this.connectionDirectionView.getView().visible = false;
            }
            else {
                this.connectionDirectionView.getView().visible = true;
            }
        }
        redrawConnectionInfoView() {
            if (this.sourceBeacon.getModel().inConnectionPartner === 0) {
                this.connectionInfoView.visible = false;
            }
            else {
                this.connectionInfoView.visible = true;
                this.setConnectionInfoViewText();
            }
        }
        setConnectionInfoViewText() {
            if (this.forceCompleteRedraw || this.inConnectionRssiHasChanged() || this.inConnectionHandleHasChanged()) {
                let inConnectionRssiString = "?";
                if (this.sourceBeacon.getModel().inConnectionRssi !== 0) {
                    inConnectionRssiString = "" + this.sourceBeacon.getModel().inConnectionRssi;
                }
                let connectionHandleString = "?";
                if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                    const inConnectionModel = this.getInConnectionModel();
                    if (inConnectionModel !== null) {
                        connectionHandleString = "" + inConnectionModel.handle;
                    }
                }
                this.connectionInfoView.text = "" + inConnectionRssiString + "/" + connectionHandleString;
                // The text will be updated so that the width and height are accessible now.
                this.connectionInfoView.updateText(false);
            }
        }
        inConnectionRssiHasChanged() {
            return this.currentModel.inConnectionRssi !== this.sourceBeacon.getModel().inConnectionRssi;
        }
        inConnectionHandleHasChanged() {
            return this.connectionsHaveChanged();
        }
        getInConnectionModel() {
            for (let i = 0; i < this.sourceBeacon.getModel().connections.length; i++) {
                const connection = this.sourceBeacon.getModel().connections[i];
                if (connection.target === this.sourceBeacon.getModel().inConnectionPartner) {
                    return connection;
                }
            }
            return null;
        }
        redrawNodeIdView() {
            if (this.forceCompleteRedraw
                || this.currentModel.nodeId !== this.sourceBeacon.getModel().nodeId
                || this.currentModel.clusterId !== this.sourceBeacon.getModel().clusterId
                || this.currentModel.clusterSize !== this.sourceBeacon.getModel().clusterSize) {
                let nodeIdString = "?";
                if (this.sourceBeacon.getModel().nodeId) {
                    nodeIdString = "" + this.sourceBeacon.getModel().nodeId;
                }
                let clusterSizeString = "?";
                if (this.sourceBeacon.getModel().clusterSize) {
                    clusterSizeString = "" + this.sourceBeacon.getModel().clusterSize;
                }
                this.nodeIdView.text = nodeIdString + " / " + clusterSizeString;
            }
        }
        syncWithSourceBeaconScale() {
            let sourceBeacon = this.getSourceBeacon();
            let scaleFactor = sourceBeacon.getView().scale.x;
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                this.retransformLedView(scaleFactor);
                this.retransformClusterIndicatorRing();
                this.retransformConnectionViews(scaleFactor);
                this.retransformConnectionDirectionView(scaleFactor);
                this.retransformConnectionInfoView(scaleFactor);
                this.retransformConnectionOwnMasterBitView(scaleFactor);
                this.retransformConnectionPartnerMasterBitView(scaleFactor);
                this.retransformNodeIdView(scaleFactor);
                this.retransformSendingMessageView(scaleFactor);
            }
        }
        retransformLedView(scaleFactor) {
            // Scale
            let radiusInPx = this.sourceBeacon.getView().width * 10;
            this.ledView.scale.x = (1.0 / this.ledView.pixi().texture.baseTexture.width) * radiusInPx;
            this.ledView.scale.y = (1.0 / this.ledView.pixi().texture.baseTexture.height) * radiusInPx;
        }
        retransformClusterIndicatorRing() {
            // Scale
            let radiusInPx = this.sourceBeacon.getView().width;
            this.clusterIndicatorRing.scale.x = radiusInPx;
            this.clusterIndicatorRing.scale.y = radiusInPx;
            // Translation
            let sourceX = this.sourceBeacon.getView().x;
            let sourceY = this.sourceBeacon.getView().y;
            this.clusterIndicatorRing.x = sourceX;
            this.clusterIndicatorRing.y = sourceY;
        }
        retransformConnectionViews(scaleFactor) {
            let lineWidth = this.referenceArrowLineWidth * scaleFactor;
            for (let i = 0; i < this.connectionViews.length; i++) {
                let connectionView = this.connectionViews[i];
                let connection = this.sourceBeacon.getModel().connections[i];
                this.retransformConnectionViewWithLineWidth(connectionView, connection, lineWidth);
            }
        }
        retransformConnectionViewWithLineWidth(connectionView, connection, lineWidth) {
            // Target beacon
            let targetNodeId = connection.target;
            let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
            if (targetBeacon != null) {
                // Since the connection is bidirectional, we move the arrow a bit upwards
                // to see both directions.
                let sourcePosition = this.sourceBeacon.getView().pixi().position;
                let targetPosition = targetBeacon.getView().pixi().position;
                // sourcePosition = this.getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition);
                // targetPosition = this.getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition);
                sourcePosition = this.getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition);
                targetPosition = this.getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition);
                // Draw arrow. The arrow should point to the source since we assume all connections
                // to be ingoing connections.
                connectionView.draw(targetPosition, sourcePosition, lineWidth);
            }
            else {
                Logger_7.Logger.logDebug("Beacon with nodeId " + targetNodeId + " does not exist.");
            }
        }
        getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition) {
            let diffVector = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let normalVector = new Vector2_11.Vector2(-diffVector.y, diffVector.x);
            normalVector.normalize();
            let offsetInTx = this.sourceBeacon.getView().height / 2;
            let modifiedSourcePosition = new PIXI.Point(sourcePosition.x - normalVector.getX() * offsetInTx, sourcePosition.y - normalVector.getY() * offsetInTx);
            return modifiedSourcePosition;
        }
        getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition) {
            let diffVector = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let normalVector = new Vector2_11.Vector2(-diffVector.y, diffVector.x);
            normalVector.normalize();
            let offsetInTx = this.sourceBeacon.getView().height / 2;
            let modifiedTargetPosition = new PIXI.Point(targetPosition.x - normalVector.getX() * offsetInTx, targetPosition.y - normalVector.getY() * offsetInTx);
            return modifiedTargetPosition;
        }
        getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition) {
            let diffPoint = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_11.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width / 2;
            let displacedSourcePosition = new PIXI.Point(sourcePosition.x + diffVector.getX() * stretchFactor, sourcePosition.y + diffVector.getY() * stretchFactor);
            return displacedSourcePosition;
        }
        getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition) {
            let diffPoint = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_11.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width / 2;
            let displacedTargetPosition = new PIXI.Point(targetPosition.x - diffVector.getX() * stretchFactor, targetPosition.y - diffVector.getY() * stretchFactor);
            return displacedTargetPosition;
        }
        retransformConnectionDirectionView(scaleFactor) {
            // Line width
            let lineWidth = this.referenceArrowLineWidth * scaleFactor;
            // Source and target position
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetNodeId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
                if (targetBeacon != null) {
                    // Since the connection is bidirectional, we move the arrow a bit upwards
                    // to see both directions.
                    let sourcePosition = this.sourceBeacon.getView().pixi().position;
                    let targetPosition = targetBeacon.getView().pixi().position;
                    // sourcePosition = this.getUpwardsDisplacedSourcePosition(sourcePosition, targetPosition);
                    // targetPosition = this.getUpwardsDisplacedTargetPosition(sourcePosition, targetPosition);
                    sourcePosition = this.getClusterRingDisplacedSourcePosition(sourcePosition, targetPosition);
                    targetPosition = this.getClusterRingDisplacedTargetPosition(sourcePosition, targetPosition);
                    // Draw arrow
                    this.connectionDirectionView.draw(targetPosition, sourcePosition, lineWidth);
                }
                else {
                    Logger_7.Logger.logDebug("Beacon with nodeId " + targetNodeId + " does not exist.");
                }
            }
        }
        retransformConnectionInfoView(scaleFactor) {
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetId);
                if (targetBeacon != null) {
                    // Pivot
                    this.connectionInfoView.pivot.x = this.connectionInfoView.pixi().texture.width / 2;
                    this.connectionInfoView.pivot.y = this.connectionInfoView.pixi().texture.height / 2;
                    // Scale
                    this.connectionInfoView.setScaleX(scaleFactor);
                    this.connectionInfoView.setScaleY(scaleFactor);
                    // Rotation
                    let camera = this.getScene().getCamera();
                    this.connectionInfoView.rotation = camera.getRotation();
                    // Translation
                    let sourcePosition = this.sourceBeacon.getView().pixi().position;
                    let targetPosition = targetBeacon.getView().pixi().position;
                    let meanPosition = new PIXI.Point((sourcePosition.x + targetPosition.x) / 2, (sourcePosition.y + targetPosition.y) / 2);
                    this.connectionInfoView.x = meanPosition.x;
                    this.connectionInfoView.y = meanPosition.y;
                }
            }
        }
        retransformConnectionOwnMasterBitView(scaleFactor) {
            let masterBitView = this.connectionOwnMasterBitView;
            if (this.sourceBeacon.getModel().inConnectionPartner === 0 || !this.sourceBeacon.getModel().inConnectionHasMasterBit) {
                masterBitView.visible = false;
                return;
            }
            else {
                masterBitView.visible = true;
                this.retransformConnectionMasterBitView(masterBitView, scaleFactor, true);
            }
        }
        retransformConnectionPartnerMasterBitView(scaleFactor) {
            let masterBitView = this.connectionPartnerMasterBitView;
            if (this.sourceBeacon.getModel().inConnectionPartner === 0 || !this.sourceBeacon.getModel().inConnectionPartnerHasMasterBit) {
                masterBitView.visible = false;
                return;
            }
            else {
                masterBitView.visible = true;
                this.retransformConnectionMasterBitView(masterBitView, scaleFactor, false);
            }
        }
        retransformConnectionMasterBitView(masterBitView, scaleFactor, isSourceView) {
            // Scale
            masterBitView.scale.x = scaleFactor;
            masterBitView.scale.y = scaleFactor;
            // Translation
            if (this.sourceBeacon.getModel().inConnectionPartner !== 0) {
                let targetNodeId = this.sourceBeacon.getModel().inConnectionPartner;
                let targetBeacon = this.deviceLayer.getBeaconWithNodeId(targetNodeId);
                if (targetBeacon != null) {
                    let sourcePosition = this.sourceBeacon.getView().pixi().position;
                    let targetPosition = targetBeacon.getView().pixi().position;
                    sourcePosition = this.getMasterBitSourcePosition(sourcePosition, targetPosition);
                    targetPosition = this.getMasterBitTargetPosition(sourcePosition, targetPosition);
                    if (isSourceView) {
                        masterBitView.x = sourcePosition.x;
                        masterBitView.y = sourcePosition.y;
                    }
                    else {
                        masterBitView.x = targetPosition.x;
                        masterBitView.y = targetPosition.y;
                    }
                }
            }
        }
        getMasterBitSourcePosition(sourcePosition, targetPosition) {
            let diffPoint = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_11.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width;
            let displacedSourcePosition = new PIXI.Point(sourcePosition.x + diffVector.getX() * stretchFactor, sourcePosition.y + diffVector.getY() * stretchFactor);
            let upperDisplacement = 0;
            displacedSourcePosition.x += -diffVector.getY() * upperDisplacement;
            displacedSourcePosition.x += diffVector.getX() * upperDisplacement;
            return displacedSourcePosition;
        }
        getMasterBitTargetPosition(sourcePosition, targetPosition) {
            let diffPoint = new PIXI.Point(targetPosition.x - sourcePosition.x, targetPosition.y - sourcePosition.y);
            let diffVector = new Vector2_11.Vector2(diffPoint.x, diffPoint.y);
            diffVector.normalize();
            let stretchFactor = this.clusterIndicatorRing.width;
            let displacedTargetPosition = new PIXI.Point(targetPosition.x - diffVector.getX() * stretchFactor, targetPosition.y - diffVector.getY() * stretchFactor);
            let upperDisplacement = 0;
            displacedTargetPosition.x += -diffVector.getY() * upperDisplacement;
            displacedTargetPosition.x += diffVector.getX() * upperDisplacement;
            return displacedTargetPosition;
        }
        retransformNodeIdView(scaleFactor) {
            let camera = this.getScene().getCamera();
            // Pivot
            this.nodeIdView.pivot.x = this.nodeIdView.pixi().texture.width / 2;
            this.nodeIdView.pivot.y = this.nodeIdView.pixi().texture.height / 2;
            // Scale
            this.nodeIdView.setScaleX(scaleFactor);
            this.nodeIdView.setScaleY(scaleFactor);
            // Rotation
            this.nodeIdView.rotation = camera.getRotation();
            // Translation
            let worldCamera = this.getScene().getCamera();
            let deviceBoundsInImage = this.sourceBeacon.getAabbInImageCoordinates();
            let textBounds = this.nodeIdView.pixi().getBounds();
            let textPositionInImage = new PIXI.Point(deviceBoundsInImage.min.x + (deviceBoundsInImage.max.x - deviceBoundsInImage.min.x) / 2, deviceBoundsInImage.min.y - textBounds.height);
            let textPositionInWorld = worldCamera.getWorldCoordinateFromImagePoint(textPositionInImage);
            if (Math.abs(this.nodeIdView.x - textPositionInWorld.x) > 0.00001) {
                this.nodeIdView.x = textPositionInWorld.x;
            }
            if (Math.abs(this.nodeIdView.y - textPositionInWorld.y) > 0.00001) {
                this.nodeIdView.y = textPositionInWorld.y;
            }
        }
        retransformSendingMessageView(scaleFactor) {
            // Scale
            let beaconWidth = this.sourceBeacon.getView().width;
            let beaconHeight = this.sourceBeacon.getView().height;
            let radiusInPx = beaconWidth / 3;
            this.sendingMessageView.scale.x = radiusInPx;
            this.sendingMessageView.scale.y = radiusInPx;
            // Translation
            this.sendingMessageView.x = this.sourceBeacon.getView().x + beaconWidth * 1.5;
            this.sendingMessageView.y = this.sourceBeacon.getView().y - beaconHeight * 1.5;
        }
        syncWithCameraRotation() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            let scaleFactor = this.sourceBeacon.getView().scale.x;
            if (this.nodeIdView.rotation !== orientation || this.invalidated) {
                this.retransformNodeIdView(scaleFactor);
            }
        }
        syncWithCameraTranslation() {
            let scaleFactor = this.sourceBeacon.getView().scale.x;
            if (this.lastScaleFactorForTranslation !== scaleFactor || this.invalidated) {
                this.lastScaleFactorForTranslation = scaleFactor;
                this.retransformNodeIdView(scaleFactor);
            }
        }
        updateSendingMessageView() {
            if (this.sendingMessageViewUpdateRequested) {
                this.sendingMessageViewUpdateRequested = false;
                let lastSentMessageTimestampMs = this.sourceBeacon.getModel().lastSentMessageTimestampMs;
                let nowInMs = Date.now();
                let diffInMs = nowInMs - lastSentMessageTimestampMs;
                if (diffInMs > 500) {
                    this.sendingMessageView.alpha = 0.0;
                }
                else {
                    this.sendingMessageView.alpha = 1.0;
                }
            }
        }
        // Model Event-handling
        // @Override
        modelChanged(deviceModel) {
            this.redraw();
        }
        // @Override
        lastSentMessageTimestampMsChanged(deviceModel) {
            this.sendingMessageViewUpdateRequested = true;
        }
        // Getters and setters
        getSourceBeacon() {
            return this.sourceBeacon;
        }
    }
    BeaconConnectionDetails.clusterColors = new Array();
    exports.BeaconConnectionDetails = BeaconConnectionDetails;
    (function (BeaconConnectionDetails) {
        class Cluster {
            constructor(clusterId, color) {
                this.clusterId = clusterId;
                this.color = color;
            }
        }
        BeaconConnectionDetails.Cluster = Cluster;
    })(BeaconConnectionDetails = exports.BeaconConnectionDetails || (exports.BeaconConnectionDetails = {}));
});
define("src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", "src/app/relution/view/world/RelutionMapAttributeObjectLayer"], function (require, exports, BeaconConnectionDetails_1, RelutionMapAttributeObjectLayer_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconConnectionDetailsLayer extends RelutionMapAttributeObjectLayer_6.RelutionMapAttributeObjectLayer {
        // Initialization
        constructor(environment, deviceLayer) {
            super(environment, deviceLayer);
            this.deviceLayer = deviceLayer;
        }
        // Device attribute object creation
        createAttributeObjectsForObject(device) {
            let resultList = new Array();
            if (device.getModel().isBleNode()) {
                let beacon = device;
                let details = new BeaconConnectionDetails_1.BeaconConnectionDetails(this.getEnvironment(), beacon, this.deviceLayer);
                resultList.push(details);
            }
            return resultList;
        }
    }
    exports.BeaconConnectionDetailsLayer = BeaconConnectionDetailsLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TextureUpdateLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/Texture", "src/engine/rendering/texture/BaseTexture"], function (require, exports, FloorplanRelatedLayer_11, SpriteObject_16, Texture_15, BaseTexture_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TextureUpdateLayer extends FloorplanRelatedLayer_11.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // Updating
            this.accumulator = 0;
            this.initView();
        }
        initView() {
            this.spriteView = new SpriteObject_16.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.getView().addChild(this.spriteView);
            this.createCanvas();
        }
        updateTexture(canvas) {
            if (this.spriteView.texture != null) {
                this.spriteView.texture.destroy(true);
            }
            let baseTexture = new BaseTexture_5.BaseTexture(new PIXI.BaseTexture(canvas), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_15.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            texture.baseTexture.mipmap = true;
            this.spriteView.texture = new Texture_15.Texture(texture.pixi(), this.getEnvironment().renderingEnvironment);
            this.spriteView.width = this.getFloorplanLayer().getFloorSize().x;
            this.spriteView.height = this.getFloorplanLayer().getFloorSize().y;
        }
        createCanvas() {
            this.canvas = document.createElement("canvas");
            this.powerTwoTextureSize = 512;
            this.canvas.width = this.powerTwoTextureSize;
            this.canvas.height = this.powerTwoTextureSize;
            return this.canvas;
        }
        // Updating
        // @Override
        update(lastFramtime) {
            super.update(lastFramtime);
            this.accumulator += lastFramtime;
            if (this.accumulator > 500) {
                this.accumulator = 0;
                this.updateCanvas();
                this.updateTexture(this.canvas);
            }
        }
        updateCanvas() {
            let ctx = this.canvas.getContext("2d");
            let x = Math.random() * this.powerTwoTextureSize;
            let y = Math.random() * this.powerTwoTextureSize;
            let width = Math.random() * this.powerTwoTextureSize / 2;
            let height = Math.random() * this.powerTwoTextureSize / 2;
            let colorHex = this.getRandomColor();
            ctx.fillStyle = colorHex;
            ctx.fillRect(x, y, width, height);
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "#";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
    }
    exports.TextureUpdateLayer = TextureUpdateLayer;
});
define("src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TileBasedBenchmarkLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/tileLayer/TileEngine", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, FloorplanRelatedLayer_12, TileEngine_2, GraphicsObject_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TileBasedBenchmarkLayer extends FloorplanRelatedLayer_12.FloorplanRelatedLayer {
        // Initialization
        constructor(environment, floorplanLayer) {
            super(environment, floorplanLayer);
            // View
            this.rectangles = new Array();
        }
        // @Override
        initialize() {
            super.initialize();
            this.initTileEngine();
        }
        initTileEngine() {
            let worldCamera = this.getScene().getCamera();
            this.tileEngine = new TileEngine_2.TileEngine(new TileEngine_2.TileEngine.Config(), this.getEnvironment(), worldCamera, 256);
            this.tileEngine.addTileEngineObserver(this);
        }
        // Event-Handling: Tile-Engine
        onLoadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.loadTile(tile);
            }
        }
        loadTile(tile) {
            let graphics = new GraphicsObject_18.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            // Drawing
            let color = this.getRandomColor();
            graphics.beginFill(parseInt(color, 10));
            let x = 0;
            let y = 0;
            let width = this.tileEngine.getTileSizeInPx();
            let height = this.tileEngine.getTileSizeInPx();
            graphics.drawRect(x, y, width, height);
            graphics.endFill();
            // Position
            graphics.x = tile.columnIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            graphics.y = tile.rowIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            // Scale
            graphics.scale.x = tile.depthIndex;
            graphics.scale.y = tile.depthIndex;
            // Scene graph
            this.getView().addChild(graphics);
            this.rectangles.push(graphics);
        }
        getRandomColor() {
            let letters = "0123456789ABCDEF";
            let color = "0x";
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        // @Override
        onReplaceTiles(tileReplacements) {
            for (let i = 0; i < tileReplacements.length; i++) {
                let tileReplacement = tileReplacements[i];
                this.onUnloadTiles(tileReplacement.oldTiles);
                this.onLoadTiles(tileReplacement.newTiles);
            }
        }
        // @Override
        onUnloadTiles(tiles) {
            for (let i = 0; i < tiles.length; i++) {
                let tile = tiles[i];
                this.unloadTile(tile);
            }
        }
        unloadTile(tile) {
            let tileX = tile.columnIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            let tileY = tile.rowIndex * this.tileEngine.getTileSizeInPx() * tile.depthIndex;
            for (let i = 0; i < this.rectangles.length; i++) {
                let rectangle = this.rectangles[i];
                let rectX = rectangle.x;
                let rectY = rectangle.y;
                if (tileX === rectX && tileY === rectY) {
                    rectangle.destroy();
                    this.getView().removeChild(rectangle);
                    let index = this.rectangles.indexOf(rectangle);
                    if (index > -1) {
                        this.rectangles.splice(index, 1);
                    }
                    return;
                }
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.tileEngine.update(lastFrametime);
        }
    }
    exports.TileBasedBenchmarkLayer = TileBasedBenchmarkLayer;
});
define("src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", ["require", "exports", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon"], function (require, exports, PopupLayer_3, Beacon_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconConnectionDetailsPopupLayer extends PopupLayer_3.PopupLayer {
        // @Override
        getContentForObject(object) {
            if (object instanceof Beacon_9.Beacon) {
                let device = object;
                let content = ""
                    + "Serial: " + device.getModel().deviceId + "\n"
                    + "Node ID: " + device.getModel().nodeId + "\n"
                    + "Cluster ID: " + device.getModel().clusterId + "\n"
                    + "Cluster size: " + device.getModel().clusterSize + "\n"
                    + "Connection losses: " + device.getModel().connectionLossCounter + "\n"
                    + "Free In: " + device.getModel().freeIn + "\n"
                    + "Free Out: " + device.getModel().freeOut + "\n"
                    + "Last Message Timestamp: " + device.getModel().lastSentMessageTimestampMs + "\n"
                    + "Last Message: " + JSON.stringify(device.getModel().lastSentAdvertisingMessage);
                return content;
            }
            else {
                return "";
            }
        }
        // Localization Event-Handling
        // @Override
        onLocalizationChanged() {
            return false;
        }
    }
    exports.BeaconConnectionDetailsPopupLayer = BeaconConnectionDetailsPopupLayer;
});
define("src/app/simulator/SimulatorMap", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", "src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", "src/app/relution/view/hud/popupLayer/PopupLayer"], function (require, exports, RelutionMap_2, BeaconConnectionDetailsLayer_1, BeaconConnectionDetailsPopupLayer_1, PopupLayer_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SimulatorMap extends RelutionMap_2.RelutionMap {
        // Initialization
        constructor(options) {
            super(options);
        }
        // @Override
        load(floor, initializedCallback) {
            super.load(floor, () => {
                this.configureFloors();
                this.configureHud();
                initializedCallback();
            });
        }
        configureFloors() {
            this.getBuilding().addFloorObserver(this);
            this.floorAdded(this.getBuilding().getCurrentFloor());
        }
        configureHud() {
            // Make beacon connection details popup layer visible
            let popupLayer = new BeaconConnectionDetailsPopupLayer_1.BeaconConnectionDetailsPopupLayer(new PopupLayer_4.PopupLayer.Config(), this.fruityMap.getEnvironment(), this.getBuilding());
            this.fruityMap.getHud().addLayer(popupLayer);
            // Make device info popup layer invisible
            this.relutionMapHud.removeLayer(this.getDeviceInfoPopupLayer());
        }
        // Floor events
        // @Override
        floorAdded(floor) {
            if (floor !== null) {
                floor.getDeviceLayer().setShowMeshGatewayInsteadOfCommunicationBeaconEnabled(false);
                floor.getDeviceInfoLayer().getView().visible = false;
                this.addBeaconConnectionDetailsLayer(floor);
            }
        }
        addBeaconConnectionDetailsLayer(floor) {
            let beaconConnectionDetailsLayer = new BeaconConnectionDetailsLayer_1.BeaconConnectionDetailsLayer(this.fruityMap.getEnvironment(), floor.getDeviceLayer());
            floor.getDeviceLayerContainer().addLayerAfterLayer(beaconConnectionDetailsLayer, floor.getBeaconRangeLayer());
        }
        // Image preloading
        // @Override
        getPreloadingImageNames() {
            let preloadingImages = super.getPreloadingImageNames();
            preloadingImages.push("light");
            return preloadingImages;
        }
    }
    exports.SimulatorMap = SimulatorMap;
});
define("src/map/view/world/layers/tileLayer/RemoteTileResponse", ["require", "exports", "src/map/view/world/layers/tileLayer/TileResponse"], function (require, exports, TileResponse_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RemoteTileResponse extends TileResponse_2.TileResponse {
        constructor(tile, tileLoader, source) {
            super(tile, tileLoader);
            this.source = source;
        }
        getSource() {
            return this.source;
        }
    }
    exports.RemoteTileResponse = RemoteTileResponse;
});
define("src/map/utils/StringUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class StringUtils {
        // See https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js
        static fillFieldsForTemplate(template, data) {
            let templateRe = /\{ *([\w_\-]+) *\}/g;
            return template.replace(templateRe, function (str, key) {
                let value = data[key];
                if (value === undefined) {
                    throw new Error("No value provided for variable " + str);
                }
                else if (typeof value === "function") {
                    value = value(data);
                }
                return value;
            });
        }
    }
    exports.StringUtils = StringUtils;
});
define("src/map/view/world/layers/tileLayer/RemoteTileLoader", ["require", "exports", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/utils/Language", "src/map/view/world/layers/tileLayer/RemoteTileResponse", "src/map/utils/SystemUtils", "src/map/utils/StringUtils"], function (require, exports, TileLoader_2, Language_2, RemoteTileResponse_1, SystemUtils_2, StringUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RemoteTileLoader extends TileLoader_2.TileLoader {
        // Initialization
        constructor(urlTemplate, options) {
            super(options);
            Language_2.Language.setOptions(this, new RemoteTileLoader.Options(), options);
            this.postprocessOptions();
            this.urlTemplate = urlTemplate;
            this.computeDimensions();
        }
        postprocessOptions() {
            if (typeof this.options.subdomains === "string") {
                this.options.subdomains = this.options.subdomains.split("");
            }
        }
        computeDimensions() {
            let numZoomLevels = (this.options.maxNativeZoom - this.options.minNativeZoom) + 1;
            let widthInPx = Math.pow(2, numZoomLevels - 1) * this.options.tileSizeInPx;
            this.worldWidthInPx = widthInPx;
            this.worldHeightInPx = widthInPx;
        }
        // Dimensions
        // @Override
        getWorldWidth() {
            return this.worldWidthInPx;
        }
        // @Override
        getWorldHeight() {
            return this.worldHeightInPx;
        }
        // Tile loading
        // @Override
        loadTile(tile, responseCallback) {
            if (this.tileOutsideWorld(tile)) {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, this, this.drawEmptyTileOnCanvas());
                responseCallback(tileResponse);
                return null;
            }
            else {
                let image = this.loadTileAsync(tile, responseCallback);
                return image;
            }
        }
        tileOutsideWorld(tile) {
            let logDepthIndex = tile.getLogDepthIndex();
            return tile.columnIndex < 0 || tile.rowIndex < 0 || logDepthIndex < this.options.minZoom;
        }
        loadTileAsync(tile, responseCallback) {
            // Create tile
            let image = document.createElement("img");
            // Callback
            let that = this;
            image.onload = function () {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, that, image);
                responseCallback(tileResponse);
            };
            image.onerror = function () {
                let tileResponse = new RemoteTileResponse_1.RemoteTileResponse(tile, that, that.drawEmptyTileOnCanvas());
                responseCallback(tileResponse);
            };
            // Cross origin
            if (this.options.crossOrigin) {
                image.crossOrigin = "";
            }
            // Screen readers should ignore this image element
            image.alt = "";
            image.setAttribute("role", "presentation");
            // Load tile
            image.src = this.getTileUrl(tile);
            return image;
        }
        getTileUrl(tile) {
            // Get url for tile
            let data = {
                r: SystemUtils_2.SystemUtils.isRetinaDisplay() ? "@2x" : "",
                s: this.getSubdomain(tile.columnIndex, tile.rowIndex),
                x: tile.columnIndex,
                y: tile.rowIndex,
                z: this.getZoomForUrl(tile)
            };
            let url = StringUtils_1.StringUtils.fillFieldsForTemplate(this.urlTemplate, data);
            return url;
        }
        getSubdomain(columnIndex, rowIndex) {
            // Load balancing
            let index = Math.abs(columnIndex + rowIndex) % this.options.subdomains.length;
            return this.options.subdomains[index];
        }
        getZoomForUrl(tile) {
            let zoom = tile.getLogDepthIndex();
            let maxZoom = this.options.maxZoom;
            let zoomReverse = this.options.zoomReverse;
            let zoomOffset = this.options.zoomOffset;
            if (!zoomReverse) {
                zoom = maxZoom - zoom;
            }
            return zoom + zoomOffset;
        }
        cancelTile(tileImage) {
            if (tileImage) {
                tileImage.onload = function () {
                    return false;
                };
                tileImage.onerror = function () {
                    return false;
                };
                tileImage.src = "";
            }
        }
        // Tile drawing
        // @Override
        drawTileOnCanvas(tileResponse) {
            let source = tileResponse.getSource();
            if (source instanceof HTMLCanvasElement) {
                return source;
            }
            else {
                // Create canvas
                let canvas = document.createElement("canvas");
                canvas.width = this.getTileSizeInPx();
                canvas.height = this.getTileSizeInPx();
                // Draw tile on canvas context
                let ctx = canvas.getContext("2d");
                let image = tileResponse.getSource();
                ctx.drawImage(image, 0, 0);
                return canvas;
            }
        }
    }
    exports.RemoteTileLoader = RemoteTileLoader;
    (function (RemoteTileLoader) {
        class Options extends TileLoader_2.TileLoader.Options {
            constructor() {
                super(...arguments);
                this.minZoom = 0;
                this.maxZoom = 18;
                this.minNativeZoom = 0;
                this.maxNativeZoom = 18;
                this.subdomains = "abc";
                this.zoomOffset = 0;
                this.zoomReverse = false;
                this.crossOrigin = false;
            }
        }
        RemoteTileLoader.Options = Options;
    })(RemoteTileLoader = exports.RemoteTileLoader || (exports.RemoteTileLoader = {}));
});
define("src/app/world/WorldMap", ["require", "exports", "src/map/FruityMap", "src/map/view/world/layers/tileLayer/TileLayer", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/app/relution/locale/LocalizationEn", "src/map/view/world/layers/tileLayer/RemoteTileLoader", "src/map/view/world/objects/WorldCamera", "src/app/relution/RelutionMap"], function (require, exports, FruityMap_2, TileLayer_2, NavigationLayer_2, ControlLayer_2, LocalizationEn_2, RemoteTileLoader_1, WorldCamera_4, RelutionMap_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WorldMap {
        constructor() {
            const environment = new RelutionMap_3.RelutionMap.Environment();
            environment.scene.localization = new LocalizationEn_2.LocalizationEn();
            environment.scene.canvasSize.x = window.innerWidth - 30;
            environment.scene.canvasSize.y = window.innerHeight - 30;
            this.fruityMap = new FruityMap_2.FruityMap({
                parentHtmlElement: document.body,
                camera: new WorldCamera_4.WorldCamera.Config(),
                preloadingImages: [{
                        resourceName: "map",
                        url: "http://www.nationsonline.org/maps/political_world_map3000.jpg"
                    },
                    this.getPreloadingImage("compass"),
                    this.getPreloadingImage("plus_normal"),
                    this.getPreloadingImage("minus_normal"),
                    this.getPreloadingImage("pan_center"),
                    this.getPreloadingImage("pan_down"),
                    this.getPreloadingImage("pan_up"),
                    this.getPreloadingImage("pan_left"),
                    this.getPreloadingImage("pan_right")
                ]
            }, environment, () => {
                // World
                let world = this.fruityMap.getWorld();
                let tileLoader = new RemoteTileLoader_1.RemoteTileLoader("http://{s}.tile.osm.org/{z}/{x}/{y}.png", { crossOrigin: true });
                // let tileLoader = new LocalTileLoader("map");
                const config = new TileLayer_2.TileLayer.Config();
                config.tileEngine.loadTilesForRetinaDisplay = false;
                this.tileLayer = new TileLayer_2.TileLayer(config, this.fruityMap.getEnvironment(), tileLoader);
                world.addLayer(this.tileLayer);
                // HUD
                let hud = this.fruityMap.getHud();
                let worldCamera = world.getScene().getCamera();
                this.navigationLayer = new NavigationLayer_2.NavigationLayer(new NavigationLayer_2.NavigationLayer.Config(), this.fruityMap.getEnvironment(), worldCamera);
                this.controlLayer = new ControlLayer_2.ControlLayer(new ControlLayer_2.ControlLayer.Config(), this.fruityMap.getEnvironment(), worldCamera);
                hud.addLayer(this.navigationLayer);
                hud.addLayer(this.controlLayer);
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                this.fruityMap.setCanvasSize(newWidth, newHeight);
            });
        }
        getPreloadingImage(imageName) {
            return { resourceName: imageName, url: "../../../img/png/" + imageName + ".png" };
        }
    }
    exports.WorldMap = WorldMap;
});
define("src/engine/animation/BackInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BackInterpolator {
        getInterpolationValue(timeProgress) {
            let t = timeProgress;
            let result = Math.pow(t, 2) * (2.70158 * t - 1.70158);
            return result;
        }
    }
    exports.BackInterpolator = BackInterpolator;
});
define("src/engine/animation/BounceInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BounceInterpolator {
        getInterpolationValue(timeProgress) {
            let result = 0;
            let t = timeProgress;
            if (1 - t >= 0 && 1 - t < 4 / 11) {
                result = 1 - Math.pow((11 / 4) * (1 - t), 2);
            }
            else if (1 - t >= 4 / 11 && 1 - t < 8 / 11) {
                let base = (11 / 4) * (1 - t - (6 / 11));
                result = 1 - (Math.pow(base, 2) + (3 / 4));
            }
            else if (1 - t >= 8 / 11 && 1 - t < 10 / 11) {
                let base = (11 / 4) * (1 - t - (9 / 11));
                result = 1 - (Math.pow(base, 2) + (15 / 16));
            }
            else if (1 - t >= 10 / 11 && 1 - t <= 11 / 11) {
                let base = (11 / 4) * (1 - t - (10.5 / 11));
                result = 1 - (Math.pow(base, 2) + (63 / 64));
            }
            return result;
        }
    }
    exports.BounceInterpolator = BounceInterpolator;
});
define("src/engine/animation/CubicInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CubicInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 3);
        }
    }
    exports.CubicInterpolator = CubicInterpolator;
});
define("src/engine/animation/QuatricInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class QuatricInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 4);
        }
    }
    exports.QuatricInterpolator = QuatricInterpolator;
});
define("src/engine/animation/SquareInterpolator", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SquareInterpolator {
        getInterpolationValue(timeProgress) {
            return Math.pow(timeProgress, 2);
        }
    }
    exports.SquareInterpolator = SquareInterpolator;
});
define("src/engine/utils/UnsupportedOperationException", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class UnsupportedOperationException extends Error {
        constructor() {
            super("Operation unsupported.");
            Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
        }
    }
    exports.UnsupportedOperationException = UnsupportedOperationException;
});
define("src/map/utils/ArrayUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ArrayUtils {
        static getSubArrayWithIndices(path, indices) {
            let subarray = new Array();
            for (let i = 0; i < indices.length; i++) {
                let index = indices[i];
                subarray.push(path[index]);
            }
            return subarray;
        }
    }
    exports.ArrayUtils = ArrayUtils;
});
define("src/map/utils/Simplify", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* tslint:disable */
    class Simplify {
        /*
        (c) 2013, Vladimir Agafonkin
        Simplify.js, a high-performance JS polyline simplification library
        mourner.github.io/simplify-js
        */
        // to suit your point format, run search/replace for '.x' and '.y';
        // for 3D version, see 3d branch (configurability would draw significant performance overhead)
        // square distance between 2 points
        static getSqDist(p1, p2) {
            var dx = p1.x - p2.x, dy = p1.y - p2.y;
            return dx * dx + dy * dy;
        }
        // square distance from a point to a segment
        static getSqSegDist(p, p1, p2) {
            var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
            if (dx !== 0 || dy !== 0) {
                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                }
                else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
            dx = p.x - x;
            dy = p.y - y;
            return dx * dx + dy * dy;
        }
        // rest of the code doesn't care about point format
        // basic distance-based simplification
        static simplifyRadialDist(points, sqTolerance) {
            var prevPoint = points[0], newPoints = [prevPoint], point;
            for (var i = 1, len = points.length; i < len; i++) {
                point = points[i];
                if (Simplify.getSqDist(point, prevPoint) > sqTolerance) {
                    newPoints.push(point);
                    prevPoint = point;
                }
            }
            if (prevPoint !== point)
                newPoints.push(point);
            return newPoints;
        }
        static simplifyDPStep(points, first, last, sqTolerance, simplified) {
            var maxSqDist = sqTolerance, index;
            for (var i = first + 1; i < last; i++) {
                var sqDist = Simplify.getSqSegDist(points[i], points[first], points[last]);
                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }
            if (maxSqDist > sqTolerance) {
                if (index - first > 1)
                    Simplify.simplifyDPStep(points, first, index, sqTolerance, simplified);
                simplified.push(points[index]);
                if (last - index > 1)
                    Simplify.simplifyDPStep(points, index, last, sqTolerance, simplified);
            }
        }
        // simplification using Ramer-Douglas-Peucker algorithm
        static simplifyDouglasPeucker(points, sqTolerance) {
            var last = points.length - 1;
            var simplified = [points[0]];
            Simplify.simplifyDPStep(points, 0, last, sqTolerance, simplified);
            simplified.push(points[last]);
            return simplified;
        }
        // both algorithms combined for awesome performance
        static simplify(points, tolerance, highestQuality) {
            if (points.length <= 2)
                return points;
            var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
            points = highestQuality ? points : Simplify.simplifyRadialDist(points, sqTolerance);
            points = Simplify.simplifyDouglasPeucker(points, sqTolerance);
            return points;
        }
    }
    exports.Simplify = Simplify;
});
define("src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HeatmapLayerImpl;
    (function (HeatmapLayerImpl) {
        class Config {
        }
        HeatmapLayerImpl.Config = Config;
    })(HeatmapLayerImpl = exports.HeatmapLayerImpl || (exports.HeatmapLayerImpl = {}));
});
define("src/map/view/world/layers/heatmapLayer/webgl/Shader", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Shader {
        constructor(gl, vertexShader, fragmentShader) {
            this.gl = gl;
            this.program = this.gl.createProgram();
            this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            this.gl.attachShader(this.program, this.vs);
            this.gl.attachShader(this.program, this.fs);
            this.compileShader(this.vs, vertexShader);
            this.compileShader(this.fs, fragmentShader);
            this.link();
            this.valueCache = {};
            this.uniformCache = {};
            this.attribCache = {};
        }
        attribLocation(name) {
            let location;
            location = this.attribCache[name];
            if (location === void 0) {
                location = this.attribCache[name] = this.gl.getAttribLocation(this.program, name);
            }
            return location;
        }
        compileShader(shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                throw new Error("Shader Compile Error: " + (this.gl.getShaderInfoLog(shader)));
            }
        }
        link() {
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                throw new Error("Shader Link Error: " + (this.gl.getProgramInfoLog(this.program)));
            }
        }
        use() {
            this.gl.useProgram(this.program);
            return this;
        }
        uniformLoc(name) {
            let location;
            location = this.uniformCache[name];
            if (location === void 0) {
                location = this.uniformCache[name] = this.gl.getUniformLocation(this.program, name);
            }
            return location;
        }
        int(name, value) {
            let cached;
            let loc;
            cached = this.valueCache[name];
            if (cached !== value) {
                this.valueCache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1i(loc, value);
                }
            }
            return this;
        }
        vec2(name, a, b) {
            let loc;
            loc = this.uniformLoc(name);
            if (loc) {
                this.gl.uniform2f(loc, a, b);
            }
            return this;
        }
        float(name, value) {
            let cached;
            let loc;
            cached = this.valueCache[name];
            if (cached !== value) {
                this.valueCache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1f(loc, value);
                }
            }
            return this;
        }
    }
    Shader.vertexShaderBlit = `
        attribute vec4 position;
        varying vec2 texcoord;
        void main(){
            texcoord = position.xy*0.5+0.5;
            gl_Position = position;
        }
    `;
    Shader.fragmentShaderBlit = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp int;
            precision highp float;
        #else
            precision mediump int;
            precision mediump float;
        #endif
        uniform sampler2D source;
        varying vec2 texcoord;
    `;
    exports.Shader = Shader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HeatmapShader extends Shader_1.Shader {
        constructor(gl, getColorFun, output) {
            super(gl, HeatmapShader.vs, HeatmapShader.getFragmentShader(getColorFun, output));
        }
        static getFragmentShader(getColorFun, output) {
            return Shader_1.Shader.fragmentShaderBlit + (`
            float linstep(float low, float high, float value){
                return clamp((value-low)/(high-low), 0.0, 1.0);
            }

            float fade(float low, float high, float value){
                float mid = (low+high)*0.5;
                float range = (high-low)*0.5;
                float x = 1.0 - clamp(abs(mid-value)/range, 0.0, 1.0);
                return smoothstep(0.0, 1.0, x);
            }

            ` + getColorFun + `
            ` + output + `

            void main(){
                float intensity = smoothstep(0.0, 1.0, texture2D(source, texcoord).r);
                vec3 color = getColor(intensity);
                gl_FragColor = alphaFun(color, intensity);
            }
        `);
        }
    }
    HeatmapShader.vs = Shader_1.Shader.vertexShaderBlit;
    exports.HeatmapShader = HeatmapShader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/TextureObject", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TextureObject {
        constructor(gl, params) {
            let _ref;
            let _ref1;
            this.gl = gl;
            if (params == null) {
                params = {};
            }
            this.channels = this.gl[((_ref = params.channels) != null ? _ref : "rgba").toUpperCase()];
            if (typeof params.type === "number") {
                this.type = params.type;
            }
            else {
                this.type = this.gl[((_ref1 = params.type) != null ? _ref1 : "unsigned_byte").toUpperCase()];
            }
            switch (this.channels) {
                case this.gl.RGBA:
                    this.chancount = 4;
                    break;
                case this.gl.RGB:
                    this.chancount = 3;
                    break;
                case this.gl.LUMINANCE_ALPHA:
                    this.chancount = 2;
                    break;
                default:
                    this.chancount = 1;
            }
            this.target = this.gl.TEXTURE_2D;
            this.handle = this.gl.createTexture();
        }
        destroy() {
            return this.gl.deleteTexture(this.handle);
        }
        bind(unit) {
            if (unit == null) {
                unit = 0;
            }
            if (unit > 15) {
                throw new Error("Texture unit too large: " + unit);
            }
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
            this.gl.bindTexture(this.target, this.handle);
            return this;
        }
        setSize(width, height) {
            this.width = width;
            this.height = height;
            this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);
            return this;
        }
        upload(data) {
            this.width = data.width;
            this.height = data.height;
            this.gl.texImage2D(this.target, 0, this.channels, this.channels, this.type, data);
            return this;
        }
        linear() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            return this;
        }
        nearest() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            return this;
        }
        clampToEdge() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            return this;
        }
        repeat() {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
            return this;
        }
    }
    exports.TextureObject = TextureObject;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ClampShader extends Shader_2.Shader {
        constructor(gl) {
            super(gl, ClampShader.vs, ClampShader.fs);
        }
    }
    ClampShader.vs = Shader_2.Shader.vertexShaderBlit;
    ClampShader.fs = Shader_2.Shader.fragmentShaderBlit + `
        uniform float low, high;
        void main(){
            gl_FragColor = vec4(clamp(texture2D(source, texcoord).rgb, low, high), 1.0);
        }
    `;
    exports.ClampShader = ClampShader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MultiplyShader extends Shader_3.Shader {
        constructor(gl) {
            super(gl, MultiplyShader.vs, MultiplyShader.fs);
        }
    }
    MultiplyShader.vs = Shader_3.Shader.vertexShaderBlit;
    MultiplyShader.fs = Shader_3.Shader.fragmentShaderBlit + `
        uniform float value;
        void main(){
            gl_FragColor = vec4(texture2D(source, texcoord).rgb*value, 1.0);
        }
    `;
    exports.MultiplyShader = MultiplyShader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BlurShader extends Shader_4.Shader {
        constructor(gl) {
            super(gl, BlurShader.vs, BlurShader.fs);
        }
    }
    BlurShader.vs = Shader_4.Shader.vertexShaderBlit;
    BlurShader.fs = Shader_4.Shader.fragmentShaderBlit + `
        uniform vec2 viewport;
        void main(){
            vec4 result = vec4(0.0);
            for(int x=-1; x<=1; x++){
                for(int y=-1; y<=1; y++){
                    vec2 off = vec2(x,y)/viewport;
                    //float factor = 1.0 - smoothstep(0.0, 1.5, length(off));
                    float factor = 1.0;
                    result += vec4(texture2D(source, texcoord+off).rgb*factor, factor);
                }
            }
            gl_FragColor = vec4(result.rgb/result.w, 1.0);
        }`;
    exports.BlurShader = BlurShader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/Shader"], function (require, exports, Shader_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HeightsShader extends Shader_5.Shader {
        constructor(gl) {
            super(gl, HeightsShader.vs, HeightsShader.fs);
        }
    }
    HeightsShader.vs = `
        attribute vec4 position, intensity;
        varying vec2 off, dim;
        varying float vIntensity;
        uniform vec2 viewport;

        void main(){
            dim = abs(position.zw);
            off = position.zw;
            vec2 pos = position.xy + position.zw;
            vIntensity = intensity.x;
            gl_Position = vec4((pos/viewport)*2.0-1.0, 0.0, 1.0);
        }
    `;
    HeightsShader.fs = `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp int;
            precision highp float;
        #else
            precision mediump int;
            precision mediump float;
        #endif
        varying vec2 off, dim;
        varying float vIntensity;
        void main(){
            float falloff = (1.0 - smoothstep(0.0, 1.0, length(off/dim)));
            float intensity = falloff*vIntensity;
            gl_FragColor = vec4(intensity);
        }
    `;
    exports.HeightsShader = HeightsShader;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Framebuffer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Framebuffer {
        constructor(gl) {
            this.gl = gl;
            this.buffer = this.gl.createFramebuffer();
        }
        bind() {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);
            return this;
        }
        unbind(defaultFramebuffer) {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, defaultFramebuffer);
            return this;
        }
        check() {
            let result;
            result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
            switch (result) {
                case this.gl.FRAMEBUFFER_UNSUPPORTED:
                    throw new Error("Framebuffer is unsupported");
                case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    throw new Error("Framebuffer incomplete attachment");
                case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    throw new Error("Framebuffer incomplete dimensions");
                case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    throw new Error("Framebuffer incomplete missing attachment");
            }
            return this;
        }
        color(texture) {
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, texture.target, texture.handle, 0);
            this.check();
            return this;
        }
        depth(buffer) {
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, buffer.id);
            this.check();
            return this;
        }
        destroy() {
            return this.gl.deleteFramebuffer(this.buffer);
        }
    }
    exports.Framebuffer = Framebuffer;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Node", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/Framebuffer"], function (require, exports, TextureObject_1, Framebuffer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Node {
        constructor(gl, width, height, defaultFbo) {
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.defaultFbo = defaultFbo;
            let floatExt = this.gl.getFloatExtension({
                require: ["renderable"]
            });
            this.texture = new TextureObject_1.TextureObject(this.gl, {
                type: floatExt.type
            }).bind(0).setSize(this.width, this.height).nearest().clampToEdge();
            this.fbo = new Framebuffer_1.Framebuffer(this.gl).bind().color(this.texture).unbind(this.defaultFbo);
        }
        use() {
            this.fbo.bind();
            this.gl.viewport(0, 0, this.width, this.height);
            return this;
        }
        bind(unit) {
            return this.texture.bind(unit);
        }
        end() {
            return this.fbo.unbind(this.defaultFbo);
        }
        resize(width, height) {
            this.width = width;
            this.height = height;
            return this.texture.bind(0).setSize(this.width, this.height);
        }
    }
    exports.Node = Node;
});
define("src/map/view/world/layers/heatmapLayer/webgl/Heights", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", "src/map/view/world/layers/heatmapLayer/webgl/Node"], function (require, exports, ClampShader_1, MultiplyShader_1, BlurShader_1, HeightsShader_1, Node_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Heights {
        constructor(heatmap, gl, width, height, maxPointCount = 1024 * 10) {
            let i;
            let _i;
            let _ref;
            this.heatmap = heatmap;
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.shader = new HeightsShader_1.HeightsShader(this.gl);
            this.clampShader = new ClampShader_1.ClampShader(this.gl);
            this.multiplyShader = new MultiplyShader_1.MultiplyShader(this.gl);
            this.blurShader = new BlurShader_1.BlurShader(this.gl);
            this.nodeBack = new Node_1.Node(this.gl, this.width, this.height, this.heatmap.framebuffer);
            this.nodeFront = new Node_1.Node(this.gl, this.width, this.height, this.heatmap.framebuffer);
            this.vertexBuffer = this.gl.createBuffer();
            this.vertexSize = 8;
            this.maxPointCount = maxPointCount;
            this.vertexBufferData = new Float32Array(this.maxPointCount * this.vertexSize * 6);
            this.vertexBufferViews = [];
            for (i = _i = 0, _ref = this.maxPointCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                this.vertexBufferViews.push(new Float32Array(this.vertexBufferData.buffer, 0, i * this.vertexSize * 6));
            }
            this.bufferIndex = 0;
            this.pointCount = 0;
        }
        resize(width, height) {
            this.width = width;
            this.height = height;
            this.nodeBack.resize(this.width, this.height);
            return this.nodeFront.resize(this.width, this.height);
        }
        uploadHeightPoints() {
            if (this.pointCount > 0) {
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertexBufferViews[this.pointCount], this.gl.STREAM_DRAW);
            }
        }
        renderPointsToHeightMap() {
            this.nodeFront.use();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
            this.gl.enable(this.gl.BLEND);
            let positionLoc = this.shader.attribLocation("position");
            let intensityLoc = this.shader.attribLocation("intensity");
            this.gl.enableVertexAttribArray(1);
            this.gl.vertexAttribPointer(positionLoc, 4, this.gl.FLOAT, false, 8 * 4, 0 * 4);
            this.gl.vertexAttribPointer(intensityLoc, 4, this.gl.FLOAT, false, 8 * 4, 4 * 4);
            this.shader.use().vec2("viewport", this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, this.pointCount * 6);
            this.gl.disableVertexAttribArray(1);
            this.pointCount = 0;
            this.bufferIndex = 0;
            this.nodeFront.end();
            this.gl.disable(this.gl.BLEND);
        }
        clear() {
            this.nodeFront.use();
            this.gl.clearColor(0, 0, 0, 1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            return this.nodeFront.end();
        }
        clamp(min, max) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.clampShader.use().int("source", 0).float("low", min).float("high", max);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        multiply(value) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.multiplyShader.use().int("source", 0).float("value", value);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        blur() {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.blurShader.use().int("source", 0).vec2("viewport", this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        }
        swap() {
            let tmp;
            tmp = this.nodeFront;
            this.nodeFront = this.nodeBack;
            return this.nodeBack = tmp;
        }
        addVertex(x, y, xs, ys, intensity) {
            this.vertexBufferData[this.bufferIndex++] = x;
            this.vertexBufferData[this.bufferIndex++] = y;
            this.vertexBufferData[this.bufferIndex++] = xs;
            this.vertexBufferData[this.bufferIndex++] = ys;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            return this.vertexBufferData[this.bufferIndex++] = intensity;
        }
        addPoint(x, y, size, intensity) {
            let s;
            if (size == null) {
                size = 50;
            }
            if (intensity == null) {
                intensity = 0.2;
            }
            if (this.pointCount >= this.maxPointCount - 1) {
                this.uploadHeightPoints();
                this.pointCount = 0;
                this.bufferIndex = 0;
            }
            y = this.height - y;
            s = size / 2;
            this.addVertex(x, y, -s, -s, intensity);
            this.addVertex(x, y, +s, -s, intensity);
            this.addVertex(x, y, -s, +s, intensity);
            this.addVertex(x, y, -s, +s, intensity);
            this.addVertex(x, y, +s, -s, intensity);
            this.addVertex(x, y, +s, +s, intensity);
            return this.pointCount += 1;
        }
    }
    exports.Heights = Heights;
});
define("src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", ["require", "exports", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", "src/map/utils/Logger", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/Heights"], function (require, exports, HeatmapShader_1, Logger_8, TextureObject_2, Heights_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WebGlHeatmap {
        constructor(_arg, config = new WebGlHeatmap.Config()) {
            let alphaEnd;
            let alphaRange;
            let alphaStart;
            let error;
            let getColorFun;
            let gradientTexture;
            let image;
            let intensityToAlpha;
            let output;
            let quad;
            let textureGradient;
            let _ref;
            let _ref1;
            _ref = _arg != null ? _arg : {};
            this.gl = _ref.gl;
            this.framebuffer = _ref.framebuffer;
            this.width = _ref.width;
            this.height = _ref.height;
            intensityToAlpha = _ref.intensityToAlpha;
            gradientTexture = _ref.gradientTexture;
            alphaRange = _ref.alphaRange;
            if (window.WebGLDebugUtils != null) {
                Logger_8.Logger.logDebug("debugging mode");
                this.gl = WebGLDebugUtils.makeDebugContext(this.gl, function (err, funcName, args) {
                    throw new Error(WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName);
                });
            }
            this.gl.enableVertexAttribArray(0);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
            if (gradientTexture) {
                textureGradient = this.gradientTexture = new TextureObject_2.TextureObject(this.gl, {
                    channels: "rgba"
                }).bind(0).setSize(2, 2).nearest().clampToEdge();
                if (typeof gradientTexture === "string") {
                    image = new Image();
                    image.onload = function () {
                        return textureGradient.bind().upload(image);
                    };
                    image.src = gradientTexture;
                }
                else {
                    if (gradientTexture.width > 0 && gradientTexture.height > 0) {
                        textureGradient.upload(gradientTexture);
                    }
                    else {
                        gradientTexture.onload = function () {
                            return textureGradient.upload(gradientTexture);
                        };
                    }
                }
                getColorFun = `
                uniform sampler2D gradientTexture;
                vec3 getColor(float intensity){
                    return texture2D(gradientTexture, vec2(intensity, 0.0)).rgb;
                }
            `;
            }
            else {
                textureGradient = null;
                getColorFun = `
                vec3 getColor(float intensity){
                    vec3 blue = vec3(0.0, 0.0, 1.0);
                    vec3 cyan = vec3(0.0, 1.0, 1.0);
                    vec3 green = vec3(0.0, 1.0, 0.0);
                    vec3 yellow = vec3(1.0, 1.0, 0.0);
                    vec3 red = vec3(1.0, 0.0, 0.0);

                    vec3 color = (
                        fade(-0.25, 0.25, intensity)*blue +
                        fade(0.0, 0.5, intensity)*cyan +
                        fade(0.25, 0.75, intensity)*green +
                        fade(0.5, 1.0, intensity)*yellow +
                        smoothstep(0.75, 1.0, intensity)*red
                    );
                    return color;
                }
            `;
            }
            if (intensityToAlpha == null) {
                intensityToAlpha = true;
            }
            if (intensityToAlpha) {
                _ref1 = alphaRange != null ? alphaRange : [0, 1], alphaStart = _ref1[0], alphaEnd = _ref1[1];
                output = `
                vec4 alphaFun(vec3 color, float intensity){
                    float alpha = smoothstep(` + (alphaStart.toFixed(8)) + `, ` + (alphaEnd.toFixed(8)) + `, intensity);
                    return vec4(color*alpha, alpha);
                }
            `;
            }
            else {
                output = `
                vec4 alphaFun(vec3 color, float intensity){
                    return vec4(color, 1.0);
                }
            `;
            }
            this.shader = new HeatmapShader_1.HeatmapShader(this.gl, getColorFun, output);
            this.gl.viewport(0, 0, this.width, this.height);
            this.quad = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            quad = new Float32Array([-1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 1]);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, quad, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            this.heights = new Heights_1.Heights(this, this.gl, this.width, this.height, config.maxNumOfHeatpoints);
        }
        adjustSize(targetWidth, targetHeight) {
            let canvasWidth = targetWidth || 2;
            let canvasHeight = targetHeight || 2;
            if (this.width !== canvasWidth || this.height !== canvasHeight) {
                this.gl.viewport(0, 0, canvasWidth, canvasHeight);
                this.width = canvasWidth;
                this.height = canvasHeight;
                return this.heights.resize(this.width, this.height);
            }
        }
        renderColorizedHeightMap() {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.heights.nodeFront.bind(0);
            if (this.gradientTexture) {
                this.gradientTexture.bind(1);
            }
            this.shader.use().int("source", 0).int("gradientTexture", 1);
            return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        uploadHeightPoints() {
            return this.heights.uploadHeightPoints();
        }
        renderPointsToHeightMap() {
            return this.heights.renderPointsToHeightMap();
        }
        clear() {
            return this.heights.clear();
        }
        clamp(min, max) {
            if (min == null) {
                min = 0;
            }
            if (max == null) {
                max = 1;
            }
            return this.heights.clamp(min, max);
        }
        multiply(value) {
            if (value == null) {
                value = 0.95;
            }
            return this.heights.multiply(value);
        }
        blur() {
            return this.heights.blur();
        }
        addPoint(x, y, size, intensity) {
            return this.heights.addPoint(x, y, size, intensity);
        }
        addPoints(items) {
            let item;
            let _i;
            let _len;
            let _results;
            _results = [];
            for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                _results.push(this.addPoint(item.x, item.y, item.size, item.intensity));
            }
            return _results;
        }
    }
    exports.WebGlHeatmap = WebGlHeatmap;
    (function (WebGlHeatmap) {
        class Config {
            constructor() {
                /**
                 * The maximum number of heatpoints that can be loaded into the GPU memory.
                 *
                 * <p>
                 * Whenever the number of added heatpoints exceeds this threshold, the vertex buffer containing
                 * the heatpoint coordinates and intensities will be flushed and only the heatpoints added after the flush will be
                 * loaded to the GPU afterwards. This will lead to a "starvation" of all flushed vertices
                 * when applying the multipy shader several times, as the multiply shader will decrease the intensity of all heatpoints
                 * for each execution of the multiply shader program by the multiplication factor.
                 * </p>
                 *
                 * <p>Must be a power of 2</p>
                 *
                 * <p>Default: 8192</p>
                 */
                this.maxNumOfHeatpoints = 8192;
            }
        }
        WebGlHeatmap.Config = Config;
    })(WebGlHeatmap = exports.WebGlHeatmap || (exports.WebGlHeatmap = {}));
    /* tslint:disable */
    // Generated by CoffeeScript 1.8.0
    var __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
            return i;
    } return -1; };
    let nukeVendorPrefix = function () {
        var getExtension, getSupportedExtensions, vendorRe, vendors;
        if (window.WebGLRenderingContext != null) {
            vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];
            vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj, match, vendor, _i, _len;
                match = name.match(vendorRe);
                if (match !== null) {
                    name = match[1];
                }
                extobj = getExtension.call(this, name);
                if (extobj === null) {
                    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
                        vendor = vendors[_i];
                        extobj = getExtension.call(this, vendor + '_' + name);
                        if (extobj !== null) {
                            return extobj;
                        }
                    }
                    return null;
                }
                else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            return WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, match, result, supported, _i, _len;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_i = 0, _len = supported.length; _i < _len; _i++) {
                    extension = supported[_i];
                    match = extension.match(vendorRe);
                    if (match !== null) {
                        extension = match[1];
                    }
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
        }
    };
    let textureFloatShims = function () {
        var checkColorBuffer, checkFloatLinear, checkSupport, checkTexture, createSourceCanvas, getExtension, getSupportedExtensions, name, shimExtensions, shimLookup, unshimExtensions, unshimLookup, _i, _len;
        createSourceCanvas = function () {
            var canvas, ctx, imageData;
            canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            ctx = canvas.getContext('2d');
            imageData = ctx.getImageData(0, 0, 2, 2);
            imageData.data.set(new Uint8ClampedArray([0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]));
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };
        createSourceCanvas();
        checkFloatLinear = function (gl, sourceType) {
            var buffer, cleanup, fragmentShader, framebuffer, positionLoc, program, readBuffer, result, source, sourceCanvas, sourceLoc, target, vertexShader, vertices;
            program = gl.createProgram();
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.attachShader(program, vertexShader);
            gl.shaderSource(vertexShader, 'attribute vec2 position;\nvoid main(){\n    gl_Position = vec4(position, 0.0, 1.0);\n}');
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(vertexShader);
            }
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.attachShader(program, fragmentShader);
            gl.shaderSource(fragmentShader, 'uniform sampler2D source;\nvoid main(){\n    gl_FragColor = texture2D(source, vec2(1.0, 1.0));\n}');
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(fragmentShader);
            }
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw gl.getProgramInfoLog(program);
            }
            gl.useProgram(program);
            cleanup = function () {
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteProgram(program);
                gl.deleteBuffer(buffer);
                gl.deleteTexture(source);
                gl.deleteTexture(target);
                gl.deleteFramebuffer(framebuffer);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            };
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            sourceCanvas = createSourceCanvas();
            source = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, source);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, sourceType, sourceCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            positionLoc = gl.getAttribLocation(program, 'position');
            sourceLoc = gl.getUniformLocation(program, 'source');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform1i(sourceLoc, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            readBuffer = new Uint8Array(4 * 4);
            gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, readBuffer);
            result = Math.abs(readBuffer[0] - 127) < 10;
            cleanup();
            return result;
        };
        checkTexture = function (gl, targetType) {
            var target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            if (gl.getError() === 0) {
                gl.deleteTexture(target);
                return true;
            }
            else {
                gl.deleteTexture(target);
                return false;
            }
        };
        checkColorBuffer = function (gl, targetType) {
            var check, framebuffer, target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.deleteTexture(target);
            gl.deleteFramebuffer(framebuffer);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (check === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            }
            else {
                return false;
            }
        };
        shimExtensions = [];
        shimLookup = {};
        unshimExtensions = [];
        checkSupport = function () {
            var canvas, extobj, gl, halfFloatExt, halfFloatTexturing, singleFloatExt, singleFloatTexturing;
            canvas = document.createElement('canvas');
            gl = null;
            try {
                gl = canvas.getContext('experimental-webgl');
                if (gl === null) {
                    gl = canvas.getContext('webgl');
                }
            }
            catch (_error) { }
            if (gl != null) {
                singleFloatExt = gl.getExtension('OES_texture_float');
                if (singleFloatExt === null) {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                        shimLookup.OES_texture_float = {
                            shim: true
                        };
                    }
                    else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                else {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                    }
                    else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                if (singleFloatTexturing) {
                    extobj = gl.getExtension('WEBGL_color_buffer_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                            shimLookup.WEBGL_color_buffer_float = {
                                shim: true,
                                RGBA32F_EXT: 0x8814,
                                RGB32F_EXT: 0x8815,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        }
                        else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    else {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                        }
                        else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                            shimLookup.OES_texture_float_linear = {
                                shim: true
                            };
                        }
                        else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                    else {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                        }
                        else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                }
                halfFloatExt = gl.getExtension('OES_texture_half_float');
                if (halfFloatExt === null) {
                    if (checkTexture(gl, 0x8D61)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                        halfFloatExt = shimLookup.OES_texture_half_float = {
                            HALF_FLOAT_OES: 0x8D61,
                            shim: true
                        };
                    }
                    else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                else {
                    if (checkTexture(gl, halfFloatExt.HALF_FLOAT_OES)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                    }
                    else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                if (halfFloatTexturing) {
                    extobj = gl.getExtension('EXT_color_buffer_half_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                            shimLookup.EXT_color_buffer_half_float = {
                                shim: true,
                                RGBA16F_EXT: 0x881A,
                                RGB16F_EXT: 0x881B,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        }
                        else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    else {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                        }
                        else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_half_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('OES_texture_half_float_linear');
                            return shimLookup.OES_texture_half_float_linear = {
                                shim: true
                            };
                        }
                        else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                    else {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            return shimExtensions.push('OES_texture_half_float_linear');
                        }
                        else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                }
            }
        };
        if (window.WebGLRenderingContext != null) {
            checkSupport();
            unshimLookup = {};
            for (_i = 0, _len = unshimExtensions.length; _i < _len; _i++) {
                name = unshimExtensions[_i];
                unshimLookup[name] = true;
            }
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj;
                extobj = shimLookup[name];
                if (extobj === void 0) {
                    if (unshimLookup[name]) {
                        return null;
                    }
                    else {
                        return getExtension.call(this, name);
                    }
                }
                else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, result, supported, _j, _k, _len1, _len2;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_j = 0, _len1 = supported.length; _j < _len1; _j++) {
                    extension = supported[_j];
                    if (unshimLookup[extension] === void 0) {
                        result.push(extension);
                    }
                }
                for (_k = 0, _len2 = shimExtensions.length; _k < _len2; _k++) {
                    extension = shimExtensions[_k];
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
            return WebGLRenderingContext.prototype.getFloatExtension = function (spec) {
                var candidate, candidates, half, halfFramebuffer, halfLinear, halfTexture, i, importance, preference, result, single, singleFramebuffer, singleLinear, singleTexture, use, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
                if (spec.prefer == null) {
                    spec.prefer = ['half'];
                }
                if (spec.require == null) {
                    spec.require = [];
                }
                if (spec.throws == null) {
                    spec.throws = true;
                }
                singleTexture = this.getExtension('OES_texture_float');
                halfTexture = this.getExtension('OES_texture_half_float');
                singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
                halfFramebuffer = this.getExtension('EXT_color_buffer_half_float');
                singleLinear = this.getExtension('OES_texture_float_linear');
                halfLinear = this.getExtension('OES_texture_half_float_linear');
                single = {
                    texture: singleTexture !== null,
                    filterable: singleLinear !== null,
                    renderable: singleFramebuffer !== null,
                    score: 0,
                    precision: 'single',
                    half: false,
                    single: true,
                    type: this.FLOAT
                };
                half = {
                    texture: halfTexture !== null,
                    filterable: halfLinear !== null,
                    renderable: halfFramebuffer !== null,
                    score: 0,
                    precision: 'half',
                    half: true,
                    single: false,
                    type: (_ref = halfTexture != null ? halfTexture.HALF_FLOAT_OES : void 0) != null ? _ref : null
                };
                candidates = [];
                if (single.texture) {
                    candidates.push(single);
                }
                if (half.texture) {
                    candidates.push(half);
                }
                result = [];
                for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                    candidate = candidates[_j];
                    use = true;
                    _ref1 = spec.require;
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                        name = _ref1[_k];
                        if (candidate[name] === false) {
                            use = false;
                        }
                    }
                    if (use) {
                        result.push(candidate);
                    }
                }
                for (_l = 0, _len3 = result.length; _l < _len3; _l++) {
                    candidate = result[_l];
                    _ref2 = spec.prefer;
                    for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
                        preference = _ref2[i];
                        importance = Math.pow(2, spec.prefer.length - i - 1);
                        if (candidate[preference]) {
                            candidate.score += importance;
                        }
                    }
                }
                result.sort(function (a, b) {
                    if (a.score === b.score) {
                        return 0;
                    }
                    else if (a.score < b.score) {
                        return 1;
                    }
                    else if (a.score > b.score) {
                        return -1;
                    }
                });
                if (result.length === 0) {
                    if (spec.throws) {
                        throw 'No floating point texture support that is ' + spec.require.join(', ');
                    }
                    else {
                        return null;
                    }
                }
                else {
                    result = result[0];
                    return {
                        filterable: result.filterable,
                        renderable: result.renderable,
                        type: result.type,
                        precision: result.precision
                    };
                }
            };
        }
    };
    nukeVendorPrefix();
    textureFloatShims();
});
define("src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", ["require", "exports", "src/map/utils/Logger", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/BaseTexture", "src/engine/rendering/texture/Texture"], function (require, exports, Logger_9, Layer_17, HeatmapLayerImpl_1, WebGlHeatmap_1, SpriteObject_17, BaseTexture_6, Texture_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A WebGL shader based heatmap.
     *
     * A texture with floorplan dimensions will be created
     * and attached to a sprite.
     * Whenever the heatmap changes, the texture will be
     * modified in the GPU using a custom WebGL vertex
     * and fragment shader program.
     * The implementation is based on
     * https://github.com/pyalot/webgl-heatmap
     */
    class WebGlHeatmapLayer extends Layer_17.Layer {
        // Construction
        constructor(environment, config) {
            super(environment);
            // Rendering
            this.heatmap = null;
            // State
            this.pointsToAdd = new Array();
            this.clampMin = 0;
            this.clampMax = 1;
            this.multiplicationFactor = 1.0;
            this.dirty = true;
            this.dirtyClear = false;
            this.config = config;
            // Create canvas with floor size
            let canvas = document.createElement("canvas");
            canvas.width = config.textureWidth;
            canvas.height = config.textureHeight;
            // Create TextObjectures
            let baseTexture = new BaseTexture_6.BaseTexture(new PIXI.BaseTexture(canvas), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_16.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            this.sprite = new WebGlHeatmapLayer.HeatmapSprite(texture.pixi());
            this.spriteObject = new SpriteObject_17.SpriteObject(this.sprite, this.getEnvironment().renderingEnvironment);
            this.spriteObject.width = config.floorWidth;
            this.spriteObject.height = config.floorHeight;
            this.getView().addChild(this.spriteObject);
        }
        // Configuration
        // @Override
        addPoint(x, y, radius, intensity) {
            y = this.sprite.texture.baseTexture.height - y;
            let point = { x: x, y: y, size: radius * 2, intensity: intensity };
            this.pointsToAdd.push(point);
            this.dirty = true;
        }
        // @Override
        addPoints(points) {
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                this.addPoint(point.x, point.y, point.radius, point.intensity);
            }
            this.dirty = true;
        }
        // @Override
        clear() {
            this.pointsToAdd = [0, 0, 0, 0];
            this.dirtyClear = true;
            this.dirty = true;
        }
        // @Override
        clamp(min, max) {
            this.clampMin = min;
            this.clampMax = max;
            this.dirty = true;
        }
        // @Override
        multiply(value) {
            this.multiplicationFactor = value;
            this.dirty = true;
        }
        // Rendering
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            let renderer = this.sprite.renderer;
            if (renderer !== null) {
                if (this.dirty === true) {
                    this.renderHeatmapToTexture(renderer);
                    this.getEnvironment().renderingEnvironment.dirty = true;
                    this.dirty = false;
                    this.dirtyClear = false;
                }
            }
        }
        renderHeatmapToTexture(renderer) {
            try {
                // Prepare the renderer for rendering to texture.
                this.resetRenderer(renderer);
                // Initialize heatmap if necessary
                if (this.heatmap === null) {
                    this.initHeatmap(renderer);
                }
                // Upload heat points
                this.uploadHeatpoints();
                // Render the heatmap to the sprite's texture.
                this.renderHeatmap(renderer.gl);
                // Reset renderer to previous state (rendering to screen framebuffer again)
                this.resetRendererToPreviousState(renderer);
            }
            catch (e) {
                Logger_9.Logger.logDebug("An error occurred while rendering the heatmap to texture. " + e.message);
            }
        }
        resetRenderer(renderer) {
            // Reset the renderer to avoid working on VAOs from Pixi.
            renderer.reset();
        }
        initHeatmap(renderer) {
            try {
                let gl = renderer.gl;
                // Create framebuffer that will be used to render to texture.
                this.webGlFramebuffer = gl.createFramebuffer();
                // Bind the framebuffer
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.webGlFramebuffer);
                // Change viewport back to fit the texture size
                gl.viewport(0, 0, this.sprite.texture.baseTexture.width, this.sprite.texture.baseTexture.height);
                // Force Pixi to load the native WebGL texture object to the GPU.
                renderer.textureManager.updateTexture(this.sprite.texture.baseTexture);
                // Get the sprite's native WebGL texture.
                this.webGlTexture = this.sprite.texture.baseTexture._glTextures[renderer.CONTEXT_UID].texture;
                // Bind sprite texture to framebuffer
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.webGlTexture, 0);
                this.heatmap = new WebGlHeatmap_1.WebGlHeatmap({
                    gl: renderer.gl,
                    framebuffer: this.webGlFramebuffer,
                    width: this.sprite.texture.width,
                    height: this.sprite.texture.height
                }, this.config.heatmapShader);
            }
            catch (error) {
                Logger_9.Logger.logDebug("Failed to create WebGL heatmap. " + error.message);
            }
        }
        uploadHeatpoints() {
            // Add points
            if (this.pointsToAdd.length > 0) {
                this.heatmap.addPoints(this.pointsToAdd);
                this.pointsToAdd = [];
            }
            // Load height points into GPU.
            this.heatmap.uploadHeightPoints();
        }
        renderHeatmap(gl) {
            this.renderPointsToHeightMap();
            this.renderHeightMapToTexture(gl);
        }
        renderPointsToHeightMap() {
            // Clear framebuffer if necessary
            if (this.dirtyClear === true) {
                this.heatmap.clear();
            }
            // Draw heat points to height map
            this.heatmap.renderPointsToHeightMap();
            // Multiply if necessary
            this.heatmap.multiply(this.multiplicationFactor);
            // Clamp if necessary
            this.heatmap.clamp(this.clampMin, this.clampMax);
        }
        renderHeightMapToTexture(gl) {
            // Bind to the sprite texture's framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.webGlFramebuffer);
            // Change viewport to fit the texture size
            gl.viewport(0, 0, this.sprite.texture.baseTexture.width, this.sprite.texture.baseTexture.height);
            // Draw the height map on a quad fitting the texture's framebuffer size.
            this.heatmap.renderColorizedHeightMap();
        }
        resetRendererToPreviousState(renderer) {
            // Reset the WebGL renderer to use the previous shader program again
            // and to rebind the framebuffer and reset the viewport used before.
            renderer.reset();
            // We need to rebind the vertex array object, as it was set to null in the renderer reset.
            let state = renderer.state;
            if (state.nativeVaoExtension) {
                state.nativeVaoExtension.bindVertexArrayOES(renderer._activeVao.nativeVao);
            }
        }
    }
    exports.WebGlHeatmapLayer = WebGlHeatmapLayer;
    (function (WebGlHeatmapLayer) {
        class Config extends HeatmapLayerImpl_1.HeatmapLayerImpl.Config {
            constructor() {
                super(...arguments);
                /**
                 * The configuration for the WebGL heatmap implementation
                 */
                this.heatmapShader = new WebGlHeatmap_1.WebGlHeatmap.Config();
            }
        }
        WebGlHeatmapLayer.Config = Config;
        class HeatmapSprite extends PIXI.Sprite {
            constructor() {
                super(...arguments);
                this.renderer = null;
            }
            _renderWebGL(renderer) {
                super._renderWebGL(renderer);
                this.renderer = renderer;
            }
        }
        WebGlHeatmapLayer.HeatmapSprite = HeatmapSprite;
    })(WebGlHeatmapLayer = exports.WebGlHeatmapLayer || (exports.WebGlHeatmapLayer = {}));
});
define("src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/texture/BaseTexture", "src/engine/rendering/texture/Texture"], function (require, exports, Layer_18, HeatmapLayerImpl_2, CanvasHeatmap_2, SpriteObject_18, BaseTexture_7, Texture_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class CanvasHeatmapLayer extends Layer_18.Layer {
        // Construction
        constructor(environment, config) {
            super(environment);
            // State
            this.clampMin = 0;
            this.clampMax = 1;
            this.dirty = false;
            // Create canvas with floor size
            this.canvas = document.createElement("canvas");
            this.canvas.width = config.textureWidth;
            this.canvas.height = config.textureHeight;
            // Create TextObjectures
            let baseTexture = new BaseTexture_7.BaseTexture(new PIXI.BaseTexture(this.canvas), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_17.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            this.sprite = new SpriteObject_18.SpriteObject(new PIXI.Sprite(texture.pixi()), this.getEnvironment().renderingEnvironment);
            this.sprite.width = config.floorWidth;
            this.sprite.height = config.floorHeight;
            this.getView().addChild(this.sprite);
            // Create heatmap
            this.heatmap = new CanvasHeatmap_2.CanvasHeatmap(this.canvas);
        }
        // Configuration
        // @Override
        addPoint(x, y, radius, intensity) {
            this.heatmap.radius(radius);
            this.heatmap.add([x, y, intensity]);
            this.dirty = true;
        }
        // @Override
        addPoints(points) {
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                this.addPoint(point.x, point.y, point.radius, point.intensity);
            }
            this.dirty = true;
        }
        // @Override
        clear() {
            this.heatmap.clear();
            this.dirty = true;
        }
        // @Override
        clamp(min, max) {
            this.clampMin = min;
            this.clampMax = max;
            this.dirty = true;
        }
        // @Override
        multiply(value) {
            // Not implemented yet.
            this.dirty = true;
        }
        // Rendering
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.dirty === true) {
                this.dirty = false;
                this.heatmap.max(1.0 / this.clampMax);
                this.heatmap.draw(this.clampMin);
                this.sprite.texture.baseTexture.loadSource(this.canvas);
            }
        }
    }
    exports.CanvasHeatmapLayer = CanvasHeatmapLayer;
    (function (CanvasHeatmapLayer) {
        class Config extends HeatmapLayerImpl_2.HeatmapLayerImpl.Config {
        }
        CanvasHeatmapLayer.Config = Config;
    })(CanvasHeatmapLayer = exports.CanvasHeatmapLayer || (exports.CanvasHeatmapLayer = {}));
});
define("src/map/view/world/layers/heatmapLayer/HeatmapLayer", ["require", "exports", "src/map/view/Layer", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer"], function (require, exports, Layer_19, WebGlHeatmapLayer_1, CanvasHeatmapLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A WebGL based heatmap with canvas fallback.
     */
    class HeatmapLayer extends Layer_19.Layer {
        // Construction
        constructor(environment, floorplanLayer, config = new HeatmapLayer.Config) {
            super(environment);
            this.scaleFactor = 1.0;
            this.config = config;
            this.floorplanLayer = floorplanLayer;
            if (this.useWebGl()) {
                this.heatmapLayerImpl = this.createWebGlHeatmapLayer();
            }
            else {
                this.heatmapLayerImpl = this.createCanvasHeatmapLayer();
            }
            this.addChild(this.heatmapLayerImpl);
        }
        useWebGl() {
            PIXI.utils.skipHello();
            let renderer = PIXI.autoDetectRenderer(1, 1);
            return !this.config.alwaysPreferCanvasMode && renderer instanceof PIXI.WebGLRenderer;
        }
        createWebGlHeatmapLayer() {
            this.configMandatoryFields(this.config.webGlHeatmapLayer);
            let heatmapLayerImpl = new WebGlHeatmapLayer_1.WebGlHeatmapLayer(this.getEnvironment(), this.config.webGlHeatmapLayer);
            return heatmapLayerImpl;
        }
        createCanvasHeatmapLayer() {
            this.configMandatoryFields(this.config.canvasHeatmapLayer);
            let heatmapLayerImpl = new CanvasHeatmapLayer_1.CanvasHeatmapLayer(this.getEnvironment(), this.config.canvasHeatmapLayer);
            return heatmapLayerImpl;
        }
        configMandatoryFields(implConfig) {
            implConfig.floorWidth = this.floorplanLayer.getFloorSize().x;
            implConfig.floorHeight = this.floorplanLayer.getFloorSize().y;
            implConfig.textureWidth = Math.min(this.config.maxTextureWidthInPx, implConfig.floorWidth);
            implConfig.textureHeight = implConfig.textureWidth * (implConfig.floorHeight / implConfig.floorWidth);
            this.scaleFactor = implConfig.textureWidth / implConfig.floorWidth;
        }
        // Configuration
        /**
         * Adds a height point to the heatmap
         * @param x The x coordinate in centimeters
         * @param y The y coordinate in centimeters
         * @param radius The radius of the height point (in centimeters)
         * @param intensity The intensity \in [0,1]
         */
        addPoint(x, y, radius, intensity) {
            let transformedPoint = this.getTransformedPoint({ x: x, y: y, radius: radius, intensity: intensity });
            this.heatmapLayerImpl.addPoints([transformedPoint]);
        }
        /**
         * Adds multiple {x,y,radius,intensity} data points at once to the heatmap
         * @param items
         */
        addPoints(points) {
            let transformedPoints = [];
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                let transformedPoint = this.getTransformedPoint(point);
                transformedPoints.push(transformedPoint);
            }
            this.heatmapLayerImpl.addPoints(transformedPoints);
        }
        /**
         * Removes all height points from the heatmap.
         */
        clear() {
            this.heatmapLayerImpl.clear();
        }
        /**
         * Clamps the height point intensities to [min, max]
         * @param min
         * @param max
         */
        clamp(min, max) {
            this.heatmapLayerImpl.clamp(min, max);
        }
        /**
         * Multiply all values in the heatmap by a number (useful for decay)
         * @param value multiplication factor
         */
        multiply(value) {
            this.heatmapLayerImpl.multiply(value);
        }
        // Helper methods
        getTransformedPoint(point) {
            let xInTexture = this.floorplanLayer.getTexelsFromCm(point.x) * this.scaleFactor;
            let yInTexture = this.floorplanLayer.getTexelsFromCm(point.y) * this.scaleFactor;
            let radiusInTexture = this.floorplanLayer.getTexelsFromCm(point.radius) * this.scaleFactor;
            let intensity = point.intensity;
            return { x: xInTexture, y: yInTexture, radius: radiusInTexture, intensity: intensity };
        }
    }
    exports.HeatmapLayer = HeatmapLayer;
    (function (HeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * The maximum width the texture of the heatmap layer can take.
                 *
                 * Default: 4096 texels
                 */
                this.maxTextureWidthInPx = 4096;
                /**
                 * True, if the canvas implementation of the heatmap layer should
                 * always be preferred instead of the WebGL shader implementation.
                 *
                 * Default: false
                 */
                this.alwaysPreferCanvasMode = false;
                /**
                 * The configuration for the WebGL implementation
                 */
                this.webGlHeatmapLayer = new WebGlHeatmapLayer_1.WebGlHeatmapLayer.Config();
                /**
                 * The configuration for the Canvas implementation
                 */
                this.canvasHeatmapLayer = new CanvasHeatmapLayer_1.CanvasHeatmapLayer.Config();
            }
        }
        HeatmapLayer.Config = Config;
    })(HeatmapLayer = exports.HeatmapLayer || (exports.HeatmapLayer = {}));
});
define("src/map/view/world/objects/InvisibleObject", ["require", "exports", "src/engine/scene/SceneObject", "src/engine/rendering/objects/DisplayObjectContainer"], function (require, exports, SceneObject_15, DisplayObjectContainer_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class InvisibleObject extends SceneObject_15.SceneObject {
        // Initialization
        constructor(environment) {
            super(environment);
            this.container = new DisplayObjectContainer_19.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.container.visible = false;
        }
        // View
        // @Override
        getView() {
            return this.container;
        }
    }
    exports.InvisibleObject = InvisibleObject;
});
define("src/index", ["require", "exports", "src/app/portal/PortalMap", "src/app/relution/RelutionMap", "src/app/relution/events/RelutionEventSystem", "src/app/relution/locale/LocalizationDe", "src/app/relution/locale/LocalizationEn", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/device/DeviceTagModel", "src/app/relution/model/floor/FloorModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/geofence/GeofenceModel", "src/app/relution/model/geofence/GeofenceStateModel", "src/app/relution/model/indoor/PositionEstimateModel", "src/app/relution/model/usercount/HeatmapDeviceModel", "src/app/relution/model/usercount/HeatmapModel", "src/app/relution/modes/DeviceEditMode", "src/app/relution/modes/DeviceTaggingMode", "src/app/relution/modes/GeofenceEditMode", "src/app/relution/modes/RelutionMapMode", "src/app/relution/modes/SingleDeviceEditMode", "src/app/relution/modes/TapeMeasureEditMode", "src/app/relution/utils/IntersectionUtils", "src/app/relution/utils/KeyUtils", "src/app/relution/utils/MouseUtils", "src/app/relution/utils/ReflectionUtils", "src/app/relution/utils/RssiToDistance", "src/app/relution/utils/SerialNumberUtils", "src/app/relution/utils/UuidUtils", "src/app/relution/view/hud/RelutionMapHud", "src/app/relution/view/hud/barLayer/Bar", "src/app/relution/view/hud/barLayer/BarLayer", "src/app/relution/view/hud/barLayer/actionBar/Action", "src/app/relution/view/hud/barLayer/actionBar/ActionBar", "src/app/relution/view/hud/barLayer/actionBar/ToggleAction", "src/app/relution/view/hud/barLayer/beaconBar/BeaconBar", "src/app/relution/view/hud/barLayer/beaconBar/BeaconItem", "src/app/relution/view/hud/helpLayer/HelpLayer", "src/app/relution/view/hud/popupLayer/PopupLayer", "src/app/relution/view/hud/popupLayer/RelutionMapObjectPopupLayer", "src/app/relution/view/hud/selectionLayer/SelectionLayer", "src/app/relution/view/hud/tapeMeasure/TapeMeasureHudLayer", "src/app/relution/view/world/Building", "src/app/relution/view/world/Floor", "src/app/relution/view/world/RelutionMapAttributeObject", "src/app/relution/view/world/RelutionMapAttributeObjectLayer", "src/app/relution/view/world/RelutionMapObject", "src/app/relution/view/world/RelutionMapObjectLayer", "src/app/relution/view/world/RelutionMapWorld", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnection", "src/app/relution/view/world/layers/deviceLayers/beaconConnectionsLayer/BeaconConnectionsLayer", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetails", "src/app/relution/view/world/layers/deviceLayers/beaconDetailsLayer/BeaconConnectionDetailsLayer", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRange", "src/app/relution/view/world/layers/deviceLayers/beaconRangeLayer/BeaconRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRange", "src/app/relution/view/world/layers/deviceLayers/deviceAccuracyRangeLayer/DeviceAccuracyRangeLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/DeviceLayer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGateway", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTag", "src/app/relution/view/world/layers/deviceLayers/deviceTaggingLayer/DeviceTaggingLayer", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrack", "src/app/relution/view/world/layers/deviceLayers/deviceTrackLayer/DeviceTrackLayer", "src/app/relution/view/world/layers/deviceLayers/singleDeviceEditLayer/SingleDeviceEditLayer", "src/app/relution/view/world/layers/deviceLayers/userCountHeatmapLayer/UserCountHeatmapLayer", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TextureUpdateLayer", "src/app/relution/view/world/layers/floorplanLayers/benchmarkLayers/TileBasedBenchmarkLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/AbstractFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/FloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/ImageBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanLayer/TileBasedFloorplanLayer", "src/app/relution/view/world/layers/floorplanLayers/floorplanOverlayLayer/FloorplanOverlayLayer", "src/app/relution/view/world/layers/floorplanLayers/wallplanLayer/WallplanLayer", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/GeofenceLayer", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/CircleGeofence", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/PolygonGeofence", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/geofences/RectangleGeofence", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfo", "src/app/relution/view/world/layers/objectLayers/objectInfoLayer/RelutionMapObjectInfoLayer", "src/app/relution/view/world/layers/overlayLayers/tapeMeasureLayer/TapeMeasureWorldLayer", "src/app/relution/view/world/management/AutonomousObjectModelBinder", "src/app/relution/view/world/management/CoupledObjectModelBinder", "src/app/relution/view/world/management/RelutionMapObjectModelBinder", "src/app/relution/view/world/management/ViewModelBinder", "src/app/simulator/SimulatorMap", "src/app/simulator/view/hud/popupLayer/BeaconConnectionDetailsPopupLayer", "src/app/world/WorldMap", "src/engine/Game", "src/engine/animation/Animation", "src/engine/animation/BackInterpolator", "src/engine/animation/BounceInterpolator", "src/engine/animation/CubicInterpolator", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "src/engine/animation/LinearInterpolator", "src/engine/animation/QuatricInterpolator", "src/engine/animation/SquareInterpolator", "src/engine/general/AABB", "src/engine/general/OBB", "src/engine/input/GestureRecognizer", "src/engine/input/InputEvent", "src/engine/input/InputSystem", "src/engine/input/MacKeyDetector", "src/engine/locale/Localization", "src/engine/locale/UnresolvedLocalization", "src/engine/math/Vector2", "src/engine/rendering/DecoratingObject", "src/engine/rendering/RenderingEnvironment", "src/engine/rendering/filters/SpriteInverseMaskFilter", "src/engine/rendering/filters/TextureMatrix", "src/engine/rendering/objects/DisplayObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/TextObject", "src/engine/rendering/objects/text/TextStyle", "src/engine/rendering/pixi/HighResText", "src/engine/rendering/texture/BaseTexture", "src/engine/rendering/texture/Texture", "src/engine/rendering/utils/ObservablePoint", "src/engine/rendering/utils/Point", "src/engine/scene/Camera", "src/engine/scene/GameObject", "src/engine/scene/Scene", "src/engine/scene/SceneObject", "src/engine/structs/SceneObjectListIterator", "src/engine/utils/UnsupportedOperationException", "src/map/FruityMap", "src/map/utils/ArrayUtils", "src/map/utils/DateUtils", "src/map/utils/DeviceUtils", "src/map/utils/GraphicsUtils", "src/map/utils/Language", "src/map/utils/Logger", "src/map/utils/MathUtils", "src/map/utils/Prando", "src/map/utils/Simplify", "src/map/utils/StringUtils", "src/map/utils/SystemUtils", "src/map/view/Layer", "src/map/view/hud/Hud", "src/map/view/hud/layers/controlLayer/Compass", "src/map/view/hud/layers/controlLayer/ControlLayer", "src/map/view/hud/layers/controlLayer/PanObject", "src/map/view/hud/layers/controlLayer/ZoomObject", "src/map/view/hud/layers/navigationLayer/NavigationLayer", "src/map/view/hud/objects/ArrowObject", "src/map/view/hud/objects/ButtonObject", "src/map/view/hud/objects/ScrollableContentObject", "src/map/view/hud/objects/ScrollableObject", "src/map/view/world/World", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayerImpl", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmap", "src/map/view/world/layers/heatmapLayer/canvas/CanvasHeatmapLayer", "src/map/view/world/layers/heatmapLayer/webgl/Framebuffer", "src/map/view/world/layers/heatmapLayer/webgl/Heights", "src/map/view/world/layers/heatmapLayer/webgl/Node", "src/map/view/world/layers/heatmapLayer/webgl/Shader", "src/map/view/world/layers/heatmapLayer/webgl/TextureObject", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmap", "src/map/view/world/layers/heatmapLayer/webgl/WebGlHeatmapLayer", "src/map/view/world/layers/heatmapLayer/webgl/shaders/BlurShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/ClampShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeatmapShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/HeightsShader", "src/map/view/world/layers/heatmapLayer/webgl/shaders/MultiplyShader", "src/map/view/world/layers/tileLayer/LocalTileLoader", "src/map/view/world/layers/tileLayer/RemoteTileLoader", "src/map/view/world/layers/tileLayer/RemoteTileResponse", "src/map/view/world/layers/tileLayer/Tile", "src/map/view/world/layers/tileLayer/TileEngine", "src/map/view/world/layers/tileLayer/TileLayer", "src/map/view/world/layers/tileLayer/TileLoader", "src/map/view/world/layers/tileLayer/TileObject", "src/map/view/world/layers/tileLayer/TilePainter", "src/map/view/world/layers/tileLayer/TileReplacement", "src/map/view/world/layers/tileLayer/TileResponse", "src/map/view/world/objects/InvisibleObject", "src/map/view/world/objects/WorldCamera", "src/map/view/world/objects/WorldObject"], function (require, exports, PortalMap_1, RelutionMap_4, RelutionEventSystem_1, LocalizationDe_1, LocalizationEn_3, Model_11, RelutionMapModel_6, RelutionMapModelLoader_1, RelutionMapObjectModel_5, DeviceModel_5, DeviceTagModel_3, FloorModel_2, FloorModelLoader_1, GeofenceModel_4, GeofenceStateModel_2, PositionEstimateModel_1, HeatmapDeviceModel_2, HeatmapModel_2, DeviceEditMode_2, DeviceTaggingMode_2, GeofenceEditMode_2, RelutionMapMode_6, SingleDeviceEditMode_2, TapeMeasureEditMode_2, IntersectionUtils_2, KeyUtils_2, MouseUtils_3, ReflectionUtils_1, RssiToDistance_3, SerialNumberUtils_1, UuidUtils_2, RelutionMapHud_2, Bar_3, BarLayer_2, Action_3, ActionBar_1, ToggleAction_2, BeaconBar_2, BeaconItem_2, HelpLayer_2, PopupLayer_5, RelutionMapObjectPopupLayer_2, SelectionLayer_2, TapeMeasureHudLayer_2, Building_2, Floor_3, RelutionMapAttributeObject_8, RelutionMapAttributeObjectLayer_7, RelutionMapObject_11, RelutionMapObjectLayer_5, RelutionMapWorld_2, BeaconConnection_2, BeaconConnectionsLayer_2, BeaconConnectionDetails_2, BeaconConnectionDetailsLayer_2, BeaconRange_2, BeaconRangeLayer_2, DeviceAccuracyRange_2, DeviceAccuracyRangeLayer_2, Asset_6, Beacon_10, Device_5, DeviceLayer_3, MeshGateway_3, DeviceTag_3, DeviceTaggingLayer_2, DeviceTrack_2, DeviceTrackLayer_2, SingleDeviceEditLayer_2, UserCountHeatmapLayer_2, FloorplanRelatedLayer_13, TextureUpdateLayer_1, TileBasedBenchmarkLayer_1, AbstractFloorplanLayer_3, FloorplanLayer_2, ImageBasedFloorplanLayer_2, TileBasedFloorplanLayer_2, FloorplanOverlayLayer_2, WallplanLayer_2, Geofence_5, GeofenceLayer_2, CircleGeofence_2, PolygonGeofence_2, RectangleGeofence_2, RelutionMapObjectInfo_2, RelutionMapObjectInfoLayer_2, TapeMeasureWorldLayer_2, AutonomousObjectModelBinder_2, CoupledObjectModelBinder_2, RelutionMapObjectModelBinder_3, ViewModelBinder_2, SimulatorMap_1, BeaconConnectionDetailsPopupLayer_2, WorldMap_1, Game_2, Animation_12, BackInterpolator_1, BounceInterpolator_1, CubicInterpolator_1, EaseIn_2, EaseOut_4, LinearInterpolator_12, QuatricInterpolator_1, SquareInterpolator_1, AABB_11, OBB_4, GestureRecognizer_8, InputEvent_3, InputSystem_2, MacKeyDetector_2, Localization_4, UnresolvedLocalization_2, Vector2_12, DecoratingObject_7, RenderingEnvironment_2, SpriteInverseMaskFilter_3, TextureMatrix_2, DisplayObject_4, DisplayObjectContainer_20, GraphicsObject_19, HighResTextObject_6, SpriteObject_19, TextObject_6, TextStyle_2, HighResText_6, BaseTexture_8, Texture_18, ObservablePoint_2, Point_6, Camera_3, GameObject_6, Scene_2, SceneObject_16, SceneObjectListIterator_2, UnsupportedOperationException_1, FruityMap_3, ArrayUtils_1, DateUtils_3, DeviceUtils_25, GraphicsUtils_3, Language_3, Logger_10, MathUtils_2, Prando_2, Simplify_1, StringUtils_2, SystemUtils_3, Layer_20, Hud_2, Compass_2, ControlLayer_3, PanObject_2, ZoomObject_2, NavigationLayer_3, ArrowObject_3, ButtonObject_4, ScrollableContentObject_2, ScrollableObject_2, World_2, HeatmapLayer_1, HeatmapLayerImpl_3, CanvasHeatmap_3, CanvasHeatmapLayer_2, Framebuffer_2, Heights_2, Node_2, Shader_6, TextureObject_3, WebGlHeatmap_2, WebGlHeatmapLayer_2, BlurShader_2, ClampShader_2, HeatmapShader_2, HeightsShader_2, MultiplyShader_2, LocalTileLoader_2, RemoteTileLoader_2, RemoteTileResponse_2, Tile_2, TileEngine_3, TileLayer_3, TileLoader_3, TileObject_2, TilePainter_2, TileReplacement_2, TileResponse_3, InvisibleObject_1, WorldCamera_5, WorldObject_2) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(PortalMap_1);
    __export(RelutionMap_4);
    __export(RelutionEventSystem_1);
    __export(LocalizationDe_1);
    __export(LocalizationEn_3);
    __export(Model_11);
    __export(RelutionMapModel_6);
    __export(RelutionMapModelLoader_1);
    __export(RelutionMapObjectModel_5);
    __export(DeviceModel_5);
    __export(DeviceTagModel_3);
    __export(FloorModel_2);
    __export(FloorModelLoader_1);
    __export(GeofenceModel_4);
    __export(GeofenceStateModel_2);
    __export(PositionEstimateModel_1);
    __export(HeatmapDeviceModel_2);
    __export(HeatmapModel_2);
    __export(DeviceEditMode_2);
    __export(DeviceTaggingMode_2);
    __export(GeofenceEditMode_2);
    __export(RelutionMapMode_6);
    __export(SingleDeviceEditMode_2);
    __export(TapeMeasureEditMode_2);
    __export(IntersectionUtils_2);
    __export(KeyUtils_2);
    __export(MouseUtils_3);
    __export(ReflectionUtils_1);
    __export(RssiToDistance_3);
    __export(SerialNumberUtils_1);
    __export(UuidUtils_2);
    __export(RelutionMapHud_2);
    __export(Bar_3);
    __export(BarLayer_2);
    __export(Action_3);
    __export(ActionBar_1);
    __export(ToggleAction_2);
    __export(BeaconBar_2);
    __export(BeaconItem_2);
    __export(HelpLayer_2);
    __export(PopupLayer_5);
    __export(RelutionMapObjectPopupLayer_2);
    __export(SelectionLayer_2);
    __export(TapeMeasureHudLayer_2);
    __export(Building_2);
    __export(Floor_3);
    __export(RelutionMapAttributeObject_8);
    __export(RelutionMapAttributeObjectLayer_7);
    __export(RelutionMapObject_11);
    __export(RelutionMapObjectLayer_5);
    __export(RelutionMapWorld_2);
    __export(BeaconConnection_2);
    __export(BeaconConnectionsLayer_2);
    __export(BeaconConnectionDetails_2);
    __export(BeaconConnectionDetailsLayer_2);
    __export(BeaconRange_2);
    __export(BeaconRangeLayer_2);
    __export(DeviceAccuracyRange_2);
    __export(DeviceAccuracyRangeLayer_2);
    __export(Asset_6);
    __export(Beacon_10);
    __export(Device_5);
    __export(DeviceLayer_3);
    __export(MeshGateway_3);
    __export(DeviceTag_3);
    __export(DeviceTaggingLayer_2);
    __export(DeviceTrack_2);
    __export(DeviceTrackLayer_2);
    __export(SingleDeviceEditLayer_2);
    __export(UserCountHeatmapLayer_2);
    __export(FloorplanRelatedLayer_13);
    __export(TextureUpdateLayer_1);
    __export(TileBasedBenchmarkLayer_1);
    __export(AbstractFloorplanLayer_3);
    __export(FloorplanLayer_2);
    __export(ImageBasedFloorplanLayer_2);
    __export(TileBasedFloorplanLayer_2);
    __export(FloorplanOverlayLayer_2);
    __export(WallplanLayer_2);
    __export(Geofence_5);
    __export(GeofenceLayer_2);
    __export(CircleGeofence_2);
    __export(PolygonGeofence_2);
    __export(RectangleGeofence_2);
    __export(RelutionMapObjectInfo_2);
    __export(RelutionMapObjectInfoLayer_2);
    __export(TapeMeasureWorldLayer_2);
    __export(AutonomousObjectModelBinder_2);
    __export(CoupledObjectModelBinder_2);
    __export(RelutionMapObjectModelBinder_3);
    __export(ViewModelBinder_2);
    __export(SimulatorMap_1);
    __export(BeaconConnectionDetailsPopupLayer_2);
    __export(WorldMap_1);
    __export(Game_2);
    __export(Animation_12);
    __export(BackInterpolator_1);
    __export(BounceInterpolator_1);
    __export(CubicInterpolator_1);
    __export(EaseIn_2);
    __export(EaseOut_4);
    __export(LinearInterpolator_12);
    __export(QuatricInterpolator_1);
    __export(SquareInterpolator_1);
    __export(AABB_11);
    __export(OBB_4);
    __export(GestureRecognizer_8);
    __export(InputEvent_3);
    __export(InputSystem_2);
    __export(MacKeyDetector_2);
    __export(Localization_4);
    __export(UnresolvedLocalization_2);
    __export(Vector2_12);
    __export(DecoratingObject_7);
    __export(RenderingEnvironment_2);
    __export(SpriteInverseMaskFilter_3);
    __export(TextureMatrix_2);
    __export(DisplayObject_4);
    __export(DisplayObjectContainer_20);
    __export(GraphicsObject_19);
    __export(HighResTextObject_6);
    __export(SpriteObject_19);
    __export(TextObject_6);
    __export(TextStyle_2);
    __export(HighResText_6);
    __export(BaseTexture_8);
    __export(Texture_18);
    __export(ObservablePoint_2);
    __export(Point_6);
    __export(Camera_3);
    __export(GameObject_6);
    __export(Scene_2);
    __export(SceneObject_16);
    __export(SceneObjectListIterator_2);
    __export(UnsupportedOperationException_1);
    __export(FruityMap_3);
    __export(ArrayUtils_1);
    __export(DateUtils_3);
    __export(DeviceUtils_25);
    __export(GraphicsUtils_3);
    __export(Language_3);
    __export(Logger_10);
    __export(MathUtils_2);
    __export(Prando_2);
    __export(Simplify_1);
    __export(StringUtils_2);
    __export(SystemUtils_3);
    __export(Layer_20);
    __export(Hud_2);
    __export(Compass_2);
    __export(ControlLayer_3);
    __export(PanObject_2);
    __export(ZoomObject_2);
    __export(NavigationLayer_3);
    __export(ArrowObject_3);
    __export(ButtonObject_4);
    __export(ScrollableContentObject_2);
    __export(ScrollableObject_2);
    __export(World_2);
    __export(HeatmapLayer_1);
    __export(HeatmapLayerImpl_3);
    __export(CanvasHeatmap_3);
    __export(CanvasHeatmapLayer_2);
    __export(Framebuffer_2);
    __export(Heights_2);
    __export(Node_2);
    __export(Shader_6);
    __export(TextureObject_3);
    __export(WebGlHeatmap_2);
    __export(WebGlHeatmapLayer_2);
    __export(BlurShader_2);
    __export(ClampShader_2);
    __export(HeatmapShader_2);
    __export(HeightsShader_2);
    __export(MultiplyShader_2);
    __export(LocalTileLoader_2);
    __export(RemoteTileLoader_2);
    __export(RemoteTileResponse_2);
    __export(Tile_2);
    __export(TileEngine_3);
    __export(TileLayer_3);
    __export(TileLoader_3);
    __export(TileObject_2);
    __export(TilePainter_2);
    __export(TileReplacement_2);
    __export(TileResponse_3);
    __export(InvisibleObject_1);
    __export(WorldCamera_5);
    __export(WorldObject_2);
});
define("test/utils/HttpUtils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class HttpUtils {
        static getJson(path, success, failure) {
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        if (success) {
                            success(JSON.parse(xhr.responseText));
                        }
                    }
                    else {
                        if (failure) {
                            document.body.innerHTML = xhr.responseText;
                        }
                    }
                }
            };
            xhr.open("GET", path, true);
            xhr.send();
        }
        static postJson(path, jsonObject, successCallback, failure) {
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        if (successCallback) {
                            successCallback(JSON.parse(xhr.responseText));
                        }
                    }
                    else {
                        if (failure) {
                            document.body.innerHTML = xhr.responseText;
                        }
                    }
                }
            };
            xhr.open("POST", path, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.send(JSON.stringify(jsonObject));
        }
        static getGetParameter(parameterName) {
            let result = null;
            let tmp = [];
            location.search
                .substr(1)
                .split("&")
                .forEach(function (item) {
                tmp = item.split("=");
                if (tmp[0] === parameterName) {
                    result = decodeURIComponent(tmp[1]);
                }
            });
            return result;
        }
    }
    exports.HttpUtils = HttpUtils;
});
define("test/tests/relution/helper/testPortalMap", ["require", "exports", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/map/utils/Logger", "src/app/relution/view/world/RelutionMapWorld", "src/app/relution/RelutionMap", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, LocalizationEn_4, PortalMap_2, HttpUtils_1, DeviceModel_6, FloorModelLoader_2, Logger_11, RelutionMapWorld_3, RelutionMap_5, RelutionMapModelLoader_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalMap(config, testFunction) {
        let testDataPath = "../../maps/" + config.mapName + "/";
        let testCasePath = testDataPath + "data/" + config.testCaseName + "/";
        let floorplanUrl = testDataPath + "img/floorplan.png";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions(config);
        let map = new PortalMap_2.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadMap(map, floor, config, testCasePath, (fruityMap) => {
                if (config.shouldLoadDevices) {
                    loadDevices(fruityMap, testCasePath, (deviceModels) => {
                        testFunction(fruityMap, deviceModels, testCasePath);
                    });
                }
                else {
                    testFunction(fruityMap, null, testCasePath);
                }
            });
        });
    }
    exports.default = testPortalMap;
    function initMapOptions(config) {
        let options = new RelutionMap_5.RelutionMap.Options();
        options.world = config.relutionMapWorld;
        // General
        options.localization = new LocalizationEn_4.LocalizationEn();
        options.parentHtmlElement = document.body;
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.pathToImages = "../../../img/png/";
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_1.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_2.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadMap(map, floor, config, testCasePath, callback) {
        map.load(floor, function () {
            window.fruityMap = map;
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                map.setSize(newWidth, newHeight);
            });
            window.addEventListener("beforeunload", function (e) {
                map.destroy();
            });
            callback(map);
        });
        map.addObserver(new TestObserver());
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_1.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_2.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_6.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    class PortalMapTestConfig {
        constructor() {
            this.mapName = "mway";
            this.testCaseName = "default";
            this.shouldLoadDevices = true;
            this.relutionMapWorld = new RelutionMapWorld_3.RelutionMapWorld.Config();
        }
    }
    exports.PortalMapTestConfig = PortalMapTestConfig;
    class TestObserver {
        // @Override
        onObjectMovedToMap(beacon) {
            Logger_11.Logger.logDebug("On Beacon moved to map");
        }
        // @Override
        onObjectMovedToStock(beacon) {
            Logger_11.Logger.logDebug("On Beacon moved to stock");
        }
        // @Override
        onObjectSelected(object) {
            Logger_11.Logger.logDebug("On object selected");
        }
        // @Override
        onObjectUnselected(object) {
            Logger_11.Logger.logDebug("On object unselected");
        }
        // @Override
        onObjectDoubleClicked(object) {
            Logger_11.Logger.logDebug("On object double clicked");
        }
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            let visibleString = "";
            if (visible) {
                visibleString = "visible";
            }
            else {
                visibleString = "invisible";
            }
            Logger_11.Logger.logDebug("Layer " + layerName + " has become " + visibleString);
        }
    }
    exports.TestObserver = TestObserver;
});
define("test/tests/heatmap/helper/MouseHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "src/engine/input/GestureRecognizer"], function (require, exports, FloorplanRelatedLayer_14, HeatmapLayer_2, GestureRecognizer_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MouseHeatmapLayer extends FloorplanRelatedLayer_14.FloorplanRelatedLayer {
        // Construction
        constructor(building, floor) {
            super(building.getEnvironment(), floor.getFloorplanLayer());
            this.floor = floor;
            this.building = building;
            this.initHeatmap();
        }
        initHeatmap() {
            this.heatmap = new HeatmapLayer_2.HeatmapLayer(this.building.getEnvironment(), this.getFloorplanLayer());
            this.addChild(this.heatmap);
        }
        // Mouse interaction
        // @Override
        onMouseMove(x, y) {
            super.onMouseMove(x, y);
            if (this.floor === this.building.getCurrentFloor()) {
                if (GestureRecognizer_9.GestureRecognizer.isShiftPressed()) {
                    let mouseInRelative = this.getFloorplanLayer().getRelativeWorldCoordsFromScreenPixels(new PIXI.Point(x, y));
                    let floorWidthInTx = this.getFloorplanLayer().getFloorSize().x;
                    let floorHeightInTx = this.getFloorplanLayer().getFloorSize().y;
                    let floorWidthInCm = this.getFloorplanLayer().getCmFromTexels(floorWidthInTx);
                    let floorHeightInCm = floorWidthInCm * (floorHeightInTx / floorWidthInTx);
                    let mouseInCm = new PIXI.Point(mouseInRelative.x * floorWidthInCm, mouseInRelative.y * floorHeightInCm);
                    let radiusInCm = 150;
                    this.heatmap.addPoint(mouseInCm.x, mouseInCm.y, radiusInCm, 0.2);
                    this.heatmap.clamp(0, 1);
                    this.heatmap.multiply(0.999);
                }
            }
            return false;
        }
        // @Override
        onTap(x, y, numTaps) {
            super.onTap(x, y, numTaps);
            if (this.floor === this.building.getCurrentFloor()) {
                if (GestureRecognizer_9.GestureRecognizer.isShiftPressed()) {
                    this.heatmap.clear();
                }
            }
            return false;
        }
    }
    exports.MouseHeatmapLayer = MouseHeatmapLayer;
});
define("test/tests/heatmap/testPortalHeatmap", ["require", "exports", "test/tests/relution/helper/testPortalMap", "test/tests/heatmap/helper/MouseHeatmapLayer"], function (require, exports, testPortalMap_1, MouseHeatmapLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalHeatmap() {
        let config = new testPortalMap_1.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        testPortalMap_1.default(config, runTest);
    }
    exports.default = testPortalHeatmap;
    function runTest(fruityMap, deviceModels, testCasePath) {
        const floor = fruityMap.getBuilding().getCurrentFloor();
        let heatmapLayer = new MouseHeatmapLayer_1.MouseHeatmapLayer(fruityMap.getBuilding(), floor);
        floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
    }
});
define("test/tests/heatmap/helper/RandomHeatmapLayer", ["require", "exports", "src/app/relution/view/world/layers/floorplanLayers/FloorplanRelatedLayer", "src/map/view/world/layers/heatmapLayer/HeatmapLayer"], function (require, exports, FloorplanRelatedLayer_15, HeatmapLayer_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RandomHeatmapLayer extends FloorplanRelatedLayer_15.FloorplanRelatedLayer {
        // Construction
        constructor(config, building, floor) {
            super(building.getEnvironment(), floor.getFloorplanLayer());
            // Configuration
            this.config = new RandomHeatmapLayer.Config();
            this.config = config;
            this.initModel();
            this.initView(building, floor);
        }
        initModel() {
            this.particles = new Array();
            const numParticles = 1000;
            for (let i = 0; i < numParticles; i++) {
                this.particles.push(new PIXI.Point(Math.random(), Math.random()));
            }
        }
        initView(building, floor) {
            this.floor = floor;
            this.building = building;
            this.initHeatmap();
        }
        initHeatmap() {
            this.heatmap = new HeatmapLayer_3.HeatmapLayer(this.building.getEnvironment(), this.getFloorplanLayer(), this.config.heatmapLayer);
            this.addChild(this.heatmap);
        }
        // Update
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            this.drawRandomHeatpoints();
        }
        drawRandomHeatpoints() {
            if (this.config.testCompleteRedraw) {
                this.heatmap.clear();
            }
            for (let i = 0; i < this.particles.length; i++) {
                this.moveParticleRandomly(i);
                this.drawParticle(i);
            }
        }
        moveParticleRandomly(index) {
            const oldX = this.particles[index].x;
            const oldY = this.particles[index].y;
            const maxShiftPerUpdateInCm = 40;
            this.particles[index].x = oldX + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / this.getFloorplanLayer().getFloorSize().x);
            this.particles[index].y = oldY + (((Math.random() - 0.5) * maxShiftPerUpdateInCm) / this.getFloorplanLayer().getFloorSize().y);
            this.particles[index].x = Math.max(Math.min(this.particles[index].x, 1.0), 0.0);
            this.particles[index].y = Math.max(Math.min(this.particles[index].y, 1.0), 0.0);
        }
        drawParticle(index) {
            const radiusInCm = this.config.testCompleteRedraw ? 120 : 80;
            let particle = this.particles[index];
            let mouseInRelative = new PIXI.Point(particle.x, particle.y);
            let floorWidthInTx = this.getFloorplanLayer().getFloorSize().x;
            let floorHeightInTx = this.getFloorplanLayer().getFloorSize().y;
            let floorWidthInCm = this.getFloorplanLayer().getCmFromTexels(floorWidthInTx);
            let floorHeightInCm = floorWidthInCm * (floorHeightInTx / floorWidthInTx);
            let mouseInCm = new PIXI.Point(mouseInRelative.x * floorWidthInCm, mouseInRelative.y * floorHeightInCm);
            const intensity = this.config.testCompleteRedraw ? 0.3 : 0.125;
            this.heatmap.addPoint(mouseInCm.x, mouseInCm.y, radiusInCm, intensity);
            this.heatmap.clamp(0, 1);
            this.heatmap.multiply(0.995);
        }
    }
    exports.RandomHeatmapLayer = RandomHeatmapLayer;
    (function (RandomHeatmapLayer) {
        class Config {
            constructor() {
                /**
                 * True, if the all heatpoints should be redrawn in each frame.
                 *
                 * Default: false
                 */
                this.testCompleteRedraw = false;
                /**
                 * The configuration of the heatmap layer
                 */
                this.heatmapLayer = new HeatmapLayer_3.HeatmapLayer.Config();
            }
        }
        RandomHeatmapLayer.Config = Config;
    })(RandomHeatmapLayer = exports.RandomHeatmapLayer || (exports.RandomHeatmapLayer = {}));
});
define("test/tests/heatmap/helper/testPortalHeatmapScalability", ["require", "exports", "test/tests/relution/helper/testPortalMap", "test/tests/heatmap/helper/RandomHeatmapLayer"], function (require, exports, testPortalMap_2, RandomHeatmapLayer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalHeatmapScalability(config) {
        let mapConfig = new testPortalMap_2.PortalMapTestConfig();
        mapConfig.mapName = "mway";
        mapConfig.testCaseName = "default";
        mapConfig.shouldLoadDevices = false;
        testPortalMap_2.default(mapConfig, (fruityMap, deviceModels, testCasePath) => {
            const floor = fruityMap.getBuilding().getCurrentFloor();
            let heatmapLayer = new RandomHeatmapLayer_1.RandomHeatmapLayer(config, fruityMap.getBuilding(), floor);
            floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
        });
    }
    exports.default = testPortalHeatmapScalability;
});
define("test/tests/heatmap/testPortalHeatmapIncrementalScalability", ["require", "exports", "test/tests/heatmap/helper/RandomHeatmapLayer", "test/tests/heatmap/helper/testPortalHeatmapScalability"], function (require, exports, RandomHeatmapLayer_2, testPortalHeatmapScalability_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalHeatmapIncrementalScalability() {
        const config = new RandomHeatmapLayer_2.RandomHeatmapLayer.Config();
        config.testCompleteRedraw = false;
        testPortalHeatmapScalability_1.default(config);
    }
    exports.default = testPortalHeatmapIncrementalScalability;
});
define("test/tests/heatmap/testPortalHeatmapTotalRedrawScalability", ["require", "exports", "test/tests/heatmap/helper/RandomHeatmapLayer", "test/tests/heatmap/helper/testPortalHeatmapScalability"], function (require, exports, RandomHeatmapLayer_3, testPortalHeatmapScalability_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalHeatmapTotalRedrawScalability() {
        const config = new RandomHeatmapLayer_3.RandomHeatmapLayer.Config();
        config.testCompleteRedraw = true;
        testPortalHeatmapScalability_2.default(config);
    }
    exports.default = testPortalHeatmapTotalRedrawScalability;
});
define("test/tests/relution/helper/testMultiFloorPortalMap", ["require", "exports", "src/app/portal/PortalMap", "src/app/relution/locale/LocalizationEn", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/RelutionMap", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, PortalMap_3, LocalizationEn_5, HttpUtils_2, DeviceModel_7, FloorModelLoader_3, RelutionMap_6, RelutionMapModelLoader_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testMultiFloorPortalMap(buildingName, floorNames, testCaseName, useSvg, runTest) {
        let options = initMapOptions();
        let map = new PortalMap_3.PortalMap(options);
        initMap(map, buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testMultiFloorPortalMap;
    function initMapOptions() {
        let options = new RelutionMap_6.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.localization = new LocalizationEn_5.LocalizationEn();
        return options;
    }
    function initMap(map, buildingName, floorNames, testCaseName, useSvg, runTest) {
        // 3. Add floors to map
        let floors = new Array();
        let callback = function (floor) {
            floors.push(floor);
            if (floors.length === floorNames.length) {
                loadFruityMap(map, floors[0], (fruityMap) => {
                    addFloorsToMap(floors, fruityMap, buildingName, testCaseName, runTest);
                });
            }
        };
        // 2. Load floor textures
        let modelLoadedFloors = new Array();
        let floorModelCallback = function (floor) {
            modelLoadedFloors.push(floor);
            if (modelLoadedFloors.length == floorNames.length) {
                for (let i = 0; i < modelLoadedFloors.length; i++) {
                    let currentFloor = modelLoadedFloors[i];
                    currentFloor.load(callback);
                }
            }
        };
        // 1. Load floor models
        for (let i = 0; i < floorNames.length; i++) {
            let floorName = floorNames[i];
            let testDataPath = getTestDataPath(buildingName, floorName);
            let testCasePath = getTestCasePath(buildingName, floorName, testCaseName);
            let floorplanFile = "floorplan.png";
            if (useSvg === true) {
                floorplanFile = "floorplan.svg";
            }
            let floorplanUrl = testDataPath + "img/" + floorplanFile;
            let wallplanFile = "wallplan.png";
            let wallplanUrl = testDataPath + "img/" + wallplanFile;
            loadFloorModel(map, floorName, testDataPath + "floor.json", floorplanUrl, wallplanUrl, floorModelCallback);
        }
    }
    function getTestDataPath(buildingName, floorName) {
        let testDataPath = "../../maps/" + buildingName + "/" + floorName + "/";
        return testDataPath;
    }
    function getTestCasePath(buildingName, floorName, testCaseName) {
        let testDataPath = getTestDataPath(buildingName, floorName);
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        return testCasePath;
    }
    function loadFloorModel(map, floorName, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_2.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_3.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor(floorName, floorModel);
            callback(floor);
        });
    }
    function loadFruityMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
    function addFloorsToMap(floors, fruityMap, buildingName, testCaseName, runTest) {
        for (let i = 0; i < floors.length; i++) {
            let currentFloor = floors[i];
            let currentFloorName = currentFloor.getFloorName();
            fruityMap.getBuilding().addFloor(currentFloor);
            let testCasePath = getTestCasePath(buildingName, currentFloorName, testCaseName);
            loadDevices(fruityMap, currentFloor, testCasePath, (deviceModels) => {
                runTest(fruityMap, currentFloor, deviceModels, testCasePath);
            });
        }
    }
    function loadDevices(fruityMap, floor, testCasePath, callback) {
        HttpUtils_2.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_3.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_7.DeviceModel, false);
            floor.loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
});
define("test/tests/heatmap/testPortalMultiFloorHeatmap", ["require", "exports", "test/tests/relution/helper/testMultiFloorPortalMap", "src/engine/scene/Camera", "src/engine/animation/LinearInterpolator", "src/engine/animation/EaseIn", "src/engine/animation/EaseOut", "test/tests/heatmap/helper/MouseHeatmapLayer"], function (require, exports, testMultiFloorPortalMap_1, Camera_4, LinearInterpolator_13, EaseIn_3, EaseOut_5, MouseHeatmapLayer_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalMultiFloorHeatmap() {
        // Configuration
        let buildingName = "svg_map";
        let floorNames = ["001", "002"];
        let testCaseName = "default";
        let useSvg = true;
        testMultiFloorPortalMap_1.default(buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testPortalMultiFloorHeatmap;
    function runTest(fruityMap, floor, deviceModels, testCasePath) {
        // Add heatmap layer
        let heatmapLayer = new MouseHeatmapLayer_2.MouseHeatmapLayer(fruityMap.getBuilding(), floor);
        floor.getDeviceLayerContainer().addLayerAtIndex(heatmapLayer, 0);
        floor.getFloorplanLayer().setIsInBackground(false);
        floor.getFloorplanLayer().setVisible(true);
        // Zoom to building
        let camera = fruityMap.getBuilding().getScene().getCamera();
        let floorSize = floor.getFloorplanLayer().getFloorSize();
        let topLeft = new PIXI.Point(floorSize.x * 0.25, floorSize.y * 0.33);
        let topRight = new PIXI.Point(floorSize.x * 0.75, floorSize.y * 0.33);
        let bottomLeft = new PIXI.Point(floorSize.x * 0.25, floorSize.y * 0.66);
        let bottomRight = new PIXI.Point(floorSize.x * 0.75, floorSize.y * 0.66);
        let frustum = new Camera_4.Camera.Frustum(topLeft, topRight, bottomLeft, bottomRight);
        camera.startAnimation(new EaseIn_3.EaseIn(new EaseOut_5.EaseOut(new LinearInterpolator_13.LinearInterpolator())), frustum.getObb(), 2000, 1500);
    }
});
define("test/tests/indoor/service/simulation/SimulationServiceConfig", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class ApplicationConfig {
        constructor() {
            /**
             * Specifies the type of application.
             *
             * Possible values: ["monitoring", "simulation"].
             */
            this.type = SimulationServiceConfig.TYPE_NAME;
        }
    }
    exports.ApplicationConfig = ApplicationConfig;
    class SimulationServiceConfig extends ApplicationConfig {
        constructor() {
            super(...arguments);
            /**
             * The type specific simulation config.
             */
            this.simulation = new AssetTrackingSimulationConfig();
        }
    }
    SimulationServiceConfig.TYPE_NAME = "simulation";
    exports.SimulationServiceConfig = SimulationServiceConfig;
    class SimulationConfig {
        constructor() {
            /**
             * Specifies the type of simulation.
             *
             * Possible values: ["positioning", "objecttracking", "beacontracking", "assettracking"]
             */
            this.type = AssetTrackingSimulationConfig.TYPE_NAME;
            /**
             * The name dataset to be simulated
             */
            this.dataset = "longevity_bbbql_2018_06_07_000_reference_ruuvi_long_halts";
            /**
             * True, if the scalar field p(m | x) should be rendered on top of the floor.
             */
            this.renderProbabilityDensityMap = false;
            /**
             * True, if the radio map should be rendered on top of the floor, if a specific beacon is hovered.
             */
            this.renderRadioMap = true;
            /**
             * If true, the validation dataset itself will be used for calibration.
             * If false, the training dataset will be used for calibration.
             */
            this.useValidationDatasetForCalibration = true;
        }
    }
    exports.SimulationConfig = SimulationConfig;
    class PositioningSimulationConfig extends SimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = PositioningSimulationConfig.TYPE_NAME;
        }
    }
    PositioningSimulationConfig.TYPE_NAME = "positioning";
    exports.PositioningSimulationConfig = PositioningSimulationConfig;
    /**
     * Base class for all simulations that make usage of time correlations between
     * measurements (tracking).
     */
    class TrackingSimulationConfig extends SimulationConfig {
        constructor() {
            super(...arguments);
            /**
             * The serial number of the device to be simulated.
             */
            this.deviceSerial = "ABCK4";
            /**
             * True, if the dataset should be simulated with max speed.
             */
            this.simulateWithMaxSpeed = true;
            /**
             * The simulation speed factor (time expansion factor).
             *
             * Default: 1.0
             */
            this.simulationSpeed = 1.0;
        }
    }
    exports.TrackingSimulationConfig = TrackingSimulationConfig;
    class ObjectTrackingSimulationConfig extends TrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = ObjectTrackingSimulationConfig.TYPE_NAME;
        }
    }
    ObjectTrackingSimulationConfig.TYPE_NAME = "objecttracking";
    exports.ObjectTrackingSimulationConfig = ObjectTrackingSimulationConfig;
    /**
     * Base class for all simulations that simulate the complete tracking pipeline.
     */
    class IntegrationTrackingSimulationConfig extends TrackingSimulationConfig {
    }
    exports.IntegrationTrackingSimulationConfig = IntegrationTrackingSimulationConfig;
    class BeaconTrackingSimulationConfig extends IntegrationTrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            this.type = BeaconTrackingSimulationConfig.TYPE_NAME;
        }
    }
    BeaconTrackingSimulationConfig.TYPE_NAME = "beacontracking";
    exports.BeaconTrackingSimulationConfig = BeaconTrackingSimulationConfig;
    class AssetTrackingSimulationConfig extends IntegrationTrackingSimulationConfig {
        // Construction
        constructor() {
            super();
            /**
             * The mode specific config.
             */
            this.mode = new AssetTrackingDatasetSimulationModeConfig();
            this.type = AssetTrackingSimulationConfig.TYPE_NAME;
        }
    }
    // Constants
    AssetTrackingSimulationConfig.TYPE_NAME = "assettracking";
    exports.AssetTrackingSimulationConfig = AssetTrackingSimulationConfig;
    class AssetTrackingSimulationModeConfig {
        constructor() {
            /**
             * Specifies the mode for asset tracking simulation.
             *
             * Possible values: ["assetMouseSimulation", "assetDatasetSimulation", "beaconDatasetSimulation"]
             */
            this.type = AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
        }
    }
    exports.AssetTrackingSimulationModeConfig = AssetTrackingSimulationModeConfig;
    class AssetTrackingMouseSimulationModeConfig extends AssetTrackingSimulationModeConfig {
        // Construction
        constructor() {
            super();
            this.simulateSpeed = true;
            this.simulateDirection = false;
            this.type = AssetTrackingMouseSimulationModeConfig.TYPE_NAME;
        }
    }
    AssetTrackingMouseSimulationModeConfig.TYPE_NAME = "assetMouseSimulation";
    exports.AssetTrackingMouseSimulationModeConfig = AssetTrackingMouseSimulationModeConfig;
    class AssetTrackingDatasetSimulationModeConfig extends AssetTrackingSimulationModeConfig {
        // Construction
        constructor() {
            super();
            this.type = AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
        }
    }
    AssetTrackingDatasetSimulationModeConfig.TYPE_NAME = "assetDatasetSimulation";
    exports.AssetTrackingDatasetSimulationModeConfig = AssetTrackingDatasetSimulationModeConfig;
});
define("test/tests/indoor/service/IndoorApplicationService", ["require", "exports", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, SimulationServiceConfig_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorApplicationService {
        // Service initilization
        init(config, finishedCallback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Configuration management
        updateConfig(configuration) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Floor management
        loadFloor(siteName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Device management
        loadDevices(siteName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
        // Geofence management
        loadGeofences(floorName, callback) {
            throw new IndoorApplicationService.NotImplementedException();
        }
    }
    exports.IndoorApplicationService = IndoorApplicationService;
    (function (IndoorApplicationService) {
        class Config {
            constructor() {
                /**
                 * The type specific simulation config.
                 */
                this.application = new SimulationServiceConfig_1.SimulationServiceConfig();
            }
        }
        IndoorApplicationService.Config = Config;
        class NotImplementedException extends Error {
        }
        IndoorApplicationService.NotImplementedException = NotImplementedException;
    })(IndoorApplicationService = exports.IndoorApplicationService || (exports.IndoorApplicationService = {}));
});
define("test/tests/indoor/models/DeviceTrackingStateModel", ["require", "exports", "src/app/relution/model/RelutionMapObjectModel", "src/app/relution/model/Model", "src/app/relution/model/RelutionMapModel"], function (require, exports, RelutionMapObjectModel_6, Model_12, RelutionMapModel_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // tslint:disable-next-line:max-classes-per-file
    class PointMatch extends RelutionMapModel_7.RelutionMapModel {
        // Getters and setters
        set estimatedPosition(estimatedPosition) {
            this._estimatedPosition = estimatedPosition;
            this.notifyObservers("estimatedPosition");
        }
        get estimatedPosition() {
            return this._estimatedPosition;
        }
        set groundTruthPosition(groundTruthPosition) {
            this._groundTruthPosition = groundTruthPosition;
            this.notifyObservers("groundTruthPosition");
        }
        get groundTruthPosition() {
            return this._groundTruthPosition;
        }
    }
    __decorate([
        Model_12.ModelProperty()
    ], PointMatch.prototype, "_estimatedPosition", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], PointMatch.prototype, "_groundTruthPosition", void 0);
    exports.PointMatch = PointMatch;
    // tslint:disable-next-line:max-classes-per-file
    class TrackingInput extends Model_12.Model {
        // Getters and setters
        set measurementDeviceAvailable(measurementDeviceAvailable) {
            this._measurementDeviceAvailable = measurementDeviceAvailable;
            this.notifyObservers("measurementDeviceAvailable");
        }
        get measurementDeviceAvailable() {
            return this._measurementDeviceAvailable;
        }
    }
    __decorate([
        Model_12.ModelProperty()
    ], TrackingInput.prototype, "_measurementDeviceAvailable", void 0);
    exports.TrackingInput = TrackingInput;
    // tslint:disable-next-line:max-classes-per-file
    class TrackingState extends Model_12.Model {
        constructor() {
            // RSSI based position estimation
            super(...arguments);
            this._lastSerialNumbers = new Array();
            this._lastRssis = new Array();
            this._particles = new Array();
            // Region estimation
            this._regionProbability = 1.0;
        }
        // Getters and setters
        set baseEstimation(baseEstimation) {
            this._baseEstimation = baseEstimation;
            this.notifyObservers("baseEstimation");
        }
        get baseEstimation() {
            return this._baseEstimation;
        }
        set lastSerialNumbers(lastSerialNumbers) {
            this._lastSerialNumbers = lastSerialNumbers;
            this.notifyObservers("lastSerialNumbers");
        }
        get lastSerialNumbers() {
            return this._lastSerialNumbers;
        }
        set lastRssis(lastRssis) {
            this._lastRssis = lastRssis;
            this.notifyObservers("lastRssis");
        }
        get lastRssis() {
            return this._lastRssis;
        }
        set speedInCmPerSec(speedInCmPerSec) {
            this._speedInCmPerSec = speedInCmPerSec;
            this.notifyObservers("speedInCmPerSec");
        }
        get speedInCmPerSec() {
            return this._speedInCmPerSec;
        }
        set particleFilterEstimation(particleFilterEstimation) {
            this._particleFilterEstimation = particleFilterEstimation;
            this.notifyObservers("particleFilterEstimation");
        }
        get particleFilterEstimation() {
            return this._particleFilterEstimation;
        }
        set reliable(reliable) {
            this._reliable = reliable;
            this.notifyObservers("reliable");
        }
        get reliable() {
            return this._reliable;
        }
        set particles(particles) {
            this._particles = particles;
            this.notifyObservers("particles");
        }
        get particles() {
            return this._particles;
        }
        set state(state) {
            this._state = state;
            this.notifyObservers("state");
        }
        get state() {
            return this._state;
        }
        set regionProbability(regionProbability) {
            this._regionProbability = regionProbability;
            this.notifyObservers("regionProbability");
        }
        get regionProbability() {
            return this._regionProbability;
        }
    }
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_baseEstimation", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_lastSerialNumbers", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_lastRssis", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_speedInCmPerSec", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_particleFilterEstimation", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_reliable", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_particles", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_state", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingState.prototype, "_regionProbability", void 0);
    exports.TrackingState = TrackingState;
    class TrackingOutput extends Model_12.Model {
        constructor() {
            // Final estimation path
            super(...arguments);
            this._estimationPath = new Array();
            // Ground Truth
            this._groundTruthPath = new Array();
            this._observationPath = new Array();
            // Path matching
            this._pathMatching = new Array();
        }
        // Getters and setters
        set finalEstimation(finalEstimation) {
            this._finalEstimation = finalEstimation;
            this.notifyObservers("finalEstimation");
        }
        get finalEstimation() {
            return this._finalEstimation;
        }
        set estimationPath(estimationPath) {
            this._estimationPath = estimationPath;
            this.notifyObservers("estimationPath");
        }
        get estimationPath() {
            return this._estimationPath;
        }
        set groundTruthPath(groundTruthPath) {
            this._groundTruthPath = groundTruthPath;
            this.notifyObservers("groundTruthPath");
        }
        get groundTruthPath() {
            return this._groundTruthPath;
        }
        set observationPath(observationPath) {
            this._observationPath = observationPath;
            this.notifyObservers("observationPath");
        }
        get observationPath() {
            return this._observationPath;
        }
        set pathMatching(pathMatching) {
            this._pathMatching = pathMatching;
            this.notifyObservers("pathMatching");
        }
        get pathMatching() {
            return this._pathMatching;
        }
    }
    __decorate([
        Model_12.ModelProperty()
    ], TrackingOutput.prototype, "_finalEstimation", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingOutput.prototype, "_estimationPath", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingOutput.prototype, "_groundTruthPath", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], TrackingOutput.prototype, "_observationPath", void 0);
    __decorate([
        Model_12.ModelProperty({ clazz: PointMatch })
    ], TrackingOutput.prototype, "_pathMatching", void 0);
    exports.TrackingOutput = TrackingOutput;
    class QualitativeTrackerState extends Model_12.Model {
        // Getters and setters
        set deviceId(deviceId) {
            this._deviceId = deviceId;
            this.notifyObservers("deviceId");
        }
        get deviceId() {
            return this._deviceId;
        }
        set trackingInput(trackingInput) {
            this._trackingInput = trackingInput;
            this.notifyObservers("trackingInput");
        }
        get trackingInput() {
            return this._trackingInput;
        }
        set trackingState(trackingState) {
            this._trackingState = trackingState;
            this.notifyObservers("trackingInput");
        }
        get trackingState() {
            return this._trackingState;
        }
        set trackingOutput(trackingOutput) {
            this._trackingOutput = trackingOutput;
            this.notifyObservers("trackingOutput");
        }
        get trackingOutput() {
            return this._trackingOutput;
        }
    }
    __decorate([
        Model_12.ModelProperty()
    ], QualitativeTrackerState.prototype, "_deviceId", void 0);
    __decorate([
        Model_12.ModelProperty({ clazz: TrackingInput })
    ], QualitativeTrackerState.prototype, "_trackingInput", void 0);
    __decorate([
        Model_12.ModelProperty({ clazz: TrackingState })
    ], QualitativeTrackerState.prototype, "_trackingState", void 0);
    __decorate([
        Model_12.ModelProperty()
    ], QualitativeTrackerState.prototype, "_trackingOutput", void 0);
    exports.QualitativeTrackerState = QualitativeTrackerState;
    // tslint:disable-next-line:max-classes-per-file
    class DeviceTrackingStateModel extends RelutionMapObjectModel_6.RelutionMapObjectModel {
        constructor() {
            // Device information
            super(...arguments);
            this._state = new QualitativeTrackerState();
        }
        // Getters and setters
        set deviceUuid(deviceUuid) {
            this._deviceUuid = deviceUuid;
            this.notifyObservers("deviceUuid");
        }
        get deviceUuid() {
            return this._deviceUuid;
        }
        set state(state) {
            this._state = state;
            this.notifyObservers("state");
        }
        get state() {
            return this._state;
        }
    }
    __decorate([
        RelutionMapObjectModel_6.ParentModel(),
        Model_12.ModelProperty()
    ], DeviceTrackingStateModel.prototype, "_deviceUuid", void 0);
    __decorate([
        Model_12.ModelProperty({ clazz: QualitativeTrackerState })
    ], DeviceTrackingStateModel.prototype, "_state", void 0);
    exports.DeviceTrackingStateModel = DeviceTrackingStateModel;
});
define("test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetails", ["require", "exports", "src/map/view/hud/objects/ArrowObject", "src/map/utils/DeviceUtils", "src/map/utils/ArrayUtils", "src/map/view/world/objects/InvisibleObject", "src/map/utils/Prando", "src/map/utils/MathUtils", "test/tests/indoor/models/DeviceTrackingStateModel", "src/engine/rendering/objects/GraphicsObject", "src/engine/rendering/objects/SpriteObject", "src/engine/rendering/objects/HighResTextObject", "src/engine/rendering/objects/DisplayObjectContainer", "src/engine/rendering/pixi/HighResText", "src/engine/rendering/texture/Texture", "src/engine/rendering/utils/Point", "src/engine/rendering/texture/BaseTexture", "src/app/relution/view/world/RelutionMapObject"], function (require, exports, ArrowObject_4, DeviceUtils_26, ArrayUtils_2, InvisibleObject_2, Prando_3, MathUtils_3, DeviceTrackingStateModel_1, GraphicsObject_20, SpriteObject_20, HighResTextObject_7, DisplayObjectContainer_21, HighResText_7, Texture_19, Point_7, BaseTexture_9, RelutionMapObject_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let DeviceTrackingDetails = class DeviceTrackingDetails extends RelutionMapObject_12.RelutionMapObject {
        // Initialization
        constructor(config, environment, floorplanLayer, model, device, deviceLayer, heatmapLayer, showDetailsOnHover) {
            super(config, environment, floorplanLayer, model, device);
            // Configuration
            this.alwaysShowBaseEstimationErrorView = true;
            this.shouldDrawHeatmap = false;
            // View: RSSI estimator
            this.beaconSerialNumbers = new Array();
            this.beaconRssiArrows = new Array();
            this.beaconRssiArrowsBodyColorReliable = 0x0000ff;
            this.beaconRssiArrowsBodyColorUnreliable = 0xff0000;
            this.beaconRssiTexts = new Array();
            this.baseEstimationViewSizeInPx = 10;
            // View: Particle filter
            // View: Particles
            this.particlePool = new Array();
            this.particleSizeInPx = 10;
            this.meanParticleSizeInPx = 20;
            this.meanIsReliable = false;
            this.finalPositionViewSizeInPx = 10;
            // View: Interaction
            this.showDetailsOnHover = false;
            this.isHovering = false;
            this.lastScaleFactor = 1.0;
            this.invalidated = false;
            this.deviceLayer = deviceLayer;
            this.heatmapLayer = heatmapLayer;
            this.showDetailsOnHover = showDetailsOnHover;
            this.initView();
        }
        initView() {
            this.initRootView();
            this.initStateView();
            this.initRssiViews();
            this.initProbabilityImageSpriteView();
            this.initRadioMapImageSpriteView();
            this.initPathView();
            this.initAccuracyPathView();
            this.initParticlePool();
            this.initParticleContainer();
            this.initMeanParticleView();
            this.initFinalPositionView();
            this.initStandardDeviationView();
            this.initGroundTruthPathView();
            this.initObservationPathView();
            this.initPathMatchingView();
            if (this.showDetailsOnHover) {
                this.rootObject.getView().alpha = 0.0;
            }
            this.invalidated = true;
        }
        initRootView() {
            this.rootObject = new InvisibleObject_2.InvisibleObject(this.getEnvironment());
            this.rootObject.getView().visible = true;
            this.addChild(this.rootObject);
        }
        initStateView() {
            // Drawing
            this.stateView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.stateView.beginFill(0x0000ff);
            this.stateView.drawRect(0, 0, 1, 1);
            this.stateView.endFill();
            // Transformation
            let floorplanLayer = this.getDeviceLayer().getFloorplanLayer();
            this.stateView.width = floorplanLayer.getFloorSize().x;
            this.stateView.height = floorplanLayer.getFloorSize().y;
            // Alpha
            // To enable the state view set alpha to 0.05
            // However the state view in the current version does
            // not work well if multiple devices are tracked.
            // Thus, the state view should only be visible
            // next to the device.
            this.stateView.alpha = 0.00;
            // Add to scene graph
            this.rootObject.getView().addChild(this.stateView);
        }
        initRssiViews() {
            this.removeBeaconNodeIds();
            this.removeBeaconRssiArrows();
            this.removeBeaconRssiTexts();
            this.removeBaseEstimationView();
            this.removeBaseEstimationAccuracyView();
            this.removeBaseEstimationErrorView();
            this.initBeaconNodeIds();
            this.initBeaconRssiArrows();
            this.initBeaconRssiTexts();
            this.initBaseEstimationView();
            this.initBaseEstimationAccuracyView();
            this.initBaseEstimationErrorView();
        }
        removeBeaconNodeIds() {
            this.beaconSerialNumbers = [];
        }
        removeBeaconRssiArrows() {
            for (let i = 0; i < this.beaconRssiArrows.length; i++) {
                let beaconRssiArrow = this.beaconRssiArrows[i];
                this.rootObject.removeChild(beaconRssiArrow);
            }
            this.beaconRssiArrows = [];
        }
        removeBeaconRssiTexts() {
            for (let i = 0; i < this.beaconRssiTexts.length; i++) {
                let text = this.beaconRssiTexts[i];
                this.rootObject.getView().removeChild(text);
            }
            this.beaconRssiTexts = [];
        }
        removeBaseEstimationView() {
            if (this.baseEstimationView != null) {
                this.rootObject.getView().removeChild(this.baseEstimationView);
            }
            this.baseEstimationView = null;
        }
        removeBaseEstimationAccuracyView() {
            if (this.baseEstimationAccuracyView != null) {
                this.rootObject.getView().removeChild(this.baseEstimationAccuracyView);
            }
            this.baseEstimationAccuracyView = null;
        }
        removeBaseEstimationErrorView() {
            if (this.baseEstimationErrorView != null) {
                if (this.alwaysShowBaseEstimationErrorView) {
                    // We remove this view not from the root view but from the scene object itself,
                    // because it should be visible also when not hovering.
                    this.removeChild(this.baseEstimationErrorView);
                }
                else {
                    this.rootObject.removeChild(this.baseEstimationErrorView);
                }
            }
            this.baseEstimationErrorView = null;
        }
        initBeaconNodeIds() {
            this.beaconSerialNumbers = [];
            let beacons = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                this.beaconSerialNumbers.push(beacon.getModel().deviceId);
            }
        }
        initBeaconRssiArrows() {
            this.beaconRssiArrows = new Array();
            let beacons = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                // Get current beacon
                let beacon = beacons[i];
                // Create arrow
                let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
                arrowObjectConfig.arrowBodyTextureName = "arrow_body";
                arrowObjectConfig.arrowHeadTextureName = "arrow_head";
                arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(12);
                arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
                arrowObjectConfig.bodyColor = this.beaconRssiArrowsBodyColorReliable;
                let arrow = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
                arrow.getView().alpha = 0.0;
                // Add arrow to scene
                this.beaconRssiArrows.push(arrow);
                this.rootObject.addChild(arrow);
            }
        }
        initBeaconRssiTexts() {
            this.beaconRssiTexts = new Array();
            let beacons = this.getDeviceLayer().getAllBeacons();
            for (let i = 0; i < beacons.length; i++) {
                // Get current beacon
                let beacon = beacons[i];
                // Create text
                let fontSize = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(15);
                let rssiText = new HighResTextObject_7.HighResTextObject(new HighResText_7.HighResText(2, "", { fontSize: fontSize }), this.getEnvironment().renderingEnvironment);
                ;
                rssiText.alpha = 0.0;
                // Add text to scene
                this.beaconRssiTexts.push(rssiText);
                this.rootObject.getView().addChild(rssiText);
            }
        }
        initBaseEstimationView() {
            this.baseEstimationView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.baseEstimationView.clear();
            this.baseEstimationView.beginFill(0x0000ff);
            this.baseEstimationView.drawCircle(0, 0, this.baseEstimationViewSizeInPx / 2);
            this.baseEstimationView.endFill();
            this.rootObject.getView().addChild(this.baseEstimationView);
        }
        initBaseEstimationAccuracyView() {
            this.baseEstimationAccuracyView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.baseEstimationAccuracyView.clear();
            this.baseEstimationAccuracyView.alpha = 0.3;
            this.rootObject.getView().addChild(this.baseEstimationAccuracyView);
        }
        initBaseEstimationErrorView() {
            let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = DeviceUtils_26.DeviceUtils.getPhysicalPixelsFromLogical(12);
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.2;
            arrowObjectConfig.bodyColor = 0xff0000;
            this.baseEstimationErrorView = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
            if (this.alwaysShowBaseEstimationErrorView) {
                // We add this view not from the root view but from the scene object itself,
                // because it should be visible also when not hovering.
                this.addChild(this.baseEstimationErrorView);
            }
            else {
                this.rootObject.addChild(this.baseEstimationErrorView);
            }
        }
        initProbabilityImageSpriteView() {
            this.probabilityImageSprite = new SpriteObject_20.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.probabilityImageSprite);
        }
        initRadioMapImageSpriteView() {
            this.radioMapImageSprite = new SpriteObject_20.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.radioMapImageSprite);
        }
        initPathView() {
            this.pathView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.pathView);
        }
        initAccuracyPathView() {
            this.accuracyPathView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.accuracyPathView);
        }
        initParticlePool() {
            this.particlePool = new Array();
        }
        initParticleContainer() {
            this.particleContainer = new DisplayObjectContainer_21.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.particleContainer);
        }
        initMeanParticleView() {
            this.meanParticleView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.drawMeanParticleView();
            // Alpha
            this.meanParticleView.alpha = 0.0;
            // Add to scene graph
            this.rootObject.getView().addChild(this.meanParticleView);
        }
        drawMeanParticleView() {
            let color = null;
            if (this.meanIsReliable) {
                color = 0x008000;
            }
            else {
                color = 0x000080;
            }
            this.meanParticleView.clear();
            this.meanParticleView.beginFill(color);
            this.meanParticleView.drawCircle(0, 0, this.meanParticleSizeInPx / 2);
            this.meanParticleView.endFill();
        }
        initFinalPositionView() {
            this.finalPositionView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.finalPositionView.clear();
            this.finalPositionView.beginFill(0x66ccff);
            this.finalPositionView.drawCircle(0, 0, this.finalPositionViewSizeInPx / 2);
            this.finalPositionView.endFill();
            this.finalPositionView.alpha = 0.0;
            this.rootObject.getView().addChild(this.finalPositionView);
        }
        initStandardDeviationView() {
            this.standardDeviationView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.standardDeviationView.beginFill(0x00ff00);
            this.standardDeviationView.endFill();
            // Alpha
            this.standardDeviationView.alpha = 0;
            // Add to scene graph
            this.rootObject.getView().addChild(this.standardDeviationView);
        }
        initGroundTruthPathView() {
            this.groundTruthPathView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.groundTruthPathView);
        }
        initObservationPathView() {
            this.observationPathView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.observationPathView);
        }
        initPathMatchingView() {
            this.pathMatchingView = new GraphicsObject_20.GraphicsObject(new PIXI.Graphics(), this.getEnvironment().renderingEnvironment);
            this.rootObject.getView().addChild(this.pathMatchingView);
        }
        // Model loading
        // @Override
        onModelUpdated(model) {
            this.updateStateModel();
        }
        updateStateModel() {
            this.updateStateView();
            this.updateBeaconRssiArrowAndTextViews();
            this.updateBaseEstimationView();
            this.updateBaseEstimationAccuracyView();
            this.updateBaseEstimationErrorView();
            this.updatePathViewAndAccuracyPathView();
            this.updateParticlesView();
            this.updateMeanParticleView();
            this.updateFinalPositionView();
            this.updateStandardDeviationView();
            this.updateRegionProbabilityView();
        }
        updateStateView() {
            if (this.getModel().state != null) {
                if (this.getModel().state.trackingState.state === "TRACKING") {
                    this.changeStateToColor(0x00ff00);
                }
                else {
                    this.changeStateToColor(0x0000ff);
                }
            }
        }
        changeStateToColor(color) {
            this.stateView.clear();
            this.stateView.beginFill(color);
            this.stateView.drawRect(0, 0, 1, 1);
            this.stateView.endFill();
        }
        updateBeaconRssiArrowAndTextViews() {
            if (this.getModel().state.trackingState.lastSerialNumbers != null) {
                // Make all arrows visible that correspond with the rssi vector.
                for (let i = 0; i < this.beaconRssiArrows.length; i++) {
                    let arrow = this.beaconRssiArrows[i];
                    let text = this.beaconRssiTexts[i];
                    let serialNumber = this.beaconSerialNumbers[i];
                    let indexOfSerialNumber = this.getModel().state.trackingState.lastSerialNumbers.indexOf(serialNumber);
                    if (indexOfSerialNumber > -1) {
                        arrow.getView().alpha = 1.0;
                        text.alpha = 1.0;
                        text.text = "" + this.getModel().state.trackingState.lastRssis[indexOfSerialNumber];
                    }
                    else {
                        arrow.getView().alpha = 0.0;
                        text.alpha = 0.0;
                    }
                    if (this.getModel().state.trackingInput.measurementDeviceAvailable !== null) {
                        if (this.getModel().state.trackingInput.measurementDeviceAvailable) {
                            arrow.setBodyColor(this.beaconRssiArrowsBodyColorReliable);
                        }
                        else {
                            arrow.setBodyColor(this.beaconRssiArrowsBodyColorUnreliable);
                        }
                    }
                }
            }
        }
        updateBaseEstimationView() {
            if (this.baseEstimationView != null && this.getModel().state.trackingState.baseEstimation != null) {
                let xInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.x);
                let yInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.y);
                this.baseEstimationView.position.x = xInTx;
                this.baseEstimationView.position.y = yInTx;
            }
        }
        updateBaseEstimationAccuracyView() {
            if (this.baseEstimationAccuracyView != null && this.getModel().state.trackingState.baseEstimation != null) {
                // Scale
                let stdXInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.standardDeviationX);
                let stdYInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.standardDeviationY);
                // Position
                let xInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.x);
                let yInTx = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.y);
                // Draw
                this.baseEstimationAccuracyView.clear();
                this.baseEstimationAccuracyView.beginFill(0x0000ff);
                this.baseEstimationAccuracyView.drawEllipse(xInTx, yInTx, stdXInTx, stdYInTx);
                this.baseEstimationAccuracyView.endFill();
            }
        }
        updateBaseEstimationErrorView() {
            if (this.getModel().state.trackingOutput.groundTruthPath != null
                && this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                // Make error arrow visible
                this.baseEstimationErrorView.getView().alpha = 1.0;
            }
            else {
                this.baseEstimationErrorView.getView().alpha = 0.0;
            }
        }
        updatePathViewAndAccuracyPathView() {
            // Update path view and accuracy path view in next update cycle
            this.invalidated = true;
        }
        updateParticlesView() {
            // Add all particles to pool
            this.addAllParticlesToPool();
            // Add new particles
            let particles = this.getModel().state.trackingState.particles;
            let maxParticleWeight = this.getMaxParticleWeight(particles);
            let minParticleWeight = this.getMinParticleWeight(particles);
            let particleWeightRange = maxParticleWeight - minParticleWeight;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let particleWeight = 1.0;
                if (particleWeightRange > 0) {
                    particleWeight = (particleModel.weight - minParticleWeight) / particleWeightRange;
                }
                this.addParticleForModel(particleModel, particleWeight);
            }
        }
        getMaxParticleWeight(particles) {
            let maxParticleWeight = -Number.MAX_VALUE;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let weight = particleModel.weight;
                if (weight > maxParticleWeight) {
                    maxParticleWeight = weight;
                }
            }
            return maxParticleWeight;
        }
        getMinParticleWeight(particles) {
            let minParticleWeight = Number.MAX_VALUE;
            for (let i = 0; i < particles.length; i++) {
                let particleModel = particles[i];
                let weight = particleModel.weight;
                if (weight < minParticleWeight) {
                    minParticleWeight = weight;
                }
            }
            return minParticleWeight;
        }
        addAllParticlesToPool() {
            this.particlePool = [];
            for (let i = 0; i < this.particleContainer.children.length; i++) {
                let particleViewContainer = this.particleContainer.getChildAt(i);
                this.particlePool.push(particleViewContainer);
            }
            this.particleContainer.removeChildren();
        }
        addParticleForModel(particleModel, particleWeight) {
            // Get particle view container
            let particleViewContainer = null;
            if (this.particlePool.length === 0) {
                particleViewContainer = this.getNewParticle();
            }
            else {
                particleViewContainer = this.popParticleFromPool();
            }
            // Update scale
            let particleWrapper = particleViewContainer.getChildAt(0);
            let particleView = particleWrapper.getChildAt(0);
            particleView.width = this.particleSizeInPx * particleWeight;
            particleView.height = this.particleSizeInPx * particleWeight;
            // Update orientation
            let particleArrow = particleViewContainer.arrowObject;
            let sourceXInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.lastX);
            let sourceYInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.lastY);
            let targetXInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.x);
            let targetYInTx = this.getDeviceLayer().getFloorplanLayer().getTexelsFromCm(particleModel.y);
            let sourcePosition = new PIXI.Point(sourceXInTx, sourceYInTx);
            let targetPosition = new PIXI.Point(targetXInTx, targetYInTx);
            particleArrow.sourcePosition = sourcePosition;
            particleArrow.targetPosition = targetPosition;
            // Set the arrow thickness proportional to the particle weight.
            particleArrow.getView().scale.y = particleWeight;
            // Update Position
            particleWrapper.x = targetXInTx;
            particleWrapper.y = targetYInTx;
            // Update color
            if (this.getModel().state.trackingState.speedInCmPerSec > 0.01 || this.getModel().state.trackingState.speedInCmPerSec === -1) {
                const motionColor = 0xff0000;
                particleArrow.setBodyColor(motionColor);
                particleView.tint = motionColor;
            }
            else {
                const zeroMotionColor = 0x000077;
                particleArrow.setBodyColor(zeroMotionColor);
                particleView.tint = zeroMotionColor;
            }
        }
        getNewParticle() {
            // Particle View container
            let particleViewContainer = new DisplayObjectContainer_21.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            // Scale
            this.rescaleParticleView(particleViewContainer);
            // Add to scene graph
            this.particleContainer.addChild(particleViewContainer);
            // Particle view
            let particleWrapper = new DisplayObjectContainer_21.DisplayObjectContainer(new PIXI.Container(), this.getEnvironment().renderingEnvironment);
            let particleView = new SpriteObject_20.SpriteObject(new PIXI.Sprite(), this.getEnvironment().renderingEnvironment);
            let texture = PIXI.loader.resources["particle"].texture;
            texture.baseTexture.mipmap = true;
            particleView.texture = new Texture_19.Texture(texture, this.getEnvironment().renderingEnvironment);
            // Pivot
            particleView.pivot.x = particleView.width / 2;
            particleView.pivot.y = particleView.height / 2;
            // Scale
            particleView.width = this.particleSizeInPx;
            particleView.height = this.particleSizeInPx;
            // Add to scene graph
            particleViewContainer.addChild(particleWrapper);
            particleWrapper.addChild(particleView);
            // Particle direction view
            let arrowObjectConfig = new ArrowObject_4.ArrowObject.Config();
            arrowObjectConfig.arrowBodyTextureName = "arrow_body";
            arrowObjectConfig.arrowHeadTextureName = "arrow_head_transparent";
            arrowObjectConfig.arrowHeadLengthInLogicalPx = 1;
            arrowObjectConfig.maxArrowHeadLengthInPercent = 0.4;
            arrowObjectConfig.bodyColor = 0xff0000;
            let particleArrow = new ArrowObject_4.ArrowObject(arrowObjectConfig, this.getEnvironment());
            // Add particle arrow to the scene so that the arrow object has camera access.
            this.addChild(particleArrow);
            // Change parent view to the particle view container
            particleViewContainer.addChild(particleArrow.getView());
            // Attach scene object to particle view container
            particleViewContainer.arrowObject = particleArrow;
            return particleViewContainer;
        }
        popParticleFromPool() {
            let particleViewContainer = this.particlePool[this.particlePool.length - 1];
            // Remove from pool
            this.particlePool.splice(this.particlePool.length - 1, 1);
            // Add to particle container
            this.particleContainer.addChild(particleViewContainer);
            return particleViewContainer;
        }
        updateMeanParticleView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    this.meanParticleView.alpha = 1.0;
                    this.meanParticleView.position.x = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.position.x);
                    this.meanParticleView.position.y = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.position.y);
                    if (this.meanReliabilityHasChanged()) {
                        this.meanIsReliable = this.getModel().state.trackingState.reliable;
                        this.drawMeanParticleView();
                    }
                }
            }
        }
        meanReliabilityHasChanged() {
            return (!this.getModel().state.trackingState.reliable && this.meanIsReliable)
                || (this.getModel().state.trackingState.reliable && !this.meanIsReliable);
        }
        updateFinalPositionView() {
            if (this.getModel().state.trackingOutput.finalEstimation != null) {
                this.finalPositionView.alpha = 1.0;
                this.finalPositionView.position.x = this.getPixelsFromCm(this.getModel().state.trackingOutput.finalEstimation.position.x);
                this.finalPositionView.position.y = this.getPixelsFromCm(this.getModel().state.trackingOutput.finalEstimation.position.y);
            }
        }
        updateStandardDeviationView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    // Alpha
                    this.standardDeviationView.alpha = 1.0;
                    // Draw graphics
                    this.redrawStandardDeviationViewWithScaleFactor(this.lastScaleFactor);
                    // Reposition view
                    this.standardDeviationView.position.x
                        = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.position.x);
                    this.standardDeviationView.position.y
                        = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.position.y);
                }
            }
        }
        redrawStandardDeviationViewWithScaleFactor(scaleFactor) {
            this.standardDeviationView.clear();
            let lineWidth = 1 * scaleFactor;
            this.standardDeviationView.lineStyle(lineWidth, 0x00ff00);
            this.standardDeviationView.beginFill(0x000000, 0);
            let width = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.standardDeviationX) * 2;
            let height = this.getPixelsFromCm(this.getModel().state.trackingState.particleFilterEstimation.standardDeviationY) * 2;
            this.standardDeviationView.drawEllipse(0, 0, width, height);
            this.standardDeviationView.endFill();
        }
        updatePathView(lineWidth) {
            // Configuration
            let targetColor = 0x8A2BE2;
            // Draw path
            this.heatmapLayer.clear();
            this.pathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.estimationPath.length > 0) {
                    // Get path
                    let path = this.getPositionsFromModel();
                    if (path.length === 0) {
                        return;
                    }
                    // Get last subpath
                    path = this.getLastSubPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Remove duplicates
                    path = this.removePositionDuplicatesInPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Remove unknown positions
                    path = this.removeUnknownPositionsInPath(path);
                    if (path.length === 0) {
                        return;
                    }
                    // Convert to world coordinates
                    path = this.getPathInWorldCoordinates(path);
                    // Draw heatmap
                    if (this.shouldDrawHeatmap === true) {
                        this.drawHeatmap(path);
                    }
                    // Draw path
                    this.pathView.lineStyle(lineWidth, targetColor, 1);
                    this.pathView.drawPolygon(path);
                    // Draw point
                    let lastPoint = path[path.length - 1];
                    this.pathView.beginFill(targetColor, 1.0);
                    this.pathView.drawCircle(lastPoint.x, lastPoint.y, lineWidth * 2);
                    this.pathView.endFill();
                }
            }
        }
        drawHeatmap(path) {
            const maxIntensity = 0.10;
            let pnrg = new Prando_3.Prando(this.getModel().state.deviceId);
            for (let i = 0; i < path.length; i++) {
                let point = path[i];
                let x = this.deviceLayer.getFloorplanLayer().getCmFromTexels(point.x);
                let y = this.deviceLayer.getFloorplanLayer().getCmFromTexels(point.y);
                let radius = 100;
                let intensity = (i / path.length) * maxIntensity;
                let numHeatpoints = 10;
                for (let j = 0; j < numHeatpoints; j++) {
                    let standardDeviationInCm = 100;
                    let noiseDistanceInCm = MathUtils_3.MathUtils.getNormalDistributedSample(0, standardDeviationInCm, pnrg);
                    let noiseAngle = 2 * Math.PI * pnrg.next();
                    let heatX = x + noiseDistanceInCm * Math.cos(noiseAngle);
                    let heatY = y + noiseDistanceInCm * Math.sin(noiseAngle);
                    intensity = intensity * (1 - (noiseDistanceInCm / (standardDeviationInCm * 3)));
                    this.heatmapLayer.addPoint(heatX, heatY, radius, intensity);
                }
            }
        }
        getPositionsFromModel() {
            let result = [];
            for (let i = 0; i < this.getModel().state.trackingOutput.estimationPath.length; i++) {
                let estimation = this.getModel().state.trackingOutput.estimationPath[i];
                if (estimation !== null) {
                    result.push(new PIXI.Point(estimation.position.x, estimation.position.y));
                }
            }
            return result;
        }
        getAccuraciesFromModel() {
            let result = [];
            for (let i = 0; i < this.getModel().state.trackingOutput.estimationPath.length; i++) {
                let estimation = this.getModel().state.trackingOutput.estimationPath[i];
                if (estimation !== null) {
                    let stdX = estimation.standardDeviationX;
                    let stdY = estimation.standardDeviationY;
                    let std = (stdX + stdY) / 2;
                    result.push(std);
                }
            }
            return result;
        }
        getLastSubPath(path) {
            let remainingIndices = this.getIndicesOfLastSubPath(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfLastSubPath(path) {
            // Get last "unknown" position (0,0)
            let newPath = new Array();
            let indexOfLastUnknownPosition = this.getIndexOfLastUnknownPosition(path);
            for (let i = indexOfLastUnknownPosition + 1; i < path.length; i++) {
                newPath.push(i);
            }
            return newPath;
        }
        getIndexOfLastUnknownPosition(path) {
            for (let i = path.length - 1; i >= 0; i--) {
                if (this.isUnknownPosition(path[i])) {
                    return i;
                }
            }
            return -1;
        }
        removePositionDuplicatesInPath(path) {
            let remainingIndices = this.getIndicesOfPathWhenRemovingDuplicates(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfPathWhenRemovingDuplicates(path) {
            let indices = new Array();
            indices.push(0);
            for (let i = 1; i < path.length; i++) {
                if (!((path[i].x === path[i - 1].x) && (path[i].y === path[i - 1].y))) {
                    indices.push(i);
                }
            }
            return indices;
        }
        removeUnknownPositionsInPath(path) {
            let remainingIndices = this.getIndicesOfPathWhenRemovingUnknownPositions(path);
            let newPath = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, remainingIndices);
            return newPath;
        }
        getIndicesOfPathWhenRemovingUnknownPositions(path) {
            let indices = new Array();
            for (let i = 0; i < path.length; i++) {
                let p = path[i];
                if (!this.isUnknownPosition(p)) {
                    indices.push(i);
                }
            }
            return indices;
        }
        isUnknownPosition(p) {
            return p.x === 0 && p.y === 0;
        }
        getPathInWorldCoordinates(path) {
            let pathInWorld = new Array();
            for (let i = 0; i < path.length; i++) {
                let pointInCm = path[i];
                let pixelPerMeter = this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter;
                let pointInWorld = new PIXI.Point(pixelPerMeter * (pointInCm.x / 100), pixelPerMeter * (pointInCm.y / 100));
                pathInWorld.push(pointInWorld);
            }
            return pathInWorld;
        }
        updateAccuracyPathView(lineWidth) {
            // Configuration
            let targetColor = 0x8A2BE2;
            // Draw path
            this.accuracyPathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.estimationPath.length > 3) {
                    // Getting path
                    let path = this.getPositionsFromModel();
                    let accuracies = this.getAccuraciesFromModel();
                    if (path.length === 0) {
                        return;
                    }
                    // Get last subpath
                    let indices = this.getIndicesOfLastSubPath(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Removing duplicates
                    indices = this.getIndicesOfPathWhenRemovingDuplicates(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Removing unknown positions
                    indices = this.getIndicesOfPathWhenRemovingUnknownPositions(path);
                    path = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(path, indices);
                    accuracies = ArrayUtils_2.ArrayUtils.getSubArrayWithIndices(accuracies, indices);
                    if (path.length === 0) {
                        return;
                    }
                    // Transform points to world coordinates
                    path = this.getPathInWorldCoordinates(path);
                    // Construct polygon above the line
                    this.drawAccuracyLine(path, accuracies, lineWidth, true);
                    // Construct polygon below the line
                    this.drawAccuracyLine(path, accuracies, lineWidth, false);
                    this.accuracyPathView.alpha = 0.5;
                }
            }
        }
        drawAccuracyLine(path, accuracies, lineWidth, above) {
            // Early out
            if (path.length < 2) {
                return;
            }
            let line = new Array();
            for (let i = 0; i < path.length; i++) {
                // Get reference point index
                let index = 0;
                if (above) {
                    index = i;
                }
                else {
                    index = path.length - 1 - i;
                }
                // Get reference point
                let targetPoint = path[index];
                // Get accuracy in texels
                let standardDeviation = accuracies[index];
                let accuracyInCm = standardDeviation * 3;
                let standardDeviationInMeter = accuracyInCm / 100;
                let standardDeviationInWorldTexel = this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter * standardDeviationInMeter;
                // Compute edge direction
                let edgeX = 0;
                let edgeY = 0;
                if (index === 0) {
                    let nextPoint = path[index + 1];
                    edgeX = targetPoint.x - nextPoint.x;
                    edgeY = targetPoint.y - nextPoint.y;
                }
                else {
                    let previousPoint = path[index - 1];
                    edgeX = previousPoint.x - targetPoint.x;
                    edgeY = previousPoint.y - targetPoint.y;
                }
                // Do not consider position duplicates
                if (edgeX === 0 && edgeY === 0) {
                    continue;
                }
                // Compute normal vector
                let normalX = 0;
                let normalY = 0;
                if (above) {
                    normalX = -edgeY;
                    normalY = edgeX;
                }
                else {
                    normalX = edgeY;
                    normalY = -edgeX;
                }
                // Normalize normal vector
                let length = Math.sqrt(normalX * normalX + normalY * normalY);
                normalX /= length;
                normalY /= length;
                // Compute accuracy point position
                let accuracyPointX = targetPoint.x + normalX * standardDeviationInWorldTexel;
                let accuracyPointY = targetPoint.y + normalY * standardDeviationInWorldTexel;
                let accuracyPoint = new PIXI.Point(accuracyPointX, accuracyPointY);
                // Add point to list
                line.push(accuracyPoint);
            }
            this.accuracyPathView.lineStyle(lineWidth, 0x0000ff, 1);
            this.accuracyPathView.drawPolygon(line);
        }
        updateGroundTruthPathView(lineWidth) {
            // Configuration
            let targetColor = 0x00ff00;
            // Draw path
            this.groundTruthPathView.clear();
            if (this.getModel() != null && this.getModel().state.trackingOutput.groundTruthPath != null) {
                if (this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                    let path = this.getModel().state.trackingOutput.groundTruthPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    path = this.getPathInWorldCoordinates(path);
                    // Draw path
                    this.groundTruthPathView.lineStyle(lineWidth, targetColor, 1);
                    this.groundTruthPathView.drawPolygon(path);
                    // Draw last recent point
                    let lastPoint = path[path.length - 1];
                    if (lastPoint !== undefined) {
                        this.groundTruthPathView.beginFill(targetColor, 1.0);
                        this.groundTruthPathView.drawCircle(lastPoint.x, lastPoint.y, lineWidth * 2);
                        this.groundTruthPathView.endFill();
                    }
                }
            }
        }
        updateObservationPathView(lineWidth) {
            // Configuration
            let targetColor = 0x000064;
            // Draw path
            this.observationPathView.clear();
            if (this.getModel() != null) {
                if (this.getModel().state.trackingOutput.observationPath.length > 0) {
                    let path = this.getModel().state.trackingOutput.observationPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    path = this.getPathInWorldCoordinates(path);
                    this.observationPathView.beginFill(0x000064);
                    let radius = lineWidth;
                    for (let i = 0; i < path.length; i++) {
                        let point = path[i];
                        this.observationPathView.drawCircle(point.x, point.y, radius);
                    }
                    this.observationPathView.endFill();
                }
            }
        }
        updatePathMatchingView(lineWidth) {
            // Draw path
            this.pathMatchingView.clear();
            if (this.getModel() !== null) {
                if (this.getModel().state.trackingOutput.pathMatching.length > 0) {
                    let pathMatching = this.getModel().state.trackingOutput.pathMatching;
                    for (let i = 0; i < pathMatching.length; i++) {
                        const pointMatch = pathMatching[i];
                        const estimatedPosition = pointMatch.estimatedPosition;
                        const groundTruthPosition = pointMatch.groundTruthPosition;
                        const matchingLine = this.getPathInWorldCoordinates([estimatedPosition, groundTruthPosition]);
                        this.accuracyPathView.lineStyle(lineWidth, 0xff0000, 1);
                        this.accuracyPathView.drawPolygon(matchingLine);
                    }
                }
            }
        }
        updateRegionProbabilityView() {
            // The region probability corresponds with the alpha value
            // of the root scene object.
            this.getView().alpha = this.getModel().state.trackingState.regionProbability;
        }
        // Helper methods
        getPixelsFromCm(widthInCm) {
            return (widthInCm / 100) * this.getDeviceLayer().getFloorplanLayer().getModel().pixelPerMeter;
        }
        loadProbabilityImage(probabilityImage) {
            this.loadImage(probabilityImage, this.probabilityImageSprite);
        }
        loadRadioMapImage(radioMapImage) {
            this.loadImage(radioMapImage, this.radioMapImageSprite);
            this.radioMapImageSprite.visible = true;
        }
        unloadRadioMapImage() {
            this.radioMapImageSprite.visible = false;
        }
        loadImage(image, spriteView) {
            // Load texture
            let baseTexture = new BaseTexture_9.BaseTexture(new PIXI.BaseTexture(image), this.getEnvironment().renderingEnvironment);
            let texture = new Texture_19.Texture(new PIXI.Texture(baseTexture.pixi()), this.getEnvironment().renderingEnvironment);
            texture.baseTexture.mipmap = true;
            spriteView.texture = texture;
            // Size
            spriteView.width = this.getDeviceLayer().getFloorplanLayer().getFloorSize().x;
            spriteView.height = this.getDeviceLayer().getFloorplanLayer().getFloorSize().y;
        }
        // View
        rescaleParticleView(particleViewContainer) {
            if (particleViewContainer.children.length > 0) {
                // Particle scaling
                let particleWrapper = particleViewContainer.getChildAt(0);
                particleWrapper.scale.x = this.lastScaleFactor;
                particleWrapper.scale.y = this.lastScaleFactor;
                // Arrow scaling
                let particleArrow = particleViewContainer.arrowObject;
                if (particleArrow !== undefined) {
                    particleArrow.draw(particleArrow.sourcePosition, particleArrow.targetPosition, 2 * this.lastScaleFactor);
                }
            }
        }
        // Updating
        // @Override
        update(lastFrametime) {
            super.update(lastFrametime);
            if (this.getView().alpha > 0) {
                if (this.getModel() != null) {
                    this.updateScale();
                    this.updateRotation();
                }
            }
        }
        updateScale() {
            let scaleFactor = 1.0;
            if (this.getScene() != null) {
                let camera = this.getScene().getCamera();
                scaleFactor = camera.getScaleX();
            }
            if (this.lastScaleFactor !== scaleFactor || this.invalidated) {
                this.lastScaleFactor = scaleFactor;
                if (!this.showDetailsOnHover || this.isHovering) {
                    this.retransformBeaconRssiArrows(scaleFactor);
                    this.retransformBeaconRssiTexts(scaleFactor);
                    this.retransformBaseEstimationView(scaleFactor);
                    this.rescaleParticles();
                    this.rescaleMeanParticleView();
                    this.rescaleFinalPositionView();
                    this.rescaleStandardDeviationView();
                    this.rescalePathView(this.lastScaleFactor);
                    this.rescaleAccuracyPathView(this.lastScaleFactor);
                    this.rescaleGroundTruthPathView(this.lastScaleFactor);
                    this.rescaleObservationPathView(this.lastScaleFactor);
                    this.rescalePathMatchingView(this.lastScaleFactor);
                    this.invalidated = false;
                }
                this.retransformBaseEstimationErrorView(scaleFactor);
            }
        }
        retransformBeaconRssiArrows(scaleFactor) {
            if (this.getModel().state.trackingState.baseEstimation != null) {
                for (let i = 0; i < this.beaconRssiArrows.length; i++) {
                    let arrow = this.beaconRssiArrows[i];
                    let serialNumber = this.beaconSerialNumbers[i];
                    let device = this.getDeviceLayer().getBeaconWithSerial(serialNumber);
                    // Draw arrow
                    let referenceArrowLineWidth = 1.5;
                    let lineWidth = referenceArrowLineWidth * scaleFactor;
                    let sourceX = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.x);
                    let sourceY = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.y);
                    let sourcePosition = new PIXI.Point(sourceX, sourceY);
                    let targetPosition = device.getView().position.pixi();
                    arrow.draw(sourcePosition, targetPosition, lineWidth);
                }
            }
        }
        retransformBeaconRssiTexts(scaleFactor) {
            if (this.getModel().state.trackingState.baseEstimation != null) {
                for (let i = 0; i < this.beaconRssiTexts.length; i++) {
                    let text = this.beaconRssiTexts[i];
                    let serialNumber = this.beaconSerialNumbers[i];
                    let device = this.getDeviceLayer().getBeaconWithSerial(serialNumber);
                    // Scale
                    text.setScaleX(scaleFactor);
                    text.setScaleY(scaleFactor);
                    // Position
                    let sourceX = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.x);
                    let sourceY = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.y);
                    let sourcePosition = new PIXI.Point(sourceX, sourceY);
                    let targetPosition = device.getView().position;
                    let meanPosition = new PIXI.Point((targetPosition.x + sourcePosition.x) / 2, (targetPosition.y + sourcePosition.y) / 2);
                    text.position = new Point_7.Point(meanPosition, this.getEnvironment().renderingEnvironment);
                }
            }
        }
        retransformBaseEstimationView(scaleFactor) {
            if (this.baseEstimationView != null) {
                if (this.baseEstimationView.x == 0 && this.baseEstimationView.y == 0) {
                    this.baseEstimationView.alpha = 0;
                }
                else {
                    this.baseEstimationView.scale.x = this.lastScaleFactor;
                    this.baseEstimationView.scale.y = this.lastScaleFactor;
                    this.baseEstimationView.alpha = 1;
                }
            }
        }
        retransformBaseEstimationErrorView(scaleFactor) {
            if (this.getModel().state.trackingOutput.groundTruthPath != null
                && this.getModel().state.trackingOutput.groundTruthPath.length > 0) {
                if (this.getModel().state.trackingState.baseEstimation !== undefined) {
                    // Draw arrow
                    let path = this.getModel().state.trackingOutput.groundTruthPath.slice();
                    path = this.removePositionDuplicatesInPath(path);
                    path = this.removeUnknownPositionsInPath(path);
                    path = this.getPathInWorldCoordinates(path);
                    if (path.length > 0) {
                        let device = this.getDeviceLayer().getDeviceWithDeviceId(this.getModel().state.deviceId);
                        let referenceArrowLineWidth = 1.5;
                        let lineWidth = referenceArrowLineWidth * scaleFactor;
                        let sourceX = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.x);
                        let sourceY = this.getPixelsFromCm(this.getModel().state.trackingState.baseEstimation.position.y);
                        let sourcePosition = new PIXI.Point(sourceX, sourceY);
                        let targetPosition = path[path.length - 1];
                        this.baseEstimationErrorView.draw(sourcePosition, targetPosition, lineWidth);
                    }
                }
            }
        }
        rescaleParticles() {
            for (let i = 0; i < this.particleContainer.children.length; i++) {
                let particleView = this.particleContainer.getChildAt(i);
                this.rescaleParticleView(particleView);
            }
        }
        rescaleMeanParticleView() {
            this.meanParticleView.scale.x = this.lastScaleFactor;
            this.meanParticleView.scale.y = this.lastScaleFactor;
        }
        rescaleFinalPositionView() {
            this.finalPositionView.scale.x = this.lastScaleFactor;
            this.finalPositionView.scale.y = this.lastScaleFactor;
        }
        rescaleStandardDeviationView() {
            if (this.getModel() != null) {
                if (this.getModel().state.trackingState.particleFilterEstimation != null) {
                    this.redrawStandardDeviationViewWithScaleFactor(this.lastScaleFactor);
                }
            }
        }
        rescalePathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updatePathView(lineWidth);
        }
        rescaleAccuracyPathView(scaleFactor) {
            let targetLineWidth = 1;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateAccuracyPathView(lineWidth);
        }
        rescaleGroundTruthPathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateGroundTruthPathView(lineWidth);
        }
        rescaleObservationPathView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updateObservationPathView(lineWidth);
        }
        rescalePathMatchingView(scaleFactor) {
            let targetLineWidth = 2;
            let lineWidth = targetLineWidth * scaleFactor;
            this.updatePathMatchingView(lineWidth);
        }
        updateRotation() {
            this.rotateBeaconRssiTexts();
        }
        rotateBeaconRssiTexts() {
            let camera = this.getScene().getCamera();
            let orientation = camera.getRotation();
            for (let i = 0; i < this.beaconRssiTexts.length; i++) {
                let beaconRssiText = this.beaconRssiTexts[i];
                if (beaconRssiText.rotation !== orientation || this.invalidated) {
                    beaconRssiText.rotation = orientation;
                }
            }
        }
        // Event-Handling: Mouse over
        // @Override
        onMouseMove(x, y) {
            if (this.showDetailsOnHover) {
                let device = this.getDependentObjects()[0];
                if (device.intersectsPointInScreenPx(x, y)) {
                    if (!this.isHovering) {
                        this.isHovering = true;
                        this.rootObject.getView().alpha = 1.0;
                        this.invalidated = true;
                    }
                }
                else {
                    if (this.isHovering) {
                        this.isHovering = false;
                        this.rootObject.getView().alpha = 0.0;
                        this.invalidated = true;
                    }
                }
            }
            return false;
        }
        // Drawing
        // @Override
        redraw() {
            this.invalidated = true;
        }
        // Name
        getName() {
            let device = this.getDependentObjects()[0];
            return device.getName();
        }
        // Relution map object: Popup info
        isPopupInfoSupported() {
            return false;
        }
        // Relution map object: Moving
        isMovable() {
            return false;
        }
        // Getters and setters
        getDeviceLayer() {
            return this.deviceLayer;
        }
        getModel() {
            return super.getModel();
        }
        isShowDetailsOnHover() {
            return this.showDetailsOnHover;
        }
        setShowDetailsOnHover(showDetailsOnHover) {
            this.showDetailsOnHover = showDetailsOnHover;
        }
    };
    DeviceTrackingDetails = __decorate([
        RelutionMapObject_12.RelutionModelBinding(DeviceTrackingStateModel_1.DeviceTrackingStateModel)
    ], DeviceTrackingDetails);
    exports.DeviceTrackingDetails = DeviceTrackingDetails;
});
define("test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetailsLayer", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/map/view/world/layers/heatmapLayer/HeatmapLayer", "test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetails", "test/tests/indoor/models/DeviceTrackingStateModel", "src/app/relution/view/world/RelutionMapObjectLayer"], function (require, exports, Asset_7, HeatmapLayer_4, DeviceTrackingDetails_1, DeviceTrackingStateModel_2, RelutionMapObjectLayer_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let DeviceTrackingDetailsLayer = class DeviceTrackingDetailsLayer extends RelutionMapObjectLayer_6.RelutionMapObjectLayer {
        // Initialization
        constructor(config, environment, deviceLayer) {
            super(config, environment, deviceLayer.getFloorplanLayer(), deviceLayer);
            this.detailsLayerConfig = config;
            this.deviceLayer = deviceLayer;
            this.initHeatmapLayer();
            this.setModelFactory((parentModel) => {
                let device = deviceLayer.getDeviceWithUuid(parentModel.uuid);
                if (device instanceof Asset_7.Asset) {
                    let model = new DeviceTrackingStateModel_2.DeviceTrackingStateModel();
                    model.state.deviceId = device.getModel().deviceId;
                    model.deviceUuid = device.getModel().uuid;
                    model.uuid = device.getModel().uuid;
                    return model;
                }
                else {
                    return null;
                }
            });
            this.setObjectFactory((model, config) => {
                let device = deviceLayer.getDeviceWithUuid(model.parentUuid);
                if (device !== null) {
                    return new DeviceTrackingDetails_1.DeviceTrackingDetails(config, this.getEnvironment(), this.deviceLayer.getFloorplanLayer(), model, device, deviceLayer, this.heatmapLayer, this.detailsLayerConfig.showDetailsOnHover);
                }
                else {
                    return null;
                }
            });
        }
        initHeatmapLayer() {
            this.heatmapLayer = new HeatmapLayer_4.HeatmapLayer(this.getEnvironment(), this.deviceLayer.getFloorplanLayer());
            // this.addChild(this.heatmapLayer);
        }
        // Loading images
        loadProbabilityImage(probabilityImage) {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.loadProbabilityImage(probabilityImage);
            }
        }
        loadRadioMapImage(radioMapImage) {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.loadRadioMapImage(radioMapImage);
            }
        }
        unloadRadioMap() {
            if (this.getObjects().length !== 0) {
                let firstDetails = this.getObjects()[0];
                firstDetails.unloadRadioMapImage();
            }
        }
        // Getters and setters
        setShowDetailsOnHover(showDetailsOnHover) {
            this.detailsLayerConfig.showDetailsOnHover = showDetailsOnHover;
            for (let i = 0; i < this.getObjects().length; i++) {
                let details = this.getObjects()[i];
                details.setShowDetailsOnHover(showDetailsOnHover);
            }
        }
        isShowDetailsOnHover() {
            return this.detailsLayerConfig.showDetailsOnHover;
        }
    };
    DeviceTrackingDetailsLayer = __decorate([
        RelutionMapObjectLayer_6.RelutionMapObjectBinding(DeviceTrackingDetails_1.DeviceTrackingDetails)
    ], DeviceTrackingDetailsLayer);
    exports.DeviceTrackingDetailsLayer = DeviceTrackingDetailsLayer;
    (function (DeviceTrackingDetailsLayer) {
        class Config extends RelutionMapObjectLayer_6.RelutionMapObjectLayer.Config {
            constructor() {
                super(...arguments);
                /**
                 * If true, the details will only be shown when hovering with the mouse cursor.
                 *
                 * Default: false
                 */
                this.showDetailsOnHover = false;
            }
        }
        DeviceTrackingDetailsLayer.Config = Config;
    })(DeviceTrackingDetailsLayer = exports.DeviceTrackingDetailsLayer || (exports.DeviceTrackingDetailsLayer = {}));
    exports.DeviceTrackingDetailsLayer = DeviceTrackingDetailsLayer;
});
define("test/tests/indoor/models/IndoorStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorStateModel extends Model_13.Model {
        constructor() {
            super(...arguments);
            this._running = false;
            this._blocking = false;
            this._blockingText = "";
        }
        // Getters and setters
        set running(running) {
            this._running = running;
            this.notifyObservers("running");
        }
        get running() {
            return this._running;
        }
        set blocking(blocking) {
            this._blocking = blocking;
            this.notifyObservers("blocking");
        }
        get blocking() {
            return this._blocking;
        }
        set blockingText(blockingText) {
            this._blockingText = blockingText;
            this.notifyObservers("blockingText");
        }
        get blockingText() {
            return this._blockingText;
        }
    }
    __decorate([
        Model_13.ModelProperty()
    ], IndoorStateModel.prototype, "_running", void 0);
    __decorate([
        Model_13.ModelProperty()
    ], IndoorStateModel.prototype, "_blocking", void 0);
    __decorate([
        Model_13.ModelProperty()
    ], IndoorStateModel.prototype, "_blockingText", void 0);
    exports.IndoorStateModel = IndoorStateModel;
});
define("test/tests/indoor/view/map/IndoorMap", ["require", "exports", "src/app/relution/RelutionMap", "src/engine/input/GestureRecognizer", "src/app/relution/utils/RssiToDistance", "src/app/relution/utils/KeyUtils", "test/tests/indoor/view/map/layers/deviceTrackingDetailsLayer/DeviceTrackingDetailsLayer", "test/tests/indoor/models/IndoorStateModel", "src/engine/scene/GameObject", "src/engine/rendering/objects/GraphicsObject"], function (require, exports, RelutionMap_7, GestureRecognizer_10, RssiToDistance_4, KeyUtils_3, DeviceTrackingDetailsLayer_1, IndoorStateModel_1, GameObject_7, GraphicsObject_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorMap extends RelutionMap_7.RelutionMap {
        // Initialization
        constructor(options) {
            super(options);
            this.radiusInPx = 5;
            // Model
            this.simulationState = new IndoorStateModel_1.IndoorStateModel();
            // View
            this.detailsLayers = new Array();
            this.lastScaleFactor = -1;
            this.taggingPath = new Array();
            this.taggingPathTimestamps = new Array();
            this.taggingData = new Array();
            this.taggingTimestampData = new Array();
            this.currentOrientationInRad = 0;
            this.currentDepth = 0;
            this.options = options;
        }
        // @Override
        load(floor, initializedCallback) {
            super.load(floor, () => {
                this.configureFloors();
                this.initViews();
                this.registerInputEvents();
                initializedCallback();
            });
        }
        // Mode initialization
        initViews() {
            this.initTaggingModeViews();
            this.initMouseSimulationModeViews();
        }
        initTaggingModeViews() {
            this.initActiveTagPoint();
            this.initTaggingPath();
        }
        initActiveTagPoint() {
            this.activeTagPoint = new GraphicsObject_21.GraphicsObject(new PIXI.Graphics(), this.fruityMap.getEnvironment().renderingEnvironment);
            this.activeTagPoint.clear();
            this.activeTagPoint.beginFill(0xff00ff);
            this.activeTagPoint.drawCircle(0, 0, this.radiusInPx);
            this.activeTagPoint.endFill();
            this.activeTagPoint.alpha = 0.0;
            this.getBuilding().getView().addChild(this.activeTagPoint);
        }
        initTaggingPath() {
            this.taggingPathView = new GraphicsObject_21.GraphicsObject(new PIXI.Graphics(), this.fruityMap.getEnvironment().renderingEnvironment);
            this.taggingPathView.alpha = 0.0;
            this.getBuilding().getView().addChild(this.taggingPathView);
        }
        initMouseSimulationModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.initTargetPositionView();
            }
        }
        initTargetPositionView() {
            let widthInPx = 2;
            let heightInPx = 40;
            this.targetView = new GraphicsObject_21.GraphicsObject(new PIXI.Graphics(), this.fruityMap.getEnvironment().renderingEnvironment);
            this.targetView.clear();
            this.targetView.beginFill(0xff00ff);
            this.targetView.lineStyle(1, 0x000000);
            this.targetView.drawRect(-widthInPx / 2, 0, widthInPx, heightInPx);
            this.targetView.drawCircle(0, 0, this.radiusInPx);
            this.targetView.endFill();
            this.targetView.alpha = 0.0;
            this.getBuilding().getView().addChild(this.targetView);
        }
        registerInputEvents() {
            let that = this;
            this.fruityMap.addScenelessGameObject(new class extends GameObject_7.GameObject {
                constructor(environment) {
                    super(environment);
                }
                // @Override
                update(lastFrametime) {
                    super.update(lastFrametime);
                    that.update(lastFrametime);
                }
                // @Override
                onKeyDown(keyCode) {
                    super.onKeyDown(keyCode);
                    that.onKeyDown(keyCode);
                    return false;
                }
                // @Override
                onMouseWheel(delta, mouseX, mouseY) {
                    super.onMouseWheel(delta, mouseX, mouseY);
                    that.onMouseWheel(delta, mouseX, mouseY);
                    return false;
                }
                // @Override
                onMouseMove(x, y) {
                    super.onMouseMove(x, y);
                    that.onMouseMove(x, y);
                    return false;
                }
            }(this.fruityMap.getEnvironment()));
        }
        // Floor management
        configureFloors() {
            this.getBuilding().addFloorObserver(this);
            this.floorAdded(this.getBuilding().getCurrentFloor());
        }
        // Floor events
        // @Override
        floorAdded(floor) {
            if (floor !== null) {
                let deviceLayer = floor.getDeviceLayer();
                let deviceLayerContainer = floor.getDeviceLayerContainer();
                let config = new DeviceTrackingDetailsLayer_1.DeviceTrackingDetailsLayer.Config();
                config.showDetailsOnHover = this.options.showDetailsOnHover;
                let detailsLayer = new DeviceTrackingDetailsLayer_1.DeviceTrackingDetailsLayer(config, this.fruityMap.getEnvironment(), deviceLayer);
                deviceLayerContainer.addLayerAfterLayer(detailsLayer, deviceLayer);
                this.detailsLayers[floor.getFloorName()] = detailsLayer;
            }
        }
        // Image preloading
        // @Override
        getPreloadingImageNames() {
            let preloadingImages = super.getPreloadingImageNames();
            preloadingImages.push("particle");
            return preloadingImages;
        }
        // Updating devices' state models
        loadIndoorStateModels(floor, indoorStateModels) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.updateModels(indoorStateModels);
            }
        }
        loadProbabilityImage(floor, probabilityImage) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.loadProbabilityImage(probabilityImage);
            }
        }
        loadRadioMap(floor, radioMapImage) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.loadRadioMapImage(radioMapImage);
            }
        }
        unloadRadioMap(floor) {
            if (this.detailsLayers[floor.getFloorName()] !== undefined) {
                let detailsLayer = this.detailsLayers[floor.getFloorName()];
                detailsLayer.unloadRadioMap();
            }
        }
        // Updating geofences' state models
        loadGeofenceStateModels(floor, geofenceStateModels) {
            let geofenceLayer = floor.getGeofenceLayer();
            geofenceLayer.loadGeofenceStateModels(geofenceStateModels);
        }
        // Updating
        update(lastFrametime) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.updateMouseSimulationMode();
            }
            this.updateDatasetTaggingMode();
        }
        updateMouseSimulationMode() {
            this.updateTargetView();
        }
        updateTargetView() {
            if (this.simulationState.running) {
                // Scale
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                this.targetView.scale.x = camera.getScaleX();
                this.targetView.scale.y = camera.getScaleY();
                // Rotation
                this.targetView.rotation = this.currentOrientationInRad;
                // Alpha
                const minRssi = RssiToDistance_4.RssiToDistance.MIN_RSSI;
                let currentFloor = this.getBuilding().getCurrentFloor();
                let floorHeightInCm = currentFloor.getHeightInMeter() * 100;
                let targetHeightInCm = this.getMouseDepthInWorldCm();
                let distanceToFloorInCm = Math.abs(targetHeightInCm - floorHeightInCm);
                let maxDistanceInCm = RssiToDistance_4.RssiToDistance.rssiToDistance(minRssi) * 100;
                let relativeDistanceToFloor = Math.max(Math.min(distanceToFloorInCm / maxDistanceInCm, 1), 0);
                this.targetView.alpha = 1 - relativeDistanceToFloor;
            }
            else {
                this.targetView.alpha = 0.0;
            }
        }
        updateDatasetTaggingMode() {
            this.updateActiveTagPointPosition();
            this.updateTaggingPath();
        }
        updateActiveTagPointPosition() {
            if (this.shouldTagBeVisible()) {
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                this.activeTagPoint.scale.x = camera.getScaleX();
                this.activeTagPoint.scale.y = camera.getScaleY();
                this.activeTagPoint.alpha = 1.0;
            }
            else {
                this.activeTagPoint.alpha = 0.0;
            }
        }
        updateTaggingPath() {
            if (this.shouldTagBeVisible()) {
                let camera = this.fruityMap.getWorld().getScene().getCamera();
                let scaleFactor = camera.getScaleX();
                if (this.lastScaleFactor !== scaleFactor) {
                    this.lastScaleFactor = scaleFactor;
                    this.updateTaggingPathView();
                }
                this.constrainTaggingPathSize();
                this.taggingPathView.alpha = 1.0;
            }
            else {
                this.taggingPathView.alpha = 0.0;
            }
        }
        shouldTagBeVisible() {
            return (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) && (this.activeTagPoint.x !== 0.0 || this.activeTagPoint.y !== 0.0);
        }
        constrainTaggingPathSize() {
            let nowInMs = Date.now();
            const pointLifetimeInMs = 1000;
            let modified = false;
            while (this.taggingPathTimestamps.length > 0 && (nowInMs - this.taggingPathTimestamps[0] > pointLifetimeInMs)) {
                this.taggingPath.splice(0, 1);
                this.taggingPathTimestamps.splice(0, 1);
                modified = true;
            }
            if (modified) {
                this.updateTaggingPathView();
            }
        }
        // Interaction
        onMouseMove(x, y) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                if (this.simulationState.running) {
                    this.onMouseMoveInMouseSimulationMode(x, y);
                }
            }
            else if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                if (this.simulationState.running) {
                    this.onMouseMoveInDatasetTaggingMode(x, y);
                }
            }
            return false;
        }
        onMouseMoveInMouseSimulationMode(x, y) {
            if (GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                // Position
                let positionInPx = new PIXI.Point(x, y);
                let positionInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(positionInPx);
                this.targetView.x = positionInTx.x;
                this.targetView.y = positionInTx.y;
            }
        }
        onMouseMoveInDatasetTaggingMode(x, y) {
            this.setTagPointTo(x, y);
        }
        setTagPointTo(x, y) {
            if (GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                this.moveActiveTagPointTo(x, y);
                this.updateTaggingPathTo(x, y);
            }
        }
        moveActiveTagPointTo(x, y) {
            let positionInPx = new PIXI.Point(x, y);
            let positionInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(positionInPx);
            this.activeTagPoint.x = positionInTx.x;
            this.activeTagPoint.y = positionInTx.y;
        }
        updateTaggingPathTo(x, y) {
            let pointInPx = new PIXI.Point(x, y);
            let pointInTx = this.getBuilding().getCurrentFloor().getFloorplanLayer().getTexelsFromScreenPixels(pointInPx);
            this.addPointToTaggingPath(pointInTx);
            this.updateTaggingPathView();
        }
        addPointToTaggingPath(pointInTx) {
            this.taggingPath.push(pointInTx);
            this.taggingPathTimestamps.push(Date.now());
            let floorplanLayer = this.getBuilding().getCurrentFloor().getFloorplanLayer();
            let pointInCm = new PIXI.Point(floorplanLayer.getCmFromTexels(pointInTx.x), floorplanLayer.getCmFromTexels(pointInTx.y));
            this.taggingData.push(pointInCm);
            this.taggingTimestampData.push(Date.now());
        }
        updateTaggingPathView() {
            this.taggingPathView.clear();
            this.taggingPathView.lineStyle(1 * this.lastScaleFactor, 0xff00ff);
            this.taggingPathView.drawPolygon(this.taggingPath);
            this.taggingPathView.endFill();
        }
        onKeyDown(keyCode) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.handleOnKeyDownInMouseSimulationMode(keyCode);
            }
            else if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                this.handleOnKeyDownInDatasetTaggingMode(keyCode);
            }
            return false;
        }
        handleOnKeyDownInMouseSimulationMode(keyCode) {
            const clockWiseKeyCode = 88; // x
            const counterClockWiseKeyCode = 89; // y
            if (keyCode === clockWiseKeyCode) {
                this.updateTargetOrientation(-1);
            }
            else if (keyCode === counterClockWiseKeyCode) {
                this.updateTargetOrientation(+1);
            }
        }
        handleOnKeyDownInDatasetTaggingMode(keyCode) {
            if (this.simulationState.running) {
                if (KeyUtils_3.KeyUtils.isCtrlKey(keyCode)) {
                    this.setTagPointTo(GestureRecognizer_10.GestureRecognizer.getMousePositionX(), GestureRecognizer_10.GestureRecognizer.getMousePositionY());
                }
            }
        }
        onMouseWheel(delta, mouseX, mouseY) {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.updateDepth(delta);
            }
            return false;
        }
        updateTargetOrientation(delta) {
            let rotationInRad = (2 * Math.PI) * (10.0 / 360);
            rotationInRad = delta < 0 ? rotationInRad : -rotationInRad;
            this.currentOrientationInRad = (this.currentOrientationInRad + rotationInRad) % (Math.PI * 2);
        }
        updateDepth(delta) {
            if (!GestureRecognizer_10.GestureRecognizer.isCtrlPressed()) {
                if (delta < 0) {
                    this.currentDepth -= 1.0 / (this.getBuilding().getFloors().length);
                }
                else {
                    this.currentDepth += 1.0 / (this.getBuilding().getFloors().length);
                }
                this.currentDepth = Math.min(Math.max(this.currentDepth, 0), 1);
            }
        }
        // External events
        onSimulationStateUpdated(state) {
            if (!state.equals(this.simulationState)) {
                this.simulationState = state;
                if (!this.simulationState.running) {
                    this.reset();
                }
            }
        }
        reset() {
            this.resetDatasetTaggingModeViews();
            this.resetMouseSimulationModeViews();
        }
        resetDatasetTaggingModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType) {
                this.activeTagPoint.alpha = 0.0;
                this.taggingPathView.clear();
                this.taggingPathView.alpha = 0.0;
                this.taggingPath = [];
                this.taggingPathTimestamps = [];
                this.taggingData = [];
            }
        }
        resetMouseSimulationModeViews() {
            if (this.options.type instanceof IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.targetView.alpha = 0.0;
                this.currentOrientationInRad = 0;
                this.currentDepth = 0;
            }
        }
        // Getters and setters
        getType() {
            return this.options.type;
        }
        setType(type) {
            this.options.type = type;
        }
        pullTaggingData() {
            let taggingData = this.taggingData;
            this.taggingData = [];
            return taggingData;
        }
        pullTimestampData() {
            let taggingTimestampData = this.taggingTimestampData;
            this.taggingTimestampData = [];
            return taggingTimestampData;
        }
        getTargetPositionInWorldCm() {
            try {
                let deviceLayer = this.getBuilding().getCurrentFloor().getDeviceLayer();
                let targetPositionInTx = this.targetView.position;
                let targetPositionInCmX = (targetPositionInTx.x / deviceLayer.getFloorplanLayer().getModel().pixelPerMeter) * 100;
                let targetPositionInCmY = (targetPositionInTx.y / deviceLayer.getFloorplanLayer().getModel().pixelPerMeter) * 100;
                let noiseWidthInCm = 0;
                targetPositionInCmX = targetPositionInCmX + ((Math.random() - 0.5) * noiseWidthInCm);
                targetPositionInCmY = targetPositionInCmY + ((Math.random() - 0.5) * noiseWidthInCm);
                return new PIXI.Point(targetPositionInCmX, targetPositionInCmY);
            }
            catch (e) {
                return new PIXI.Point(0, 0);
            }
        }
        getTargetOrientationInRad() {
            return this.currentOrientationInRad;
        }
        getMouseDepthInWorldCm() {
            let nearestFloor = this.getNearestFloor(this.currentDepth);
            let mouseDepthInWorldCm = nearestFloor.getHeightInMeter() * 100;
            return mouseDepthInWorldCm;
        }
        getNearestFloor(floorNumber) {
            let floorIndex = Math.floor(this.currentDepth * (this.getBuilding().getFloors().length - 1));
            return this.getBuilding().getFloors()[floorIndex];
        }
        getNearestFloorName() {
            let nearestFloor = this.getNearestFloor(this.currentDepth);
            return nearestFloor.getFloorName();
        }
    }
    exports.IndoorMap = IndoorMap;
    (function (IndoorMap) {
        // Types
        let Type;
        (function (Type_1) {
            class Type {
            }
            Type_1.Type = Type;
            class PositioningDatasetSimulationType extends Type {
            }
            Type_1.PositioningDatasetSimulationType = PositioningDatasetSimulationType;
            class ObjectTrackingDatasetSimulationType extends Type {
            }
            Type_1.ObjectTrackingDatasetSimulationType = ObjectTrackingDatasetSimulationType;
            class AssetTrackingSimulationType extends Type {
            }
            Type_1.AssetTrackingSimulationType = AssetTrackingSimulationType;
            class AssetTrackingRealTimeMonitoringType extends AssetTrackingSimulationType {
            }
            Type_1.AssetTrackingRealTimeMonitoringType = AssetTrackingRealTimeMonitoringType;
            class AssetTrackingDatasetSimulationType extends AssetTrackingSimulationType {
            }
            Type_1.AssetTrackingDatasetSimulationType = AssetTrackingDatasetSimulationType;
            class AssetTrackingDatasetMouseSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetMouseSimulationType = AssetTrackingDatasetMouseSimulationType;
            class AssetTrackingDatasetValidationSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetValidationSimulationType = AssetTrackingDatasetValidationSimulationType;
            class AssetTrackingDatasetTaggingSimulationType extends AssetTrackingDatasetValidationSimulationType {
            }
            Type_1.AssetTrackingDatasetTaggingSimulationType = AssetTrackingDatasetTaggingSimulationType;
            class AssetTrackingDatasetBeaconSimulationType extends AssetTrackingDatasetSimulationType {
            }
            Type_1.AssetTrackingDatasetBeaconSimulationType = AssetTrackingDatasetBeaconSimulationType;
        })(Type = IndoorMap.Type || (IndoorMap.Type = {}));
        class Options extends RelutionMap_7.RelutionMap.Options {
        }
        IndoorMap.Options = Options;
    })(IndoorMap = exports.IndoorMap || (exports.IndoorMap = {}));
});
define("test/tests/indoor/IndoorApplicationController", ["require", "exports", "src/app/relution/locale/LocalizationEn", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/Floor", "test/tests/indoor/IndoorApplication", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, LocalizationEn_6, Asset_8, Beacon_11, Floor_4, IndoorApplication_1, IndoorMap_1, SimulationServiceConfig_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorApplicationController {
        // Construction
        constructor(config, subcontroller, service) {
            this.config = config;
            this.initSubcontroller(subcontroller);
            this.initService(service, (siteNames) => {
                this.initView(siteNames, () => {
                    this.startSynchronizingModels();
                });
            });
        }
        initSubcontroller(subcontroller) {
            this.subcontroller = subcontroller;
        }
        // 1. Service initialization
        initService(service, callback) {
            this.service = service;
            this.service.init(this.config.service, (resolvedServiceConfig, siteNames) => {
                // Replace the service configuration by the one resolved by the service.
                this.config.service = resolvedServiceConfig;
                callback(siteNames);
            });
        }
        // 2. View initialization
        initView(siteNames, initializationCallback) {
            this.initIndoorMap(siteNames, () => {
                this.initDomElements(() => {
                    initializationCallback();
                });
            });
        }
        // 2.1. Map initialization
        initIndoorMap(siteNames, initializationCallback) {
            let options = this.initMapOptions();
            let map = new IndoorMap_1.IndoorMap(options);
            this.initMap(map, siteNames, initializationCallback);
        }
        initMapOptions() {
            let options = new IndoorMap_1.IndoorMap.Options();
            options.parentHtmlElement = document.getElementById("map");
            options.pathToImages = "../../../img/png/";
            options.type = IndoorApplication_1.IndoorApplication.Config.getIndoorMapType(this.config);
            options.showDetailsOnHover = this.shouldShowDetailsOnHover();
            options.canvasWidth = Number.parseInt($(options.parentHtmlElement).css("width"));
            options.canvasHeight = Number.parseInt($(options.parentHtmlElement).css("height"));
            options.localization = new LocalizationEn_6.LocalizationEn();
            options.world.building.objectTypeVisibilities.set(Beacon_11.Beacon.name, $("#beacons-action").hasClass("active"));
            options.world.building.objectTypeVisibilities.set(Asset_8.Asset.name, $("#assets-action").hasClass("active"));
            this.subcontroller.overrideMapConfig(options);
            return options;
        }
        initMap(map, siteNames, initializationCallback) {
            // 3. Add floors to map
            let floors = new Array();
            let callback = (floor) => {
                floors.push(floor);
                if (floors.length === siteNames.length) {
                    this.loadIndoorMap(map, floors[0], () => {
                        this.addFloorsToMap(floors, initializationCallback);
                    });
                }
            };
            // 2. Load floor textures
            let modelLoadedFloors = new Array();
            let floorModelCallback = (floor) => {
                modelLoadedFloors.push(floor);
                if (modelLoadedFloors.length == siteNames.length) {
                    for (let i = 0; i < modelLoadedFloors.length; i++) {
                        let currentFloor = modelLoadedFloors[i];
                        currentFloor.load(callback);
                    }
                }
            };
            // 1. Load floor models
            for (let i = 0; i < siteNames.length; i++) {
                let siteName = siteNames[i];
                this.loadFloorModel(map, siteName, floorModelCallback);
            }
        }
        loadFloorModel(map, floorName, callback) {
            this.service.loadFloor(floorName, (floorModel) => {
                let floor = map.createFloor(floorName, floorModel, new Floor_4.Floor.Config());
                callback(floor);
            });
        }
        loadIndoorMap(indoorMap, floor, callback) {
            // Instantiation
            indoorMap.load(floor, () => {
                this.indoorMap = indoorMap;
                window.addEventListener("beforeunload", (e) => {
                    this.indoorMap.destroy();
                });
                window.addEventListener("resize", () => {
                    let newWidth = Number.parseInt($(indoorMap.getConfig().parentHtmlElement).css("width"));
                    let newHeight = Number.parseInt($(indoorMap.getConfig().parentHtmlElement).css("height"));
                    this.indoorMap.setSize(newWidth, newHeight);
                });
                this.indoorMap.setDeviceEditModeEnabled(false);
                this.indoorMap.toggleLayerVisibility("connections", false);
                callback(this.indoorMap);
            });
        }
        shouldShowDetailsOnHover() {
            let applicationConfig = this.config.service.application;
            return applicationConfig.simulation.type === SimulationServiceConfig_2.BeaconTrackingSimulationConfig.TYPE_NAME;
        }
        addFloorsToMap(floors, initializationCallback) {
            let numberOfLoadedDeviceDatasets = 0;
            let devicesCallback = (deviceModels) => {
                numberOfLoadedDeviceDatasets++;
                if (numberOfLoadedDeviceDatasets == floors.length) {
                    this.orderFloorsByAvgBeaconHeight();
                    this.loadGeofences(floors, initializationCallback);
                }
            };
            for (let i = 0; i < floors.length; i++) {
                let currentFloor = floors[i];
                let currentFloorName = currentFloor.getFloorName();
                this.indoorMap.getBuilding().addFloor(currentFloor);
                this.loadDevices(currentFloorName, devicesCallback);
            }
        }
        loadDevices(siteName, callback) {
            this.service.loadDevices(siteName, (deviceModels) => {
                this.indoorMap.getBuilding().getFloorWithName(siteName).loadDevices(deviceModels);
                callback(deviceModels);
            });
        }
        orderFloorsByAvgBeaconHeight() {
            this.indoorMap.getBuilding().sortFloorsByHeight();
        }
        loadGeofences(floors, initializationCallback) {
            let numOfLoadedGeofenceDatasets = 0;
            let callback = (geofenceModels) => {
                numOfLoadedGeofenceDatasets++;
                if (numOfLoadedGeofenceDatasets == floors.length) {
                    initializationCallback();
                }
            };
            for (let i = 0; i < this.indoorMap.getBuilding().getFloors().length; i++) {
                let floor = this.indoorMap.getBuilding().getFloors()[i];
                this.loadGeofencesForFloor(floor, callback);
            }
        }
        loadGeofencesForFloor(floor, callback) {
            this.service.loadGeofences(floor.getFloorName(), (geofenceModels) => {
                this.indoorMap.getBuilding().getFloorWithName(floor.getFloorName()).loadGeofences(geofenceModels);
                callback(geofenceModels);
            });
        }
        // 2.2. DOM initialization
        initDomElements(initializationCallback) {
            this.initTabBar();
            this.initActionBar();
            this.initLeftBar();
            this.initRightBar();
            this.subcontroller.init(this.indoorMap, () => {
                this.showView();
                initializationCallback();
            });
        }
        initTabBar() {
            this.makeAllTabBarItemsInactive();
            let tabBarItemId = this.subcontroller.getId();
            this.setTabBarItemActive(tabBarItemId);
        }
        makeAllTabBarItemsInactive() {
            let children = $("#tabbar").children();
            for (let i = 0; i < children.length; i++) {
                let child = children[i];
                let aElement = $($(child).children()[0]);
                aElement.removeClass("active");
            }
        }
        setTabBarItemActive(tabBarItemId) {
            $(tabBarItemId).addClass("active");
        }
        initActionBar() {
            // General
            this.toggleLayerOnActionButtonToggleEvent("help-action", "help");
            // Floor
            this.toggleLayerOnActionButtonToggleEvent("floor-wallplan-action", "wallplan");
            this.toggleLayerOnActionButtonToggleEvent("floor-taggingplan-action", "taggingPlan");
            // Objects
            this.toggleLayerOnActionButtonToggleEvent("devices-action", "devices");
            this.toggleLayerOnActionButtonToggleEvent("geofences-action", "geofence");
            // Devices
            this.toggleRelutionMapObjectVisibilityOnButtonToggleEvent("beacons-action", Beacon_11.Beacon.name);
            this.toggleRelutionMapObjectVisibilityOnButtonToggleEvent("assets-action", Asset_8.Asset.name);
            // Device layers
            this.toggleLayerOnActionButtonToggleEvent("devices-info-action", "info");
            // Beacon layers
            this.toggleLayerOnActionButtonToggleEvent("beacons-ranges-action", "ranges");
            this.toggleLayerOnActionButtonToggleEvent("beacons-connections-action", "connections");
            // Asset layers
            this.toggleLayerOnActionButtonToggleEvent("assets-tracks-action", "tracking");
        }
        toggleLayerOnActionButtonToggleEvent(actionId, layerName) {
            // 1. Set initial layer visibility
            let actionElement = $("#" + actionId);
            let visible = actionElement.hasClass("active");
            this.indoorMap.toggleLayerVisibility(layerName, visible);
            // 2. Change layer visibility on toggle
            actionElement.on("click", () => {
                var visible = actionElement.hasClass("active");
                this.indoorMap.toggleLayerVisibility(layerName, !visible);
            });
            // 3. Change button toggle on layer visibility change
            this.indoorMap.addObserver({
                onLayerVisibilityChanged: (name, visible) => {
                    if (name === layerName) {
                        if (visible) {
                            actionElement.addClass("active");
                        }
                        else {
                            actionElement.removeClass("active");
                        }
                    }
                }
            });
        }
        toggleRelutionMapObjectVisibilityOnButtonToggleEvent(actionId, objectTypeName) {
            // 1. Set initial object type visibility
            let actionElement = $("#" + actionId);
            let visible = this.indoorMap.getConfig().world.building.objectTypeVisibilities.get(objectTypeName);
            if (visible) {
                actionElement.addClass("active");
            }
            else {
                actionElement.removeClass("active");
            }
            // 2. Change object type visibility on toggle
            actionElement.on("click", () => {
                var visible = actionElement.hasClass("active");
                this.indoorMap.toggleRelutionMapObjectTypeVisibility(objectTypeName, !visible);
            });
            // 3. Change button toggle on layer visibility change
            this.indoorMap.addObserver({
                onObjectTypeVisibilityChanged: (typeName, visible) => {
                    if (typeName === objectTypeName) {
                        if (visible) {
                            actionElement.addClass("active");
                        }
                        else {
                            actionElement.removeClass("active");
                        }
                    }
                }
            });
        }
        initLeftBar() {
            // Nothing to do
        }
        initRightBar() {
            // 1. Add floor numbers to the right bar and move to the floor on click.
            for (let i = this.indoorMap.getBuilding().getFloors().length - 1; i >= 0; i--) {
                let floorNumber = (i + 1);
                let floor = this.indoorMap.getBuilding().getFloors()[i];
                let newButton = $("<button id='floor-" + floorNumber + "' type='button' class='btn btn-sm btn-light'>" + floorNumber + "</button>");
                newButton.on("click", () => {
                    this.indoorMap.getBuilding().animateToFloor(floor);
                });
                newButton.appendTo("#floor-bar");
            }
            // 2. Set current floor active
            let currentFloor = this.indoorMap.getBuilding().getCurrentFloor();
            this.setFloorButtonActive(currentFloor, currentFloor);
            // 2. On floor change update the corresponding buttons.
            let that = this;
            this.indoorMap.getBuilding().addFloorObserver({
                floorChanged(floorBefore, floorAfter) {
                    that.setFloorButtonActive(floorBefore, floorAfter);
                }
            });
        }
        setFloorButtonActive(floorBefore, floorAfter) {
            let previousFloorNumber = this.indoorMap.getBuilding().getFloorIndex(floorBefore) + 1;
            let nextFloorNumber = this.indoorMap.getBuilding().getFloorIndex(floorAfter) + 1;
            $("#floor-" + previousFloorNumber).removeClass("active");
            $("#floor-" + nextFloorNumber).addClass("active");
        }
        showView() {
            $("#application").removeClass("d-none");
        }
        // 3. Model synchronization
        startSynchronizingModels() {
            this.startConfigSync();
            let floors = this.indoorMap.getBuilding().getFloors();
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.startFloorDataSync(floor);
            }
        }
        startConfigSync() {
            let intervalDurationInMs = 100;
            setInterval(() => {
                const oldConfigAsJsonString = JSON.stringify(this.config.service);
                this.updateConfig();
                this.subcontroller.updateServiceConfig();
                const newConfigAsJsonString = JSON.stringify(this.config.service);
                if (newConfigAsJsonString !== oldConfigAsJsonString) {
                    this.service.updateConfig(this.config.service);
                }
            }, intervalDurationInMs);
        }
        updateConfig() {
            // Nothing to do
        }
        startFloorDataSync(floor) {
            // Floor name
            let siteName = floor.getFloorName();
            // Devices
            this.startReloadingDevices(siteName);
        }
        // Updating state: devices
        startReloadingDevices(siteName) {
            let intervalDurationInMs = this.subcontroller.getConfig().deviceReloadingIntervalInMs;
            setInterval(() => {
                if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                    this.service.loadDevices(siteName, (deviceModels) => {
                        this.indoorMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
                    });
                }
            }, intervalDurationInMs);
        }
    }
    exports.IndoorApplicationController = IndoorApplicationController;
    class Controller {
        // Construction
        constructor(applicationConfig, service) {
            this.applicationConfig = applicationConfig;
            this.service = service;
        }
        // Identifier
        // Configuration
        getConfig() {
            return new Controller.Config();
        }
        // 1. Event handling: Map initialization
        /**
         * Subclasses should override this method, to override the indoor map options right before
         * the map will be instantiated.
         * @param indoorMapOptions
         */
        overrideMapConfig(indoorMapOptions) {
            for (let i = 0; i < this.getSubcontrollers().length; i++) {
                const subcontroller = this.getSubcontrollers()[i];
                subcontroller.overrideMapConfig(indoorMapOptions);
            }
        }
    }
    exports.Controller = Controller;
    class ApplicationController extends Controller {
        constructor(applicationConfig, service) {
            super(applicationConfig, service);
        }
    }
    exports.ApplicationController = ApplicationController;
    (function (Controller) {
        class Config {
            constructor() {
                this.deviceReloadingIntervalInMs = 100;
                this.geofenceUpdateIntervalInMs = 100;
            }
        }
        Controller.Config = Config;
    })(Controller = exports.Controller || (exports.Controller = {}));
});
define("test/tests/indoor/service/monitoring/MonitoringServiceConfig", ["require", "exports", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, SimulationServiceConfig_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MonitoringServiceConfig extends SimulationServiceConfig_3.ApplicationConfig {
    }
    MonitoringServiceConfig.TYPE_NAME = "monitoring";
    exports.MonitoringServiceConfig = MonitoringServiceConfig;
});
define("test/tests/indoor/service/monitoring/MonitoringService", ["require", "exports", "test/tests/indoor/service/IndoorApplicationService"], function (require, exports, IndoorApplicationService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MonitoringService extends IndoorApplicationService_1.IndoorApplicationService {
        constructor() {
            super();
        }
    }
    exports.MonitoringService = MonitoringService;
});
define("test/tests/indoor/models/simulation/positioning/PositioningSimulationStateModel", ["require", "exports", "test/tests/indoor/models/IndoorStateModel", "src/app/relution/model/Model"], function (require, exports, IndoorStateModel_2, Model_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PositioningSimulationStateModel extends IndoorStateModel_2.IndoorStateModel {
        constructor() {
            super(...arguments);
            /**
             * The index of the current measurement the positioning dataset simulation is pointing to.
             *
             * Default: 0
             */
            this._cursor = 0;
            /**
             * The number of instances in the positioning dataset
             *
             * Default: 0
             */
            this._size = 0;
        }
        // Getters and setters
        set cursor(cursor) {
            this._cursor = cursor;
            this.notifyObservers("cursor");
        }
        get cursor() {
            return this._cursor;
        }
        set size(size) {
            this._size = size;
            this.notifyObservers("size");
        }
        get size() {
            return this._size;
        }
    }
    __decorate([
        Model_14.ModelProperty()
    ], PositioningSimulationStateModel.prototype, "_cursor", void 0);
    __decorate([
        Model_14.ModelProperty()
    ], PositioningSimulationStateModel.prototype, "_size", void 0);
    exports.PositioningSimulationStateModel = PositioningSimulationStateModel;
});
define("test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TrackingSimulationStateModel extends Model_15.Model {
        constructor() {
            super(...arguments);
            this._paused = false;
            this._progress = 0.0;
            this._timeInMs = 0;
        }
        // Getters and setters
        set paused(paused) {
            this._paused = paused;
            this.notifyObservers("paused");
        }
        get paused() {
            return this._paused;
        }
        set progress(progress) {
            this._progress = progress;
            this.notifyObservers("progress");
        }
        get progress() {
            return this._progress;
        }
        set timeInMs(timeInMs) {
            this._timeInMs = timeInMs;
            this.notifyObservers("timeInMs");
        }
        get timeInMs() {
            return this._timeInMs;
        }
    }
    __decorate([
        Model_15.ModelProperty()
    ], TrackingSimulationStateModel.prototype, "_paused", void 0);
    __decorate([
        Model_15.ModelProperty()
    ], TrackingSimulationStateModel.prototype, "_progress", void 0);
    __decorate([
        Model_15.ModelProperty()
    ], TrackingSimulationStateModel.prototype, "_timeInMs", void 0);
    exports.TrackingSimulationStateModel = TrackingSimulationStateModel;
});
define("test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel", ["require", "exports", "src/app/relution/model/Model"], function (require, exports, Model_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TaggingStateModel extends Model_16.Model {
        constructor() {
            super(...arguments);
            this._running = false;
        }
        // Getters and setters
        set running(running) {
            this._running = running;
            this.notifyObservers("running");
        }
        get running() {
            return this._running;
        }
    }
    __decorate([
        Model_16.ModelProperty()
    ], TaggingStateModel.prototype, "_running", void 0);
    exports.TaggingStateModel = TaggingStateModel;
});
define("test/tests/indoor/service/simulation/SimulationService", ["require", "exports", "test/tests/indoor/service/IndoorApplicationService", "test/utils/HttpUtils", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/RelutionMapModelLoader", "src/map/utils/Logger", "src/app/relution/model/geofence/GeofenceModel", "src/app/relution/model/geofence/GeofenceStateModel", "test/tests/indoor/models/DeviceTrackingStateModel", "test/tests/indoor/models/simulation/positioning/PositioningSimulationStateModel", "test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel", "test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel", "test/tests/indoor/models/IndoorStateModel"], function (require, exports, IndoorApplicationService_2, HttpUtils_3, FloorModelLoader_4, DeviceModel_8, RelutionMapModelLoader_4, Logger_12, GeofenceModel_5, GeofenceStateModel_3, DeviceTrackingStateModel_3, PositioningSimulationStateModel_1, TrackingSimulationStateModel_1, TaggingStateModel_1, IndoorStateModel_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SimulationService extends IndoorApplicationService_2.IndoorApplicationService {
        constructor() {
            super();
            this.indoorServerUrl = "http://localhost:4444/indoor";
        }
        // Initialization
        init(config, finishedCallback) {
            const initUrl = this.indoorServerUrl + "/init";
            HttpUtils_3.HttpUtils.postJson(initUrl, config, (response) => {
                const siteNames = response.results[0].info.siteNames;
                const resolvedConfig = response.results[0].config;
                finishedCallback(resolvedConfig, siteNames);
            }, (response) => {
                let text = document.createTextNode(response);
                document.body.appendChild(text);
            });
        }
        // Configuration
        loadConfig(callback) {
            const url = this.indoorServerUrl + "/config";
            HttpUtils_3.HttpUtils.getJson(url, (config) => {
                callback(config);
            });
        }
        updateConfig(configuration) {
            const url = this.indoorServerUrl + "/config";
            HttpUtils_3.HttpUtils.postJson(url, configuration, (resultObject) => {
                // Nothing to do
            });
        }
        // Floor
        loadFloor(siteName, callback) {
            const floorUrl = this.indoorServerUrl + "/site/" + siteName;
            const floorplanUrl = this.indoorServerUrl + "/site/" + siteName + "/floorplan-image";
            const wallplanUrl = this.indoorServerUrl + "/site/" + siteName + "/wallplan-image";
            const taggingPlanUrl = this.indoorServerUrl + "/site/" + siteName + "/taggingplan-image";
            HttpUtils_3.HttpUtils.getJson(floorUrl, (floorObject) => {
                let floorplanOverlayNameToImageUrl = new Map();
                floorplanOverlayNameToImageUrl.set("taggingPlan", taggingPlanUrl);
                let floorModelOptions = {
                    jsonObject: floorObject,
                    pathToFloorplan: floorplanUrl,
                    wallplanUrl: wallplanUrl,
                    floorplanOverlayNameToImageUrl: floorplanOverlayNameToImageUrl,
                    isPortalMode: false,
                };
                let floorModel = FloorModelLoader_4.FloorModelLoader.loadFloor(floorModelOptions);
                callback(floorModel);
            });
        }
        // Devices
        loadDevices(siteName, callback) {
            let devicesUrl = this.indoorServerUrl + "/site/" + siteName + "/devices";
            HttpUtils_3.HttpUtils.getJson(devicesUrl, (devicesObject) => {
                let deviceModels = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_8.DeviceModel, false);
                callback(deviceModels);
            });
        }
        // Devices: state
        loadDeviceStates(siteName, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/state";
            HttpUtils_3.HttpUtils.getJson(url, (resultObject) => {
                if (resultObject["status"] === "success") {
                    let indoorStateArray = resultObject["results"];
                    let indoorStateModels = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModels(indoorStateArray, DeviceTrackingStateModel_3.DeviceTrackingStateModel, false);
                    callback(indoorStateModels);
                }
                else {
                    Logger_12.Logger.logDebug("Updating indoor state not possible.");
                }
            });
        }
        // Devices: probability image
        loadDeviceProbabilityImage(siteName, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/state/probability-image";
            this.loadImage(url, callback);
        }
        // Devices: radio map image
        loadDeviceRadioMapImage(siteName, beaconUuid, callback) {
            const url = this.indoorServerUrl + "/site/" + siteName + "/devices/" + beaconUuid + "/state/radiomap";
            this.loadImage(url, callback);
        }
        loadImage(url, callback) {
            if (url !== null) {
                let image = new Image();
                image.crossOrigin = "anonymous";
                image.onload = () => {
                    callback(image);
                };
                // We add math.random to the end of the url to prevent the browser
                // to load the next image from its cache.
                image.src = "" + url + "?random=" + Math.random();
            }
        }
        // Geofences
        loadGeofences(floorName, callback) {
            const url = this.indoorServerUrl + "/site/" + floorName + "/geofences";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let geofenceModels = new Array();
                if (json !== null) {
                    geofenceModels = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModels(json, GeofenceModel_5.GeofenceModel, false);
                }
                callback(geofenceModels);
            }, (json) => {
                // If geofences are unsupported, just ignore them.
                callback(new Array());
            });
        }
        loadGeofenceStates(floorName, callback) {
            const url = this.indoorServerUrl + "/site/" + floorName + "/geofences/state";
            HttpUtils_3.HttpUtils.getJson(url, (resultObject) => {
                if (resultObject["status"] === "success") {
                    let geofenceStateArray = resultObject["results"];
                    let geofenceStateModels = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModels(geofenceStateArray, GeofenceStateModel_3.GeofenceStateModel, false);
                    callback(geofenceStateModels);
                }
                else {
                    Logger_12.Logger.logDebug("Updating indoor state not possible.");
                }
            });
        }
        // Simulation
        getSimulationState(callback) {
            const url = this.indoorServerUrl + "/simulation/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModel(json, IndoorStateModel_3.IndoorStateModel, false);
                callback(state);
            });
        }
        startCalibration(calibrateWithValidationData) {
            const url = this.indoorServerUrl + "/simulation/calibration/start";
            let payload = {
                calibrateWithValidationData: calibrateWithValidationData
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (r) => { });
        }
        stopCalibration() {
            const url = this.indoorServerUrl + "/simulation/calibration/stop";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        // Positioning simulation
        setPositioningDatasetCursor(floorName, cursor, callback) {
            const url = this.indoorServerUrl + "/positioning/site/" + floorName + "/cursor";
            let payload = {
                "cursor": cursor
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (resultObject) => {
                if (callback !== undefined) {
                    callback();
                }
            });
        }
        getPositioningSimulationState(floorName, callback) {
            const url = this.indoorServerUrl + "/positioning/site/" + floorName + "/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModel(json, PositioningSimulationStateModel_1.PositioningSimulationStateModel, false);
                callback(state);
            });
        }
        // Tracking simulation
        startTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/start";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        stopTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/stop";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        restartTrackingSimulation() {
            const startUrl = this.indoorServerUrl + "/tracking/start";
            const stopUrl = this.indoorServerUrl + "/tracking/stop";
            HttpUtils_3.HttpUtils.getJson(stopUrl, (responseObject) => {
                HttpUtils_3.HttpUtils.getJson(startUrl, (responseObject) => { });
            });
        }
        pauseTrackingSimulation() {
            const url = this.indoorServerUrl + "/tracking/pause";
            HttpUtils_3.HttpUtils.getJson(url, (responseObject) => { });
        }
        setTrackingSimulationProgress(progress, callback) {
            const url = this.indoorServerUrl + "/tracking/progress";
            let payload = {
                "progress": progress
            };
            HttpUtils_3.HttpUtils.postJson(url, payload, (resultObject) => {
                if (callback !== undefined) {
                    callback();
                }
            });
        }
        getTrackingSimulationState(callback) {
            const url = this.indoorServerUrl + "/tracking/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModel(json, TrackingSimulationStateModel_1.TrackingSimulationStateModel, false);
                callback(state);
            });
        }
        // Asset tracking: mouse simulation
        sendTargetState(positionObject) {
            const url = this.indoorServerUrl + "/assettracking/mouse/target-state";
            HttpUtils_3.HttpUtils.postJson(url, positionObject, (r) => { });
        }
        // Asset tracking: dataset tagging simulation
        startTagging() {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/start";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        stopTagging() {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/stop";
            HttpUtils_3.HttpUtils.postJson(url, {}, (r) => { });
        }
        sendTaggingData(payload) {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/data";
            HttpUtils_3.HttpUtils.postJson(url, payload, (r) => { });
        }
        getTaggingState(callback) {
            const url = this.indoorServerUrl + "/assettracking/dataset/tagging/state";
            HttpUtils_3.HttpUtils.getJson(url, (json) => {
                let state = RelutionMapModelLoader_4.RelutionMapModelLoader.loadModel(json, TaggingStateModel_1.TaggingStateModel, false);
                callback(state);
            });
        }
    }
    exports.SimulationService = SimulationService;
});
define("test/tests/indoor/controller/monitoring/MonitoringController", ["require", "exports", "test/tests/indoor/IndoorApplicationController"], function (require, exports, IndoorApplicationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MonitoringController extends IndoorApplicationController_1.ApplicationController {
        // Construction
        constructor(config, service) {
            super(config, service);
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // Identifier
        // @Override
        getId() {
            return "#monitoring-tabbar-item";
        }
        // Configuration
        // @Override
        getConfig() {
            let config = new IndoorApplicationController_1.Controller.Config();
            config.deviceReloadingIntervalInMs = 1000;
            config.geofenceUpdateIntervalInMs = 1000;
            return config;
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.startSynchronizingModels();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // Nothing to do
        }
    }
    exports.MonitoringController = MonitoringController;
});
define("test/tests/indoor/IndoorApplicationView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorApplicationView {
    }
    exports.IndoorApplicationView = IndoorApplicationView;
    class View {
        constructor(config) {
            this.config = config;
        }
    }
    exports.View = View;
});
define("test/tests/indoor/controller/simulation/SimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView", "test/tests/indoor/service/simulation/SimulationServiceConfig"], function (require, exports, IndoorApplicationView_1, SimulationServiceConfig_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SimulationView extends IndoorApplicationView_1.View {
        // Construction
        constructor(config) {
            super(config);
            this.simulationFormArea = `
        <form id="simulation-mode-form" action="" class="form-inline" method="get" style="width: 100%">
            <div id="simulation-mode-form-group" class="form-group" style="width: 100%">
                <div class="col">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Dataset</small>
                        </legend>
                        <div class="control-group" style="width: 100%">
                            <div id="dataset-area" class="row align-items-center" style="padding:3px">
                                <div class="col-sm-auto">
                                    Name:
                                </div>
                                <div class="col">
                                    <input id="asset-tracking-dataset" class="form-control form-control-sm" type="text" autocomplete="off"
                                    placeholder="Dataset name" style="width: 100%">
                                </div>
                            </div>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Positioning</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-positioning-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Asset tracking</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-tracking-integration-asset-mouse-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Mouse sim.
                            </button>
                            <button id="sim-tracking-integration-asset-dataset-button" class="btn btn-sm btn-light" data-toggle="button" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
                <div class="col-sm-auto">
                    <fieldset class="scheduler-border">
                        <legend class="scheduler-border">
                            <small>Beacon tracking</small>
                        </legend>
                        <div class="control-group align-items-center" style="margin-top: 4.5px; margin-bottom: 4.5px">
                            <button id="sim-tracking-integration-beacon-dataset-button" class="btn btn-sm btn-light" data-toggle="button" value="beacon-d-validation" type="button">
                                Dataset sim.
                            </button>
                        </div>
                    </fieldset>
                </div>
            </div>
        </form>
    `;
            this.leftSideBarArea = `
        <div id="custom-left-side-bar-items">
        </div>
        <div id="general-left-side-bar-items">
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Render probability density map:
                <br>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" name="renderProbabilityDensity" id="renderProbabilityDensity">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Render radio map:
                <br>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" name="renderRadioMap" id="renderRadioMap">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
            <li class="list-group-item asset-mouse-sim asset-dataset-sim bg-light">
                Calibrate with validation dataset:
                <br>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" name="calibrateWithValidationData" id="calibrateWithValidationData" checked>
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </li>
        </div>
        <li class="list-group-item bg-light">
            <!-- Placeholder -->
        </li>
    `;
            this.centerTopArea = `
        <div class="col-sm-auto">
            <div id="player" class="btn-group">
            </div>
        </div>
        <div id="player-progress-area" class="col">
        </div>
    `;
        }
        // Initialization
        init() {
            this.initActionBar();
            this.initSimulationForm();
            this.initLeftSideBar();
            this.initCenterTopArea();
        }
        initActionBar() {
            $("#floor-taggingplan-action-area").removeClass("d-none");
        }
        // Initialization: Simulation form
        initSimulationForm() {
            this.insertSimulationForm();
            this.fillSimulationForm();
        }
        insertSimulationForm() {
            $("#top-area").html(this.simulationFormArea);
        }
        fillSimulationForm() {
            let applicationConfig = this.config.service.application;
            let assetTrackingSimulationConfig = applicationConfig.simulation;
            const datasetName = assetTrackingSimulationConfig.dataset;
            $("#asset-tracking-dataset").attr("value", datasetName);
            this.toggleActiveSimulationModeButton();
        }
        toggleActiveSimulationModeButton() {
            let applicationConfig = this.config.service.application;
            if (applicationConfig.simulation.type == SimulationServiceConfig_4.AssetTrackingSimulationConfig.TYPE_NAME) {
                let assetTrackingSimulationConfig = applicationConfig.simulation;
                if (assetTrackingSimulationConfig.mode.type === SimulationServiceConfig_4.AssetTrackingMouseSimulationModeConfig.TYPE_NAME) {
                    $("#sim-tracking-integration-asset-mouse-button").addClass("active");
                }
                else if (assetTrackingSimulationConfig.mode.type === SimulationServiceConfig_4.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME) {
                    $("#sim-tracking-integration-asset-dataset-button").addClass("active");
                }
            }
            else if (applicationConfig.simulation.type == SimulationServiceConfig_4.BeaconTrackingSimulationConfig.TYPE_NAME) {
                $("#sim-tracking-integration-beacon-dataset-button").addClass("active");
            }
            else if (applicationConfig.simulation.type == SimulationServiceConfig_4.PositioningSimulationConfig.TYPE_NAME) {
                $("#sim-positioning-button").addClass("active");
            }
        }
        // Initialization: Left side bar
        initLeftSideBar() {
            this.insertLeftSideBar();
            this.fillLeftSideBar();
        }
        insertLeftSideBar() {
            $("#left-area").html(this.leftSideBarArea);
        }
        fillLeftSideBar() {
            // 1. Update own config properties
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            $("#renderProbabilityDensity").prop("checked", assetTrackingConfig.renderProbabilityDensityMap);
            $("#renderRadioMap").prop("checked", assetTrackingConfig.renderRadioMap);
            $("#calibrateWithValidationData").prop("checked", assetTrackingConfig.useValidationDatasetForCalibration);
        }
        // Initialization: Center area
        initCenterTopArea() {
            $("#center-top-area").html(this.centerTopArea);
        }
    }
    exports.SimulationView = SimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/TrackingSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TrackingSimulationView extends IndoorApplicationView_2.View {
        // Construction
        constructor(config) {
            super(config);
            this.datasetAreaExtensions = `
        <div class="col-sm-auto">
            Device:
        </div>
        <div class="col-sm-auto">
            <input id="deviceId" class="form-control form-control-sm" type="text" autocomplete="off" placeholder="Serial number">
        </div>
    `;
            this.customLeftSideBarItems = `
        <li class="list-group-item asset-dataset-sim beacon-dataset-sim bg-light">
            Simulate with max. speed:
            <br>
            <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                <input type="checkbox" class="switch-input" checked name="simulateWithMaxSpeed" id="simulateWithMaxSpeed">
                <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
        <li class="list-group-item asset-dataset-sim beacon-dataset-sim bg-light">
            Simulation speed:
            <span id="timeExpansionFactorSliderValue">1</span>x
            <br>
            <input id="timeExpansionFactorSlider" data-slider-id='ex1Slider' type="text" data-slider-min="0.1" data-slider-max="1000"
            data-slider-step="0.1" data-slider-value="1" style="width: 100%" />
        </li>
    `;
            this.playerButtons = `
        <button id="sim-record" class="btn btn-light d-none" href="#">
            <i id="sim-record-icon" class="fas fa-circle"></i>
        </button>
        <button id="sim-calibrate" class="btn btn-light d-none" href="#">
            <img id="sim-calibrate-icon" src="../../img/calibration.svg" width="20" />
        </button>
        <button id="sim-play-pause" class="btn btn-light" href="#">
            <i id="sim-play-pause-icon" class="fas fa-play"></i>
        </button>
        <button id="sim-stop" class="btn btn-light" href="#">
            <i id="sim-stop-icon" class="fas fa-stop"></i>
        </button>
        <button id="sim-replay" class="btn btn-light" href="#">
            <img id="sim-replay-icon" src="../../img/refresh.svg" width="20" />
        </button>
    `;
            this.playerProgressArea = `
        <div id="progress-line" class="progress" style="height: 20px;">
            <div id="sim-progress" class="progress-bar bg-secondary" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            <p id="sim-progress-value" class="unselectable justify-content-center d-flex position-absolute w-100"></p>
        </div>
        <input id="progress-slider" class="d-none" data-slider-id='progress-slider' type="text" data-slider-min="0" data-slider-max="100"
            data-slider-step="0.1" data-slider-value="0" style="width: 100%"/>
    `;
        }
        // @Override
        init() {
            this.initSimulationForm();
            this.initLeftSideBar();
            this.initPlayerItems();
        }
        initSimulationForm() {
            this.insertSimulationForm();
            this.fillSimulationForm();
        }
        insertSimulationForm() {
            let previousHtmlContent = $("#dataset-area").html();
            $("#dataset-area").html(previousHtmlContent + this.datasetAreaExtensions);
        }
        fillSimulationForm() {
            let applicationConfig = this.config.service.application;
            let trackingSimulationConfig = applicationConfig.simulation;
            const deviceId = trackingSimulationConfig.deviceSerial;
            $("#deviceId").attr("value", deviceId);
        }
        initLeftSideBar() {
            this.insertItemsIntoLeftSideBar();
            this.initLeftSideBarItems();
        }
        insertItemsIntoLeftSideBar() {
            let previousHtmlContent = $("#custom-left-side-bar-items").html();
            $("#custom-left-side-bar-items").html(this.customLeftSideBarItems + previousHtmlContent);
        }
        initLeftSideBarItems() {
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            document.getElementById("simulateWithMaxSpeed").checked = assetTrackingConfig.simulateWithMaxSpeed;
            this.initTimeExpansionFactorSlider();
        }
        initTimeExpansionFactorSlider() {
            // Time expansion factor slider
            window.timeExpansionFactorSlider = new Slider("#timeExpansionFactorSlider", {
                formatter: function (value) {
                    return "" + value;
                },
                scale: 'logarithmic'
            });
            window.timeExpansionFactorSlider.on("slide", function (sliderValue) {
                $("#timeExpansionFactorSliderValue").text(sliderValue);
            });
            // Initial value
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            document.getElementById("timeExpansionFactorSlider").value = "" + assetTrackingConfig.simulationSpeed;
        }
        initPlayerItems() {
            $("#player").html(this.playerButtons);
            $("#player-progress-area").html(this.playerProgressArea);
        }
    }
    exports.TrackingSimulationView = TrackingSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationView", "test/tests/indoor/models/simulation/tracking/TrackingSimulationStateModel"], function (require, exports, IndoorApplicationController_2, TrackingSimulationView_1, TrackingSimulationStateModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TrackingSimulationController extends IndoorApplicationController_2.Controller {
        // Construction
        constructor(applicationConfig, simulatorService, state) {
            super(applicationConfig, simulatorService);
            this.state = state;
            this.trackingState = new TrackingSimulationStateModel_2.TrackingSimulationStateModel();
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.view = new TrackingSimulationView_1.TrackingSimulationView(this.applicationConfig);
            this.view.init();
            this.registerPlayerButtonEvents();
            this.startModelSynchronization();
        }
        registerPlayerButtonEvents() {
            this.registerCalibrateButton();
            this.registerPlayButton();
            this.registerStopButton();
            this.registerReplayButton();
            this.syncPlayerBarWithSimulationState();
        }
        registerCalibrateButton() {
            $("#sim-calibrate").on("click", () => {
                const calibrateWithValidationData = $("#calibrateWithValidationData").prop("checked");
                this.service.startCalibration(calibrateWithValidationData);
            });
        }
        registerPlayButton() {
            $("#sim-play-pause").on("click", () => {
                let playResumeElement = $("#sim-play-pause-icon");
                if (playResumeElement.hasClass("fa-play")) {
                    this.service.startTrackingSimulation();
                }
                else {
                    this.service.pauseTrackingSimulation();
                }
            });
        }
        registerStopButton() {
            $("#sim-stop").on("click", () => {
                this.service.stopTrackingSimulation();
            });
        }
        registerReplayButton() {
            $("#sim-replay").on("click", () => {
                this.service.restartTrackingSimulation();
            });
        }
        syncPlayerBarWithSimulationState() {
            setInterval(() => {
                this.service.getTrackingSimulationState((trackingState) => {
                    this.trackingState.update(trackingState);
                    // 1. Play/Pause button
                    if (!this.state.running) {
                        this.toggleToPlayButton();
                    }
                    else {
                        if (trackingState.paused) {
                            this.toggleToPlayButton();
                        }
                        else {
                            this.toggleToPauseButton();
                        }
                    }
                    // 2. Stop button
                    if (this.state.running) {
                        this.enableStopButton();
                    }
                    else {
                        this.disableStopButton();
                    }
                    // 3. Progress bar
                    let progressInPercent = trackingState.progress * 100;
                    this.setSimulationProgressBar(progressInPercent, trackingState.timeInMs);
                });
            }, 100);
        }
        toggleToPlayButton() {
            let playResumeElement = $("#sim-play-pause-icon");
            playResumeElement.addClass("fa-play");
            playResumeElement.removeClass("fa-pause");
        }
        toggleToPauseButton() {
            let playResumeElement = $("#sim-play-pause-icon");
            playResumeElement.addClass("fa-pause");
            playResumeElement.removeClass("fa-play");
        }
        enableStopButton() {
            $("#sim-stop").removeAttr("disabled");
        }
        disableStopButton() {
            $("#sim-stop").prop("disabled", true);
        }
        setSimulationProgressBar(progressInPercent, timeInMs) {
            let simProgressTag = $("#sim-progress");
            let simProgressValueTag = $("#sim-progress-value");
            // Disable progress animation when moving to 0%
            let transitionValue = "all 0.1s ease";
            if (progressInPercent === 0) {
                transitionValue = "none";
            }
            simProgressTag.css("transition", transitionValue);
            // Progress
            simProgressTag.css("width", progressInPercent + "%").attr("aria-valuenow", progressInPercent);
            // Progress value
            if (timeInMs === 0) {
                simProgressValueTag.html("");
            }
            else {
                const date = new Date(timeInMs);
                const timeString = date.toLocaleString();
                simProgressValueTag.html("" + timeString);
            }
            // Progress value color
            let color = "black";
            if (progressInPercent > 50) {
                color = "white";
            }
            simProgressValueTag.css("color", color);
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            assetTrackingConfig.simulateWithMaxSpeed = document.getElementById("simulateWithMaxSpeed").checked;
            assetTrackingConfig.simulationSpeed = Number.parseFloat(document.getElementById("timeExpansionFactorSlider").value);
        }
    }
    exports.TrackingSimulationController = TrackingSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AssetTrackingMouseSimulationView extends IndoorApplicationView_3.View {
        // Construction
        constructor(config) {
            super(config);
            this.customLeftSideBarItems = `
        <li class="list-group-item asset-mouse-sim bg-light">
            Speed measurements:
            <br>
            <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                <input type="checkbox" class="switch-input" checked name="simulateWithSpeedMeasurements" id="simulateWithSpeedMeasurements">
                <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
        <li class="list-group-item asset-mouse-sim bg-light">
            Direction measurements:
            <br>
            <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                <input type="checkbox" class="switch-input" name="simulateWithDirectionMeasurements" id="simulateWithDirectionMeasurements">
                <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
            </label>
        </li>
    `;
        }
        // @Override
        init() {
            this.initLeftBar();
        }
        initLeftBar() {
            this.insertItemsIntoLeftSideBar();
            this.initLeftSideBar();
        }
        insertItemsIntoLeftSideBar() {
            let previousHtmlContent = $("#custom-left-side-bar-items").html();
            $("#custom-left-side-bar-items").html(this.customLeftSideBarItems + previousHtmlContent);
        }
        initLeftSideBar() {
            let applicationConfig = this.config.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            let mouseConfig = assetTrackingConfig.mode;
            $("#simulateWithSpeedMeasurements").prop("checked", mouseConfig.simulateSpeed);
            $("#simulateWithDirectionMeasurements").prop("checked", mouseConfig.simulateDirection);
        }
    }
    exports.AssetTrackingMouseSimulationView = AssetTrackingMouseSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationController", ["require", "exports", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationView"], function (require, exports, TrackingSimulationController_1, AssetTrackingMouseSimulationView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AssetTrackingMouseSimulationController extends TrackingSimulationController_1.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.assetTrackingMouseSimulationView = new AssetTrackingMouseSimulationView_1.AssetTrackingMouseSimulationView(this.applicationConfig);
            this.assetTrackingMouseSimulationView.init();
            this.startModelSynchronization();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            this.startSendingFakePosition();
        }
        startSendingFakePosition() {
            setInterval(() => {
                let targetPositionInWorldCm = this.indoorMap.getTargetPositionInWorldCm();
                let targetOrientationInRad = this.indoorMap.getTargetOrientationInRad();
                let floorName = this.indoorMap.getNearestFloorName();
                let speedEnabled = $("#simulateWithSpeedMeasurements").prop("checked");
                let directionEnabled = $("#simulateWithDirectionMeasurements").prop("checked");
                let positionObject = {
                    position: { x: targetPositionInWorldCm.x, y: targetPositionInWorldCm.y, z: 0 },
                    orientation: targetOrientationInRad,
                    regionId: floorName,
                    speedEnabled: speedEnabled,
                    directionEnabled: directionEnabled
                };
                this.service.sendTargetState(positionObject);
            }, 16);
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            let mouseConfig = assetTrackingConfig.mode;
            mouseConfig.simulateSpeed = $("#simulateWithSpeedMeasurements").prop("checked");
            mouseConfig.simulateDirection = $("#simulateWithDirectionMeasurements").prop("checked");
        }
    }
    exports.AssetTrackingMouseSimulationController = AssetTrackingMouseSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AssetTrackingDatasetSimulationView extends IndoorApplicationView_4.View {
        // Construction
        constructor(config) {
            super(config);
        }
        // @Override
        init() {
            this.initLeftBar();
            this.initTaggingViews();
        }
        initLeftBar() {
            $(".asset-dataset-sim").removeClass("d-none");
        }
        initTaggingViews() {
            this.initRecordButton();
            this.initCalibrateButton();
            this.initProgressSlider();
        }
        initRecordButton() {
            $("#sim-record").removeClass("d-none");
        }
        initCalibrateButton() {
            $("#sim-calibrate").removeClass("d-none");
        }
        initProgressSlider() {
            this.progressSlider = new Slider("#progress-slider", {
                formatter: function (value) {
                    return "" + value;
                }
            });
            // Hide the progress slider by default.
            $("#progress-slider").addClass("d-none");
        }
        // Getters and setters
        getProgressSlider() {
            return this.progressSlider;
        }
    }
    exports.AssetTrackingDatasetSimulationView = AssetTrackingDatasetSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationController", ["require", "exports", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationView", "test/tests/indoor/models/simulation/tracking/asset/TaggingStateModel"], function (require, exports, IndoorMap_2, TrackingSimulationController_2, AssetTrackingDatasetSimulationView_1, TaggingStateModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AssetTrackingDatasetSimulationController extends TrackingSimulationController_2.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
            // State
            this.taggingState = new TaggingStateModel_2.TaggingStateModel();
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.assetTrackingSimulationView = new AssetTrackingDatasetSimulationView_1.AssetTrackingDatasetSimulationView(this.applicationConfig);
            this.assetTrackingSimulationView.init();
            this.continuouslyUpdateView();
            this.startModelSynchronization();
            initializationCallback();
        }
        continuouslyUpdateView() {
            this.updateProgressSlider();
            this.updateTaggingButton();
        }
        updateProgressSlider() {
            let sliding = false;
            this.assetTrackingSimulationView.getProgressSlider().on("slideStart", () => {
                sliding = true;
            });
            this.assetTrackingSimulationView.getProgressSlider().on("slideStop", () => {
                let sliderValue = this.assetTrackingSimulationView.getProgressSlider().getValue();
                this.service.pauseTrackingSimulation();
                this.service.setTrackingSimulationProgress(sliderValue / 100);
                setTimeout(() => {
                    sliding = false;
                }, 2000);
            });
            setInterval(() => {
                if (!sliding) {
                    let progressInPercent = this.trackingState.progress * 100;
                    this.assetTrackingSimulationView.getProgressSlider().setValue(progressInPercent, false, false);
                }
            }, 10);
        }
        updateTaggingButton() {
            $("#sim-record").on("click", () => {
                if (this.taggingState.running) {
                    this.service.stopTagging();
                }
                else {
                    this.service.startTagging();
                }
            });
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            this.startLoadingTaggingState();
            this.startPublishingTaggingData();
        }
        startLoadingTaggingState() {
            setInterval(() => {
                this.service.getTaggingState((taggingState) => {
                    this.taggingState.update(taggingState);
                    if (this.taggingState.running) {
                        $("#sim-record-icon").css("color", "darkred");
                        if (!(this.indoorMap.getType() instanceof IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType)) {
                            this.indoorMap.setType(new IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetTaggingSimulationType());
                        }
                    }
                    else {
                        $("#sim-record-icon").css("color", "black");
                        if (!(this.indoorMap.getType() instanceof IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType)) {
                            this.indoorMap.setType(new IndoorMap_2.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType());
                        }
                    }
                    this.updateProgressSliderState();
                });
            }, 16);
        }
        updateProgressSliderState() {
            if (this.taggingState.running) {
                $("#progress-slider").removeClass("d-none");
                $("#progress-line").addClass("d-none");
            }
            else {
                $("#progress-slider").addClass("d-none");
                $("#progress-line").removeClass("d-none");
            }
        }
        startPublishingTaggingData() {
            setInterval(() => {
                if (this.taggingState.running) {
                    let positions = this.indoorMap.pullTaggingData();
                    if (positions.length > 0) {
                        let timestamps = this.indoorMap.pullTimestampData();
                        let floorName = this.indoorMap.getNearestFloorName();
                        let applicationConfig = this.applicationConfig.service.application;
                        let simulation = applicationConfig.simulation;
                        let deviceId = simulation.deviceSerial;
                        let payload = {
                            datasetName: floorName,
                            deviceId: deviceId,
                            positions: positions,
                            timestamps: timestamps
                        };
                        this.service.sendTaggingData(payload);
                    }
                }
            }, 16);
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
        }
    }
    exports.AssetTrackingDatasetSimulationController = AssetTrackingDatasetSimulationController;
});
define("test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconTrackingSimulationView extends IndoorApplicationView_5.View {
        // Construction
        constructor(config) {
            super(config);
        }
        // @Override
        init() {
            this.initLeftBar();
        }
        initLeftBar() {
            $(".beacon-dataset-sim").removeClass("d-none");
        }
    }
    exports.BeaconTrackingSimulationView = BeaconTrackingSimulationView;
});
define("test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationController", ["require", "exports", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "test/tests/indoor/controller/simulation/tracking/TrackingSimulationController", "test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationView"], function (require, exports, Beacon_12, Asset_9, TrackingSimulationController_3, BeaconTrackingSimulationView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class BeaconTrackingSimulationController extends TrackingSimulationController_3.TrackingSimulationController {
        // Construction
        constructor(simulatorConfig, simulatorService, state) {
            super(simulatorConfig, simulatorService, state);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            super.init(indoorMap, initializationCallback);
            this.beaconTrackingSimulationView = new BeaconTrackingSimulationView_1.BeaconTrackingSimulationView(this.applicationConfig);
            this.beaconTrackingSimulationView.init();
            this.indoorMap.getBuilding().toggleRelutionMapObjectTypeVisibility(Beacon_12.Beacon.name, true);
            this.indoorMap.getBuilding().toggleRelutionMapObjectTypeVisibility(Asset_9.Asset.name, false);
            this.startModelSynchronization();
            initializationCallback();
        }
        // 2. Event handling: Model synchronization
        // @Override
        startModelSynchronization() {
            // Nothing to do
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            super.updateServiceConfig();
        }
    }
    exports.BeaconTrackingSimulationController = BeaconTrackingSimulationController;
});
define("test/tests/indoor/controller/simulation/positioning/PositioningSimulationView", ["require", "exports", "test/tests/indoor/IndoorApplicationView"], function (require, exports, IndoorApplicationView_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PositioningSimulationView extends IndoorApplicationView_6.View {
        // Construction
        constructor(config) {
            super(config);
            this.playerButtons = `
        <button id="sim-calibrate" class="btn btn-light" href="#">
            <img id="sim-calibrate-icon" src="../../img/calibration.svg" width="20" />
        </button>
        <button id="sim-step-backward" class="btn btn-light" href="#">
            <i id="sim-step-backward-icon" class="fas fa-step-backward"></i>
        </button>
        <button id="sim-step-forward" class="btn btn-light" href="#">
            <i id="sim-step-forward-icon" class="fas fa-step-forward"></i>
        </button>
    `;
            this.playerProgressArea = `
        <input id="cursor-slider" class="" data-slider-id='cursor-slider' type="text" data-slider-min="0" data-slider-max="1"
            data-slider-step="1" data-slider-value="0" style="width: 100%"/>
    `;
        }
        // @Override
        init() {
            this.initLeftSideBar();
            this.initPlayerItems();
            this.initCursorSlider();
        }
        initLeftSideBar() {
            // Calibration should always be done using the training data and not using validation data.
            $("#calibrateWithValidationData").prop("checked", false);
        }
        initPlayerItems() {
            $("#player").html(this.playerButtons);
            $("#player-progress-area").html(this.playerProgressArea);
        }
        initCursorSlider() {
            this.cursorSlider = new Slider("#cursor-slider", {
                formatter: function (value) {
                    return "" + value;
                }
            });
        }
        // Getters and setters
        getCursorSlider() {
            return this.cursorSlider;
        }
    }
    exports.PositioningSimulationView = PositioningSimulationView;
});
define("test/tests/indoor/controller/simulation/positioning/PositioningSimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/controller/simulation/positioning/PositioningSimulationView", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon"], function (require, exports, IndoorApplicationController_3, PositioningSimulationView_1, Beacon_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class PositioningSimulationController extends IndoorApplicationController_3.Controller {
        // Construction
        constructor(applicationConfig, simulatorService) {
            super(applicationConfig, simulatorService);
            this.sliding = false;
            this.states = new Map();
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [];
        }
        // Configuration
        getConfig() {
            return new IndoorApplicationController_3.Controller.Config();
        }
        // @Override
        overrideMapConfig(indoorMapOptions) {
            super.overrideMapConfig(indoorMapOptions);
            indoorMapOptions.world.building.objectTypeVisibilities.set(Beacon_13.Beacon.name, true);
        }
        // 1. Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.map = indoorMap;
            this.view = new PositioningSimulationView_1.PositioningSimulationView(this.applicationConfig);
            this.view.init();
            this.registerInputEvents();
            this.startSynchronizingModels();
            initializationCallback();
        }
        registerInputEvents() {
            this.registerCalibrateButtonEvents();
            this.registerStepForwardEvents();
            this.registerStepBackwardEvents();
            this.registerCursorSliderEvents();
        }
        registerCalibrateButtonEvents() {
            $("#sim-calibrate").on("click", () => {
                const calibrateWithValidationData = $("#calibrateWithValidationData").prop("checked");
                this.service.startCalibration(calibrateWithValidationData);
            });
        }
        registerStepBackwardEvents() {
            $("#sim-step-backward").on("click", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let state = this.states.get(floorName);
                    let newCursor = Math.max(state.cursor - 1, 0);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
            });
        }
        registerStepForwardEvents() {
            $("#sim-step-forward").on("click", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let state = this.states.get(floorName);
                    let newCursor = Math.min(state.cursor + 1, state.size - 1);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
            });
        }
        registerCursorSliderEvents() {
            this.sliding = false;
            this.view.getCursorSlider().on("slideStart", () => {
                this.sliding = true;
            });
            this.view.getCursorSlider().on("slideStop", () => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                if (this.states.has(floorName)) {
                    let sliderValue = this.view.getCursorSlider().getValue();
                    let newCursor = Math.floor(sliderValue);
                    this.service.setPositioningDatasetCursor(floorName, newCursor);
                }
                setTimeout(() => {
                    this.sliding = false;
                }, 2000);
            });
        }
        // 2. Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            this.continuouslyLoadStateModel();
        }
        continuouslyLoadStateModel() {
            setInterval(() => {
                let floorName = this.map.getBuilding().getCurrentFloor().getFloorName();
                this.service.getPositioningSimulationState(floorName, (state) => {
                    this.states.set(floorName, state);
                    this.syncSliderWithState(state);
                });
            }, 100);
        }
        syncSliderWithState(state) {
            if (!this.sliding) {
                this.setCursorSliderAttributeToValue("min", 0);
                this.setCursorSliderAttributeToValue("max", state.size);
                this.view.getCursorSlider().setValue(state.cursor);
                this.registerCursorSliderEvents();
            }
        }
        setCursorSliderAttributeToValue(attributeName, value) {
            if (this.view.getCursorSlider().getAttribute(attributeName) !== value) {
                this.view.getCursorSlider().setAttribute(attributeName, value);
                this.view.getCursorSlider().refresh();
                this.registerCursorSliderEvents();
            }
        }
        // 3. Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // Nothing to do
        }
    }
    exports.PositioningSimulationController = PositioningSimulationController;
});
define("test/tests/indoor/controller/simulation/SimulationController", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/IndoorApplication", "src/engine/input/GestureRecognizer", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/simulation/SimulationServiceConfig", "test/tests/indoor/controller/simulation/SimulationView", "test/tests/indoor/models/IndoorStateModel", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingMouseSimulationController", "test/tests/indoor/controller/simulation/tracking/asset/AssetTrackingDatasetSimulationController", "test/tests/indoor/controller/simulation/tracking/beacon/BeaconTrackingSimulationController", "test/tests/indoor/controller/simulation/positioning/PositioningSimulationController"], function (require, exports, IndoorApplicationController_4, IndoorApplication_2, GestureRecognizer_11, Beacon_14, IndoorMap_3, SimulationServiceConfig_5, SimulationView_1, IndoorStateModel_4, AssetTrackingMouseSimulationController_1, AssetTrackingDatasetSimulationController_1, BeaconTrackingSimulationController_1, PositioningSimulationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SimulationController extends IndoorApplicationController_4.ApplicationController {
        // Construction
        constructor(config, service) {
            super(config, service);
            // State
            this.state = new IndoorStateModel_4.IndoorStateModel();
            this.initSubcontroller();
        }
        initSubcontroller() {
            let indoorMapType = IndoorApplication_2.IndoorApplication.Config.getIndoorMapType(this.applicationConfig);
            if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetMouseSimulationType) {
                this.subcontroller = new AssetTrackingMouseSimulationController_1.AssetTrackingMouseSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType) {
                this.subcontroller = new AssetTrackingDatasetSimulationController_1.AssetTrackingDatasetSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.AssetTrackingDatasetBeaconSimulationType) {
                this.subcontroller = new BeaconTrackingSimulationController_1.BeaconTrackingSimulationController(this.applicationConfig, this.service, this.state);
            }
            else if (indoorMapType instanceof IndoorMap_3.IndoorMap.Type.PositioningDatasetSimulationType) {
                this.subcontroller = new PositioningSimulationController_1.PositioningSimulationController(this.applicationConfig, this.service);
            }
            else {
                throw new Error("No simulation controller for simulation type = " + indoorMapType);
            }
        }
        // Subcontrollers
        // @Override
        getSubcontrollers() {
            return [this.subcontroller];
        }
        // Identifier
        // @Override
        getId() {
            return "#simulation-tabbar-item";
        }
        // Event handling: View initialization
        // @Override
        init(indoorMap, initializationCallback) {
            this.indoorMap = indoorMap;
            this.initDomElements();
            this.continuouslyUpdateView();
            this.subcontroller.init(indoorMap, () => {
                this.startSynchronizingModels();
                initializationCallback();
            });
        }
        initDomElements() {
            this.view = new SimulationView_1.SimulationView(this.applicationConfig);
            this.view.init();
        }
        // View synchronization
        continuouslyUpdateView() {
            this.registerSimulationModeFormEvents();
        }
        registerSimulationModeFormEvents() {
            // Submit form
            var that = this;
            $("#sim-tracking-integration-asset-mouse-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-tracking-integration-asset-dataset-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-tracking-integration-beacon-dataset-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
            $("#sim-positioning-button").click(function () {
                that.submitSimulationForm($(this).attr("id"));
            });
        }
        submitSimulationForm(mode) {
            let applicationConfig = this.applicationConfig.service.application;
            // Simulation configuration
            if (mode.indexOf("-tracking") >= 0) {
                if (mode.indexOf("-beacon") >= 0) {
                    applicationConfig.simulation.type = SimulationServiceConfig_5.BeaconTrackingSimulationConfig.TYPE_NAME;
                    applicationConfig.simulation = new SimulationServiceConfig_5.BeaconTrackingSimulationConfig();
                }
                else if (mode.indexOf("-asset") >= 0) {
                    applicationConfig.simulation.type = SimulationServiceConfig_5.AssetTrackingSimulationConfig.TYPE_NAME;
                    applicationConfig.simulation = new SimulationServiceConfig_5.AssetTrackingSimulationConfig();
                    let assetTrackingSimulationConfig = applicationConfig.simulation;
                    if (mode.indexOf("-mouse") >= 0) {
                        assetTrackingSimulationConfig.mode.type = SimulationServiceConfig_5.AssetTrackingMouseSimulationModeConfig.TYPE_NAME;
                    }
                    else if (mode.indexOf("-dataset") >= 0) {
                        assetTrackingSimulationConfig.mode.type = SimulationServiceConfig_5.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME;
                    }
                }
                let trackingSimulation = applicationConfig.simulation;
                trackingSimulation.deviceSerial = $("#deviceId").val();
            }
            else if (mode.indexOf("-positioning")) {
                applicationConfig.simulation.type = SimulationServiceConfig_5.PositioningSimulationConfig.TYPE_NAME;
            }
            applicationConfig.simulation.dataset = $("#asset-tracking-dataset").val();
            // Add config as hidden input field
            this.addHiddenInputFieldToSimulationModeForm("config", JSON.stringify(this.applicationConfig));
            // Reload page
            $("#simulation-mode-form").submit();
        }
        addHiddenInputFieldToSimulationModeForm(key, value) {
            let inputElement = $("<input></input>");
            inputElement.attr("name", key);
            inputElement.attr("id", key);
            inputElement.attr("value", value);
            inputElement.attr("type", "hidden");
            inputElement.addClass("form-control");
            inputElement.appendTo("#simulation-mode-form-group");
        }
        // Event handling: Model synchronization
        // @Override
        startSynchronizingModels() {
            this.startSyncSimulationModels();
            this.startSyncFloorModels();
        }
        startSyncSimulationModels() {
            this.startSyncState();
        }
        startSyncState() {
            setInterval(() => {
                this.service.getSimulationState((state) => {
                    this.state.update(state);
                    // Loading indicator
                    if (state.blocking) {
                        this.enableLoadingMode(state.blockingText);
                    }
                    else {
                        this.disableLoadingMode();
                    }
                    // Map
                    this.indoorMap.onSimulationStateUpdated(state);
                });
            }, 100);
        }
        enableLoadingMode(loadingText) {
            this.showLoadingIndicator(loadingText);
            this.indoorMap.pause();
        }
        disableLoadingMode() {
            this.hideLoadingIndicator();
            this.indoorMap.resume();
        }
        showLoadingIndicator(loadingText) {
            $("#loading-modal").modal("show");
            $(".modal-backdrop").appendTo("#center");
            $("body").removeClass("modal-open");
            $("body").css("padding-right", "");
            $("#loading-modal-text").html(loadingText);
        }
        hideLoadingIndicator() {
            $("#loading-modal").modal("hide");
        }
        startSyncFloorModels() {
            let floors = this.indoorMap.getBuilding().getFloors();
            for (let i = 0; i < floors.length; i++) {
                let floor = floors[i];
                this.startFloorDataSync(floor);
            }
        }
        startFloorDataSync(floor) {
            // Floor name
            let siteName = floor.getFloorName();
            // Device states
            this.startUpdatingDeviceStateModel(siteName);
            // Device probability map
            this.startUpdatingProbabilityImage(siteName);
            // Device radio map
            this.startUpdatingDeviceRadioMap(siteName);
            // Geofence states
            this.startUpdatingGeofenceStates(siteName);
        }
        // Updating state: devices state
        startUpdatingDeviceStateModel(siteName) {
            let intervalDurationMs = 50;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        this.loadIndoorStateModel(siteName);
                    }
                }
            }, intervalDurationMs);
        }
        loadIndoorStateModel(siteName) {
            this.service.loadDeviceStates(siteName, (deviceStateModels) => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                if (floor.getFloorName() === siteName) {
                    this.indoorMap.loadIndoorStateModels(floor, deviceStateModels);
                }
            });
        }
        startUpdatingProbabilityImage(siteName) {
            let intervalDurationMs = 1000;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        if ($("#renderProbabilityDensity").prop("checked")) {
                            this.service.loadDeviceProbabilityImage(siteName, (image) => {
                                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                                this.indoorMap.loadProbabilityImage(floor, image);
                            });
                        }
                    }
                }
            }, intervalDurationMs);
        }
        startUpdatingDeviceRadioMap(siteName) {
            let intervalDurationMs = 1000;
            setInterval(() => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                if (floor.getFloorName() === siteName) {
                    if ($("#renderRadioMap").prop("checked")) {
                        let mouseX = GestureRecognizer_11.GestureRecognizer.getMousePositionX();
                        let mouseY = GestureRecognizer_11.GestureRecognizer.getMousePositionY();
                        let hoveringObject = floor.getCollidingObject(mouseX, mouseY);
                        if (hoveringObject !== null && hoveringObject instanceof Beacon_14.Beacon) {
                            let beacon = hoveringObject;
                            this.service.loadDeviceRadioMapImage(siteName, beacon.getModel().uuid, (image) => {
                                this.indoorMap.loadRadioMap(floor, image);
                            });
                        }
                        else {
                            this.indoorMap.unloadRadioMap(floor);
                        }
                    }
                }
            }, intervalDurationMs);
        }
        // Updating state: geofence state
        startUpdatingGeofenceStates(siteName) {
            let intervalDurationMs = this.subcontroller.getConfig().geofenceUpdateIntervalInMs;
            setInterval(() => {
                if (this.state.running) {
                    if (this.indoorMap.getBuilding().getCurrentFloor().getFloorName() === siteName) {
                        this.loadGeofenceStates(siteName);
                    }
                }
            }, intervalDurationMs);
        }
        loadGeofenceStates(siteName) {
            this.service.loadGeofenceStates(siteName, (geofenceStateModels) => {
                let floor = this.indoorMap.getBuilding().getCurrentFloor();
                this.indoorMap.loadGeofenceStateModels(floor, geofenceStateModels);
            });
        }
        // Event handling: Config synchronization
        // @Override
        updateServiceConfig() {
            // 1. Update own config properties
            let applicationConfig = this.applicationConfig.service.application;
            let assetTrackingConfig = applicationConfig.simulation;
            assetTrackingConfig.renderProbabilityDensityMap = $("#renderProbabilityDensity").prop("checked");
            assetTrackingConfig.renderRadioMap = $("#renderRadioMap").prop("checked");
            assetTrackingConfig.useValidationDatasetForCalibration = $("#calibrateWithValidationData").prop("checked");
            // 2. Update subcontroller config properties
            this.subcontroller.updateServiceConfig();
        }
    }
    exports.SimulationController = SimulationController;
});
define("test/tests/indoor/IndoorApplication", ["require", "exports", "test/tests/indoor/IndoorApplicationController", "test/tests/indoor/service/IndoorApplicationService", "test/utils/HttpUtils", "test/tests/indoor/view/map/IndoorMap", "test/tests/indoor/service/monitoring/MonitoringServiceConfig", "test/tests/indoor/service/monitoring/MonitoringService", "test/tests/indoor/service/simulation/SimulationService", "test/tests/indoor/service/simulation/SimulationServiceConfig", "test/tests/indoor/controller/monitoring/MonitoringController", "test/tests/indoor/controller/simulation/SimulationController"], function (require, exports, IndoorApplicationController_5, IndoorApplicationService_3, HttpUtils_4, IndoorMap_4, MonitoringServiceConfig_1, MonitoringService_1, SimulationService_1, SimulationServiceConfig_6, MonitoringController_1, SimulationController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class IndoorApplication {
        constructor() {
            try {
                this.config = this.initConfig();
                this.service = this.initService();
                this.controller = this.initController();
            }
            catch (e) {
                console.log("Failed to initialize application. " + e);
            }
        }
        initConfig() {
            let configString = HttpUtils_4.HttpUtils.getGetParameter("config");
            if (configString === null) {
                return new IndoorApplication.Config();
            }
            else {
                return JSON.parse(configString);
            }
        }
        initService() {
            if (this.config.service.application.type === MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                return new MonitoringService_1.MonitoringService();
            }
            else {
                return new SimulationService_1.SimulationService();
            }
        }
        initController() {
            let subcontroller = null;
            if (this.config.service.application.type === MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                subcontroller = new MonitoringController_1.MonitoringController(this.config, this.service);
            }
            else if (this.config.service.application.type === SimulationServiceConfig_6.SimulationServiceConfig.TYPE_NAME) {
                subcontroller = new SimulationController_1.SimulationController(this.config, this.service);
            }
            else {
                throw new Error("No controller exists for simulation type: " + this.config.service.application.type);
            }
            let controller = new IndoorApplicationController_5.IndoorApplicationController(this.config, subcontroller, this.service);
            return controller;
        }
    }
    exports.IndoorApplication = IndoorApplication;
    (function (IndoorApplication) {
        class Config {
            constructor() {
                this.service = new IndoorApplicationService_3.IndoorApplicationService.Config();
            }
            // Convenience methods
            static getIndoorMapType(config) {
                if (config.service.application.type == MonitoringServiceConfig_1.MonitoringServiceConfig.TYPE_NAME) {
                    return new IndoorMap_4.IndoorMap.Type.AssetTrackingRealTimeMonitoringType();
                }
                else {
                    let simulationApplication = config.service.application;
                    let simConfig = simulationApplication.simulation;
                    if (simulationApplication.simulation.type === SimulationServiceConfig_6.PositioningSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.PositioningDatasetSimulationType();
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.ObjectTrackingSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.ObjectTrackingDatasetSimulationType();
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.AssetTrackingSimulationConfig.TYPE_NAME) {
                        if (simConfig.mode.type === SimulationServiceConfig_6.AssetTrackingMouseSimulationModeConfig.TYPE_NAME) {
                            return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetMouseSimulationType();
                        }
                        else if (simConfig.mode.type === SimulationServiceConfig_6.AssetTrackingDatasetSimulationModeConfig.TYPE_NAME) {
                            return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetValidationSimulationType();
                        }
                    }
                    else if (simulationApplication.simulation.type === SimulationServiceConfig_6.AssetTrackingSimulationConfig.TYPE_NAME) {
                        return new IndoorMap_4.IndoorMap.Type.AssetTrackingDatasetBeaconSimulationType();
                    }
                }
                throw new Error("Illegal simulator service config");
            }
        }
        IndoorApplication.Config = Config;
    })(IndoorApplication = exports.IndoorApplication || (exports.IndoorApplication = {}));
});
define("test/tests/indoor/testIndoorMap", ["require", "exports", "test/tests/indoor/IndoorApplication"], function (require, exports, IndoorApplication_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testIndoorFruityMap() {
        new IndoorApplication_3.IndoorApplication();
    }
    exports.default = testIndoorFruityMap;
});
define("test/tests/mesh/testSimulatorMap", ["require", "exports", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/locale/LocalizationEn", "src/app/simulator/SimulatorMap", "src/map/utils/Logger", "test/utils/HttpUtils", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/device/DeviceModel"], function (require, exports, FloorModelLoader_5, LocalizationEn_7, SimulatorMap_2, Logger_13, HttpUtils_5, RelutionMapModelLoader_5, DeviceModel_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testFruityMeshSimulatorMap() {
        let serverUrl = "http://localhost:5555/simulator";
        let options = new SimulatorMap_2.SimulatorMap.Options();
        options.parentHtmlElement = document.body;
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.localization = new LocalizationEn_7.LocalizationEn();
        options.pathToImages = "../../../img/png/";
        let map = new SimulatorMap_2.SimulatorMap(options);
        loadFloor(map, serverUrl + "/site", serverUrl + "/floorplan", serverUrl + "/wallplan", (floor) => {
            loadSimulatorMap(map, floor, (fruityMap) => {
                runTest(serverUrl, fruityMap);
            });
        });
    }
    exports.default = testFruityMeshSimulatorMap;
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_5.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_5.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadSimulatorMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            callback(fruityMap);
        });
    }
    function runTest(serverUrl, fruityMap) {
        // Initialization
        fruityMap.toggleLayerVisibility("connections", false);
        // Updating
        let intervalDurationMs = 1000;
        startUpdatingDeviceModels(fruityMap, serverUrl, intervalDurationMs);
    }
    function startUpdatingDeviceModels(fruityMap, serverUrl, intervalDurationMs) {
        let lastDevicesObject = "";
        setInterval(function () {
            HttpUtils_5.HttpUtils.getJson(serverUrl + "/devices", function (resultObject) {
                if (resultObject["status"] === "success") {
                    let devicesObject = resultObject.result;
                    let stringifiedDevicesObject = JSON.stringify(devicesObject);
                    if (stringifiedDevicesObject !== lastDevicesObject) {
                        lastDevicesObject = stringifiedDevicesObject;
                        let deviceModels = RelutionMapModelLoader_5.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_9.DeviceModel, false);
                        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
                    }
                }
                else {
                    Logger_13.Logger.logDebug("Updating device models not possible.");
                }
            });
        }, intervalDurationMs);
    }
});
define("test/tests/relution/testPortalDefault", ["require", "exports", "src/app/portal/PortalMap", "src/map/utils/Logger", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/index", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, PortalMap_4, Logger_14, HttpUtils_6, DeviceModel_10, FloorModelLoader_6, fruitymap_1, RelutionMapModelLoader_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapDefault() {
        let mapName = "mway";
        let testCaseName = "default";
        let testDataPath = "../../maps/" + mapName + "/";
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        let floorplanImageUrl = testDataPath + "img/floorplan.png";
        let wallplanImageUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_4.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanImageUrl, wallplanImageUrl, (floor) => {
            loadRelutionMap(map, floor, testCasePath, (fruityMap) => {
                loadDevices(fruityMap, testCasePath, (deviceModels) => {
                    runTest(fruityMap, deviceModels, testCasePath);
                });
            });
        });
    }
    exports.default = testPortalFruityMapDefault;
    function initMapOptions() {
        let options = new fruitymap_1.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_6.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_6.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadRelutionMap(map, floor, testCasePath, callback) {
        map.load(floor, function () {
            window.fruityMap = map;
            window.addEventListener("beforeunload", function (e) {
                map.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                map.setSize(newWidth, newHeight);
            });
            map.addObserver(new TestObserver());
            map.setDeviceEditModeEnabled(false);
            callback(map);
        });
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_6.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_6.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_10.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    function runTest(fruityMap, deviceModels, testCasePath) {
        HttpUtils_6.HttpUtils.getJson(testCasePath + "heatmap.json", function (heatmapSequenceArray) {
            let heatmapData = RelutionMapModelLoader_6.RelutionMapModelLoader.loadModels(heatmapSequenceArray, fruitymap_1.HeatmapModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadHeatmapData(heatmapData);
        });
        fruityMap.getBuilding().getCurrentFloor().updateDevices(deviceModels);
        // Selected/unselecting devices
        // fruityMap.getBuilding().getCurrentFloor()
        // .setDeviceWithUuidSelected("88EAAED7-3FF4-42D6-B31A-34C696D509DB");
        // fruityMap.getBuilding().getCurrentFloor()
        // .setDeviceWithUuidUnselected("88EAAED7-3FF4-42D6-B31A-34C696D509DB");
        // Moving beacon to map/stock
        fruityMap.getBuilding().getCurrentFloor().moveDeviceWithUuidToStock("30BCBC00-3B31-4C5B-A923-126D2BA68702");
        fruityMap.getBuilding().getCurrentFloor().moveDeviceWithUuidToMap("30BCBC00-3B31-4C5B-A923-126D2BA68702");
        // Toggle device visibility
        for (let i = 0; i < deviceModels.length; i++) {
            let deviceModel = deviceModels[i];
            if (deviceModel.platform === "ASSET" && deviceModel.deviceId !== "ABBR2" && deviceModel.deviceId !== "ABBB1") {
                let deviceUuid = deviceModel.uuid;
                fruityMap.getBuilding().getCurrentFloor().toggleDeviceVisibility(deviceUuid);
            }
        }
        // Load tracks
        HttpUtils_6.HttpUtils.getJson(testCasePath + "positionEstimates2.json", function (positionEstimateObject) {
            let estimates = RelutionMapModelLoader_6.RelutionMapModelLoader.loadModels(positionEstimateObject, fruitymap_1.PositionEstimateModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadTracks(estimates);
            /*
            /// Animation
            // Set animation configuration
            let startTimeInSec = 1486636682;
            let endTimeInSec = 1486639019;
            let durationInMs = 10 * 1000;
            let progressCallback = function(progress, currentTimeInSec) {
                console.log("Animation in progress: " + progress);
                console.log("Animation time: " + currentTimeInSec);
            }
            fruityMap.setAnimationConfiguration(startTimeInSec, endTimeInSec, durationInMs, progressCallback);

            // Get animation configuration
            let configuration = fruityMap.getAnimationConfiguration();
            console.log("startTime = " + configuration.startTimeInSec);
            console.log("endTime = " + configuration.endTimeInSec);
            console.log("duration = " + configuration.durationInMs);
            console.log("progressCallback = " + configuration.progressCallback);

            fruityMap.startAnimation();
            fruityMap.stopAnimation();
            fruityMap.pauseAnimation();
            fruityMap.resumeAnimation();
            fruityMap.seekAnimation(0.5);
            */
        });
    }
    class TestObserver {
        // @Override
        onObjectMovedToMap(beacon) {
            Logger_14.Logger.logDebug("On Beacon moved to map");
        }
        // @Override
        onObjectMovedToStock(beacon) {
            Logger_14.Logger.logDebug("On Beacon moved to stock");
        }
        // @Override
        onObjectSelected(object) {
            Logger_14.Logger.logDebug("On object selected");
        }
        // @Override
        onObjectUnselected(object) {
            Logger_14.Logger.logDebug("On object unselected");
        }
        // @Override
        onObjectDoubleClicked(object) {
            Logger_14.Logger.logDebug("On object double clicked");
        }
        // @Override
        onLayerVisibilityChanged(layerName, visible) {
            let visibleString = "";
            if (visible) {
                visibleString = "visible";
            }
            else {
                visibleString = "invisible";
            }
            Logger_14.Logger.logDebug("Layer " + layerName + " has become " + visibleString);
        }
    }
    exports.TestObserver = TestObserver;
});
define("test/tests/relution/testPortalGeofencing", ["require", "exports", "test/utils/HttpUtils", "test/tests/relution/helper/testPortalMap", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/geofence/GeofenceModel", "src/map/utils/Logger", "src/app/relution/view/world/layers/geofenceLayers/geofenceLayer/Geofence"], function (require, exports, HttpUtils_7, testPortalMap_3, RelutionMapModelLoader_7, GeofenceModel_6, Logger_15, Geofence_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapGeofencing() {
        let config = new testPortalMap_3.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = false;
        testPortalMap_3.default(config, runTest);
    }
    exports.default = testPortalFruityMapGeofencing;
    function runTest(fruityMap, deviceModels, testCasePath) {
        testGeofences(fruityMap, testCasePath);
    }
    function testGeofences(fruityMap, testCasePath) {
        HttpUtils_7.HttpUtils.getJson(testCasePath + "geofences.json", function (jsonArray) {
            let models = testLoadingGeofences(fruityMap, jsonArray);
            testGeofenceEditMode(fruityMap);
            testAddGeofenceToScreenCenter(fruityMap, models);
            testGeofenceLayerVisibility(fruityMap);
            testSelectingGeofences(fruityMap, models);
        });
    }
    function testLoadingGeofences(fruityMap, jsonArray) {
        let geofenceModels = RelutionMapModelLoader_7.RelutionMapModelLoader.loadModels(jsonArray, GeofenceModel_6.GeofenceModel, false);
        fruityMap.getBuilding().getCurrentFloor().loadGeofences(geofenceModels);
        return geofenceModels;
    }
    function testGeofenceEditMode(fruityMap) {
        fruityMap.setGeofenceEditModeEnabled(true);
    }
    function testAddGeofenceToScreenCenter(fruityMap, geofenceModels) {
        window.addEventListener("keydown", (keyboardEvent) => {
            const cKeyCode = 67;
            if (keyboardEvent.keyCode === cKeyCode) {
                let newModel = new GeofenceModel_6.RectangleGeofenceModel();
                newModel.uuid = getRandomUuid();
                newModel.name = "Geofence";
                newModel.description = "";
                newModel.shape = "RECTANGLE";
                newModel.timeThreshold = 0;
                newModel.accuracyThreshold = 500;
                newModel.min = { x: 0, y: 0 };
                newModel.max = { x: 0, y: 0 };
                geofenceModels.push(newModel);
                fruityMap.getBuilding().getCurrentFloor().updateGeofences(geofenceModels);
                let geofence = fruityMap.getBuilding().getCurrentFloor().getGeofenceWithUuid(newModel.uuid);
                geofence.translateAndScaleToCameraCenter();
            }
        });
    }
    function getRandomUuid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
    }
    function testGeofenceLayerVisibility(fruityMap) {
        fruityMap.toggleLayerVisibility("geofence", true);
    }
    function testSelectingGeofences(fruityMap, geofenceModels) {
        let firstGeofenceModel = geofenceModels[0];
        fruityMap.getBuilding().getCurrentFloor().setGeofenceWithUuidSelected(firstGeofenceModel.uuid);
        fruityMap.getBuilding().getCurrentFloor().setGeofenceWithUuidUnselected(firstGeofenceModel.uuid);
        fruityMap.addObserver({
            onObjectSelected: function (object) {
                if (object instanceof Geofence_6.Geofence) {
                    Logger_15.Logger.logDebug("On geofence selected");
                }
            },
            onObjectUnselected: function (object) {
                if (object instanceof Geofence_6.Geofence) {
                    Logger_15.Logger.logDebug("On geofence unselected");
                }
            },
            onObjectDoubleClicked: function (object) {
                if (object instanceof Geofence_6.Geofence) {
                    Logger_15.Logger.logDebug("On geofence double clicked");
                }
            }
        });
    }
});
define("test/tests/relution/testPortalLargeAssetPaths", ["require", "exports", "src/app/portal/PortalMap", "src/app/relution/locale/LocalizationEn", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "test/tests/relution/testPortalDefault", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/RelutionMap", "src/app/relution/model/RelutionMapModelLoader", "src/app/relution/model/indoor/PositionEstimateModel"], function (require, exports, PortalMap_5, LocalizationEn_8, HttpUtils_8, DeviceModel_11, testPortalDefault_1, FloorModelLoader_7, RelutionMap_8, RelutionMapModelLoader_8, PositionEstimateModel_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapLargeAssetPaths() {
        let testCaseName = "longtracks3";
        let testDataPath = "../../maps/adendorf/";
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        let floorplanUrl = testDataPath + "img/floorplan.png";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_5.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadFruityMap(map, floor, testCasePath, (fruityMap) => {
                loadDevices(fruityMap, testCasePath, (deviceModels) => {
                    runTest(fruityMap, deviceModels, testCasePath);
                });
            });
        });
    }
    exports.default = testPortalFruityMapLargeAssetPaths;
    function initMapOptions() {
        let options = new RelutionMap_8.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.localization = new LocalizationEn_8.LocalizationEn();
        return options;
    }
    function initMapEnvironment(options) {
        let environment = new RelutionMap_8.RelutionMap.Environment();
        environment.scene.canvasSize.x = window.innerWidth - 30;
        environment.scene.canvasSize.y = window.innerHeight - 30;
        environment.scene.localization = new LocalizationEn_8.LocalizationEn();
        return environment;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_8.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            // FloorModel configuration
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_7.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadFruityMap(fruityMap, floor, testCasePath, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.addObserver(new testPortalDefault_1.TestObserver());
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_8.HttpUtils.getJson(testCasePath + "devices.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_8.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_11.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    function runTest(fruityMap, deviceModels, testCasePath) {
        // Toogle layer visibility
        fruityMap.toggleLayerVisibility("help", false);
        fruityMap.toggleLayerVisibility("ranges", true);
        fruityMap.toggleLayerVisibility("info", false);
        fruityMap.toggleLayerVisibility("connections", true);
        fruityMap.toggleLayerVisibility("tracking", true);
        fruityMap.toggleLayerVisibility("heatmap", true);
        // Toggle device visibility
        for (let i = 0; i < deviceModels.length; i++) {
            const deviceModel = deviceModels[i];
            if (deviceModel.platform === "BLENODE") {
                const deviceUuid = deviceModel.uuid;
                fruityMap.getBuilding().getCurrentFloor().toggleDeviceVisibility(deviceUuid);
            }
        }
        // Load tracks
        HttpUtils_8.HttpUtils.getJson(testCasePath + "positionEstimates.json", function (positionEstimateObject) {
            const estimates = RelutionMapModelLoader_8.RelutionMapModelLoader.loadModels(positionEstimateObject, PositionEstimateModel_2.PositionEstimateModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadTracks(estimates);
        });
    }
});
define("test/tests/relution/testPortalLargeScaleDevices", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "test/tests/relution/testPortalDefault", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, RelutionMap_9, LocalizationEn_9, PortalMap_6, HttpUtils_9, DeviceModel_12, testPortalDefault_2, FloorModelLoader_8, RelutionMapModelLoader_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapLargeScaleDevices() {
        let mapName = "mway";
        let testCaseName = "largescaledevices";
        let testDataPath = "../../maps/" + mapName + "/";
        let testCasePath = testDataPath + "data/" + testCaseName + "/";
        let floorplanUrl = testDataPath + "img/floorplan.png";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_6.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadFruityMap(map, floor, testCasePath, (fruityMap) => {
                loadDevices(fruityMap, testCasePath, (deviceModels) => {
                    runTest(fruityMap, deviceModels, testCasePath);
                });
            });
        });
    }
    exports.default = testPortalFruityMapLargeScaleDevices;
    function initMapOptions() {
        let options = new RelutionMap_9.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.localization = new LocalizationEn_9.LocalizationEn();
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_9.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_8.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadFruityMap(fruityMap, floor, testCasePath, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.addObserver(new testPortalDefault_2.TestObserver());
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
    function loadDevices(fruityMap, testCasePath, callback) {
        HttpUtils_9.HttpUtils.getJson(testCasePath + "devices_100.json", function (devicesObject) {
            let deviceModels = RelutionMapModelLoader_9.RelutionMapModelLoader.loadModels(devicesObject, DeviceModel_12.DeviceModel, false);
            fruityMap.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            callback(deviceModels);
        });
    }
    function runTest(fruityMap, deviceModels, testCasePath) {
        fruityMap.toggleLayerVisibility("help", false);
        fruityMap.toggleLayerVisibility("ranges", true);
        fruityMap.toggleLayerVisibility("info", false);
        fruityMap.toggleLayerVisibility("connections", true);
        fruityMap.toggleLayerVisibility("tracking", true);
        fruityMap.toggleLayerVisibility("heatmap", true);
    }
});
define("test/tests/relution/testPortalMultiFloor", ["require", "exports", "test/tests/relution/helper/testMultiFloorPortalMap"], function (require, exports, testMultiFloorPortalMap_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapMultiFloor() {
        // Configuration
        let buildingName = "multifloor_003";
        let floorNames = ["001", "002", "003"];
        let testCaseName = "default";
        let useSvg = false;
        testMultiFloorPortalMap_2.default(buildingName, floorNames, testCaseName, useSvg, runTest);
    }
    exports.default = testPortalFruityMapMultiFloor;
    function runTest(fruityMap, floor, deviceModels, testCasePath) {
        // Make assets invisible
        for (let i = 0; i < deviceModels.length; i++) {
            let deviceModel = deviceModels[i];
            if (deviceModel.platform === "ASSET") {
                let deviceUuid = deviceModel.uuid;
                floor.toggleDeviceVisibility(deviceUuid);
            }
        }
    }
});
define("test/tests/relution/testPortalTaggingMode", ["require", "exports", "test/tests/relution/helper/testPortalMap", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Beacon", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/MeshGateway", "src/map/utils/Logger"], function (require, exports, testPortalMap_4, Beacon_15, MeshGateway_4, Logger_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalTaggingMode() {
        let config = new testPortalMap_4.PortalMapTestConfig();
        config.mapName = "mway";
        config.testCaseName = "default";
        config.shouldLoadDevices = true;
        config.relutionMapWorld.building.objectTypeVisibilities.set(Beacon_15.Beacon.name, false);
        config.relutionMapWorld.building.objectTypeVisibilities.set(MeshGateway_4.MeshGateway.name, false);
        testPortalMap_4.default(config, runTest);
    }
    exports.default = testPortalTaggingMode;
    function runTest(map, deviceModels, testCasePath) {
        // testTaggingModeDefaultBehavior();
        // testTaggingModeDisabled(map);
        testTaggingModeEnabled(map);
    }
    function testTaggingModeDefaultBehavior() {
        // Testing default behavior
    }
    function testTaggingModeDisabled(map) {
        map.setDeviceTaggingModeEnabled(true);
        map.setDeviceTaggingModeEnabled(false);
    }
    function testTaggingModeEnabled(map) {
        // Enabling tagging mode
        map.setDeviceTaggingModeEnabled(true);
        // Adding prespecified models
        let models = map.getBuilding().getCurrentFloor().getDeviceTagModels();
        models[0].valid = true;
        models[0].x = 0.3;
        models[0].y = 0.3;
        map.getBuilding().getCurrentFloor().updateDeviceTags(models);
        // Fetching device tag models
        let deviceTagModels = map.getBuilding().getCurrentFloor().getDeviceTagModels();
        Logger_16.Logger.logDebug("Device tag models = " + deviceTagModels);
    }
});
define("test/tests/relution/editor/testMapEditor", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/device/DeviceModel", "src/app/relution/model/floor/FloorModelLoader", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Asset", "src/app/relution/model/RelutionMapModelLoader"], function (require, exports, RelutionMap_10, LocalizationEn_10, PortalMap_7, HttpUtils_10, DeviceModel_13, FloorModelLoader_9, Asset_10, RelutionMapModelLoader_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TestMapEditor {
        constructor(configClassConstructor) {
            this.config = null;
            // Model
            this.siteModel = null;
            this.deviceModels = null;
            // View
            this.map = null;
            this.configClassConstructor = configClassConstructor;
            this.config = this.initConfig();
            this.initMap(() => {
                this.initUi();
            });
        }
        // Construction: Config
        initConfig() {
            let configString = HttpUtils_10.HttpUtils.getGetParameter("config");
            if (configString === null) {
                return new this.configClassConstructor();
            }
            else {
                return JSON.parse(configString);
            }
        }
        // Construction: Map
        initMap(callback) {
            let testDataPath = "../../../maps/" + this.config.mapName + "/";
            let testCasePath = testDataPath + "data/" + this.config.testCaseName + "/";
            let floorplanUrl = testDataPath + "img/floorplan.png";
            let wallplanUrl = testDataPath + "img/wallplan.png";
            let options = this.initMapOptions();
            this.map = new PortalMap_7.PortalMap(options);
            this.loadFloor(testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
                this.loadFruityMap(floor, testCasePath, () => {
                    this.loadDevices(testCasePath, () => {
                        callback();
                    });
                });
            });
        }
        initMapOptions() {
            let options = new RelutionMap_10.RelutionMap.Options();
            options.parentHtmlElement = document.getElementById("center");
            options.pathToImages = "../../../../img/png/";
            options.canvasWidth = options.parentHtmlElement.clientWidth;
            options.canvasHeight = options.parentHtmlElement.clientHeight;
            options.localization = new LocalizationEn_10.LocalizationEn();
            options.world.building.objectTypeVisibilities.set(Asset_10.Asset.name, false);
            this.onConfigMap(options);
            return options;
        }
        loadFloor(floorModelUrl, floorplanUrl, wallplanUrl, callback) {
            HttpUtils_10.HttpUtils.getJson(floorModelUrl, (floorObject) => {
                this.siteModel = floorObject;
                let floorModelOptions = {
                    jsonObject: floorObject,
                    pathToFloorplan: floorplanUrl,
                    wallplanUrl: wallplanUrl,
                    isPortalMode: false,
                };
                let floorModel = FloorModelLoader_9.FloorModelLoader.loadFloor(floorModelOptions);
                let floor = this.map.createFloor("floor1", floorModel);
                floor.load(() => {
                    callback(floor);
                });
            });
        }
        loadFruityMap(floor, testCasePath, callback) {
            this.map.load(floor, () => {
                window.fruityMap = this.map;
                window.addEventListener("beforeunload", (e) => {
                    this.map.destroy();
                });
                window.addEventListener("resize", () => {
                    let newWidth = this.map.getConfig().parentHtmlElement.clientWidth;
                    let newHeight = this.map.getConfig().parentHtmlElement.clientHeight;
                    this.map.setSize(newWidth, newHeight);
                });
                this.onMapLoaded();
                callback(this.map);
            });
        }
        loadDevices(testCasePath, callback) {
            HttpUtils_10.HttpUtils.getJson(testCasePath + "devices.json", (devicesObject) => {
                this.deviceModels = devicesObject;
                let deviceModels = RelutionMapModelLoader_10.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_13.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
                callback(deviceModels);
            });
        }
        // Construction: UI
        initUi() {
            this.initBootstrap();
            this.initGeneralSection();
            this.initUiSections();
        }
        // Construction: Init bootstrap
        initBootstrap() {
            $(function () {
                $('[data-toggle="tooltip"]').tooltip();
            });
        }
        // Construction: General section
        initGeneralSection() {
            this.initMapName();
            this.initTestCaseName();
            this.initLoadButton();
        }
        initMapName() {
            $("#map-name").val(this.config.mapName);
        }
        initTestCaseName() {
            $("#test-case-name").val(this.config.testCaseName);
        }
        initLoadButton() {
            $("#reload-button").click(() => {
                this.loadSite(this.config);
            });
        }
        loadSite(config) {
            config.mapName = $("#map-name").val().toString();
            config.testCaseName = $("#test-case-name").val().toString();
            this.updateConfig(config);
            this.addHiddenInputFieldToSimulationModeForm("testName", HttpUtils_10.HttpUtils.getGetParameter("testName"));
            this.addHiddenInputFieldToSimulationModeForm("config", JSON.stringify(config));
            $("#form").submit();
        }
        addHiddenInputFieldToSimulationModeForm(key, value) {
            let inputElement = $("<input></input>");
            inputElement.attr("name", key);
            inputElement.attr("id", key);
            inputElement.attr("value", value);
            inputElement.attr("type", "hidden");
            inputElement.addClass("form-control");
            inputElement.appendTo("#form");
        }
        // Helper methods
        initSwitch(switchId, initiallySwitchedOn, switchCallback) {
            switchId = "#" + switchId;
            if (initiallySwitchedOn) {
                $(switchId).prop("checked", true);
            }
            else {
                $(switchId).prop("checked", false);
            }
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                switchCallback(checked);
            });
        }
    }
    exports.TestMapEditor = TestMapEditor;
    (function (TestMapEditor) {
        class Config {
            constructor() {
                this.mapName = "mway";
                this.testCaseName = "longtracks";
            }
        }
        TestMapEditor.Config = Config;
    })(TestMapEditor = exports.TestMapEditor || (exports.TestMapEditor = {}));
});
define("test/tests/relution/editor/mapEditor/MapEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MapEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
        <fieldset class="scheduler-border">
            <legend class="scheduler-border">Devices:
                <a data-toggle="tooltip" data-html="true" style="float: right" title="
                Click on <code>Save JSON</code> and override your <code>devices.json</code> file, if you want to save the beacon positions.
            " class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <button type="button" class="button btn btn-sm btn-light" id="add-beacon-button">Add
                    beacon</button>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <button type="button" class="button btn btn-sm btn-light" id="remove-beacon-button">Remove
                    selected
                    beacons</button>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Edit devices:</small>
                </div>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" id="editDevices">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Show device names:</small>
                </div>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" id="showDeviceNames">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <a id="save-devices-link" class="button"><button type="button" class="btn btn-sm btn-light"
                        style="width: 100%" id="save-devices-button">Save JSON</button></a>
            </div>
            </legend>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.MapEditorView = MapEditorView;
});
define("test/tests/relution/editor/mapEditor/MapEditorController", ["require", "exports", "src/app/relution/model/device/DeviceModel", "src/app/relution/utils/UuidUtils", "src/app/relution/utils/SerialNumberUtils", "src/app/relution/view/world/layers/deviceLayers/deviceLayer/Device", "src/app/relution/model/RelutionMapModelLoader", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/mapEditor/MapEditorView"], function (require, exports, DeviceModel_14, UuidUtils_3, SerialNumberUtils_2, Device_6, RelutionMapModelLoader_11, TestMapEditor_1, MapEditorView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MapEditorController extends TestMapEditor_1.TestMapEditor {
        constructor() {
            super(MapEditorController.Config);
            this.createCustomUi();
        }
        // Custom UI construction
        createCustomUi() {
            this.view = new MapEditorView_1.MapEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            // Nothing to do
        }
        // Map construction
        onMapLoaded() {
            this.map.setDeviceEditModeEnabled(this.config.editDevices);
            this.map.getBuilding().setInfosOfAllMapObjectsVisible(Device_6.Device.name, this.config.deviceInfosVisible);
        }
        // Construction: UI
        initUiSections() {
            this.initDevicesSection();
        }
        // Construction: Devices section
        initDevicesSection() {
            this.initEditDevicesSwitch();
            this.initShowDeviceNamesSwitch();
            this.initAddBeaconButton();
            this.initRemoveSelectedBeaconsButton();
            this.initSaveDevicesButton();
        }
        initSaveDevicesButton() {
            $("#save-devices-link").click(() => {
                RelutionMapModelLoader_11.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let payload = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.deviceModels, null, 2));
                $("#save-devices-link").attr("href", "data:" + payload);
                $("#save-devices-link").attr("download", "devices.json");
            });
        }
        initEditDevicesSwitch() {
            const switchId = "#editDevices";
            if (this.config.editDevices) {
                $(switchId).prop("checked", true);
            }
            else {
                $(switchId).prop("checked", false);
            }
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.setDeviceEditModeEnabled(checked);
            });
        }
        initShowDeviceNamesSwitch() {
            const switchId = "#showDeviceNames";
            if (this.config.deviceInfosVisible) {
                $(switchId).prop("checked", true);
            }
            else {
                $(switchId).prop("checked", false);
            }
            $(switchId).change(() => {
                const checked = $(switchId).prop("checked");
                this.map.getBuilding().setInfosOfAllMapObjectsVisible(Device_6.Device.name, checked);
            });
        }
        initAddBeaconButton() {
            $("#add-beacon-button").click(() => {
                RelutionMapModelLoader_11.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let newDevice = this.createBeacon();
                this.deviceModels.push(newDevice);
                let deviceModels = RelutionMapModelLoader_11.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_14.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            });
        }
        createBeacon() {
            const organizationUuid = this.siteModel.organizationUuid;
            const siteUuid = this.siteModel.uuid;
            const uuid = UuidUtils_3.UuidUtils.randomUuid();
            const nodeId = this.deviceModels.length;
            const serial = SerialNumberUtils_2.SerialNumberUtils.generateBeaconSerialForIndex(nodeId);
            const enrollmentDate = Date.now();
            const enrollmentUuid = UuidUtils_3.UuidUtils.randomUuid();
            const beacon = {
                "meid": null,
                "enrollmentDate": enrollmentDate,
                "uuid": uuid,
                "deviceId": serial,
                "installedApps": [],
                "securedSharedDeviceStatus": "NOT_SHARED",
                "model": "nRF5",
                "pushMagic": null,
                "details": {
                    "freeOut": 2,
                    "dfuState": "NOT_STARTED",
                    "serialNumber": serial,
                    "manufacturerId": 589,
                    "clusterId": null,
                    "uptimeSeconds": null,
                    "version": 70800,
                    "platform": "BLENODE",
                    "nonConnections": [],
                    "dfuProgress": 0,
                    "batteryInfo": 50,
                    "clusterSize": 11,
                    "macAddress": "CF:FB:F4:AC:C8:51",
                    "calibratedRssi": -55,
                    "dBmTX": 4,
                    "dfuMessage": "",
                    "dBmRX": -90,
                    "freeIn": 0,
                    "edgeRouterUuid": null,
                    "nodeId": nodeId,
                    "chipId": "51:C8:AC:F4:FB:8F:4D:22",
                    "connections": [],
                    "communicationBeacon": false
                },
                "migrated": false,
                "unlockToken": null,
                "siteUuid": siteUuid,
                "deviceType": null,
                "ruleset": null,
                "boundApp": null,
                "tags": [],
                "lastConnectionDate": enrollmentDate,
                "deletedDate": null,
                "name": "SmartBeacon " + serial,
                "status": "COMPLIANT",
                "executedPolicy": null,
                "simSlots": [],
                "advertisingMessages": [],
                "siteName": "Heideck",
                "sharedDeviceStatus": "NOT_SHARED",
                "platform": "BLENODE",
                "deletedBy": null,
                "manufacturer": "Nordic Semiconductor",
                "iotDevice": true,
                "mdmClientVersionCode": null,
                "pushEnabled": false,
                "msisdn": null,
                "appPushToken": null,
                "policy": null,
                "os": "0.7.800",
                "jailbroken": false,
                "userName": "userName",
                "pushToken": null,
                "enrollment": enrollmentUuid,
                "modificationDate": enrollmentDate,
                "organizationUuid": organizationUuid,
                "ownership": "COD",
                "mdmClientVersionName": null,
                "complianceNoticeCount": 0,
                "imei": null,
                "mdmClientInternalName": null,
                "comment": null,
                "user": "C99DBB8F-F3FB-476A-96BA-69CCA73C13A2",
                "complianceViolatedCount": 0,
                "properties": {
                    "onMap": "false",
                    "x": "0.0",
                    "y": "0.0"
                },
                "pushUdid": null
            };
            return beacon;
        }
        initRemoveSelectedBeaconsButton() {
            $("#remove-beacon-button").click(() => {
                RelutionMapModelLoader_11.RelutionMapModelLoader.syncModels(this.map.getBuilding().getCurrentFloor().getDeviceModels(), this.deviceModels, false);
                let devices = this.map.getBuilding().getCurrentFloor().getDeviceLayer().getAllDevices();
                for (let i = 0; i < devices.length; i++) {
                    let device = devices[i];
                    if (device.isSelected()) {
                        let removed = this.removeBeacon(device);
                        if (removed) {
                            i--;
                        }
                    }
                }
                let deviceModels = RelutionMapModelLoader_11.RelutionMapModelLoader.loadModels(this.deviceModels, DeviceModel_14.DeviceModel, false);
                this.map.getBuilding().getCurrentFloor().loadDevices(deviceModels);
            });
        }
        removeBeacon(device) {
            for (let i = 0; i < this.deviceModels.length; i++) {
                let deviceModel = this.deviceModels[i];
                if (deviceModel.uuid === device.getModel().uuid) {
                    this.deviceModels.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
        updateConfig(config) {
            config.editDevices = $("#editDevices").prop("checked");
            config.deviceInfosVisible = $("#showDeviceNames").prop("checked");
        }
    }
    exports.MapEditorController = MapEditorController;
    (function (MapEditorController) {
        class Config extends TestMapEditor_1.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editDevices = true;
                this.deviceInfosVisible = false;
            }
        }
        MapEditorController.Config = Config;
    })(MapEditorController = exports.MapEditorController || (exports.MapEditorController = {}));
});
define("test/tests/relution/editor/mapEditor/testMapEditor", ["require", "exports", "test/tests/relution/editor/mapEditor/MapEditorController"], function (require, exports, MapEditorController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testMapEditor() {
        new MapEditorController_1.MapEditorController();
    }
    exports.default = testMapEditor;
});
define("test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SingleDeviceEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
            <fieldset class="scheduler-border">
            <legend class="scheduler-border">Configuration:
                <a data-toggle="tooltip" data-html="true" style="float: right" class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Enable Single device edit mode:</small>
                </div>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" id="editModeEnabled">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.SingleDeviceEditorView = SingleDeviceEditorView;
});
define("test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorController", ["require", "exports", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorView"], function (require, exports, TestMapEditor_2, SingleDeviceEditorView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class SingleDeviceEditorController extends TestMapEditor_2.TestMapEditor {
        // Construction
        constructor() {
            super(SingleDeviceEditor.Config);
            this.createCustomUi();
        }
        createCustomUi() {
            this.view = new SingleDeviceEditorView_1.SingleDeviceEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            options.world.building.floor.singleDeviceEditLayer.enabled = this.config.editModeEnabled;
            options.world.building.floor.singleDeviceEditLayer.editableDeviceUuid = SingleDeviceEditorController.EDITABLE_DEVICE_UUID;
            options.world.building.floor.tapeMeasureLayer.editModeEnabled = !this.config.editModeEnabled;
        }
        // Construction: Map
        onMapLoaded() {
            this.map.getBuilding().getCurrentFloor().getSingleDeviceEditLayer().addObserver({
                onDevicePositionChanged: function (device) {
                    console.log("Device " + device.getModel().uuid + " positioned.");
                }
            });
        }
        // Construction: UI elements
        initUiSections() {
            this.initConfigurationSection();
        }
        initConfigurationSection() {
            this.initEditModeEnabledSwitch();
        }
        initEditModeEnabledSwitch() {
            this.initSwitch("editModeEnabled", this.config.editModeEnabled, (checked) => {
                this.map.setSingleDeviceEditModeEnabled(checked, SingleDeviceEditorController.EDITABLE_DEVICE_UUID);
                this.map.setTapeMeasureEditModeEnabled(!checked);
            });
        }
        // Configuration update
        updateConfig(config) {
            config.editModeEnabled = $("#editModeEnabled").prop("checked");
        }
    }
    // Constants
    SingleDeviceEditorController.EDITABLE_DEVICE_UUID = "88EAAED7-3FF4-42D6-B31A-34C696D509DB";
    exports.SingleDeviceEditorController = SingleDeviceEditorController;
    var SingleDeviceEditor;
    (function (SingleDeviceEditor) {
        class Config extends TestMapEditor_2.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editModeEnabled = true;
                this.editableDeviceUuid = "";
            }
        }
        SingleDeviceEditor.Config = Config;
    })(SingleDeviceEditor = exports.SingleDeviceEditor || (exports.SingleDeviceEditor = {}));
});
define("test/tests/relution/editor/testSingleDeviceEditMode/testSingleDeviceEditMode", ["require", "exports", "test/tests/relution/editor/testSingleDeviceEditMode/SingleDeviceEditorController"], function (require, exports, SingleDeviceEditorController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testSingleDeviceEditMode() {
        new SingleDeviceEditorController_1.SingleDeviceEditorController();
    }
    exports.default = testSingleDeviceEditMode;
});
define("test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorView", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TapeMeasureModeEditorView {
        // Construction
        constructor() {
            this.customFieldset = `
            <fieldset class="scheduler-border">
            <legend class="scheduler-border">Configuration:
                <a data-toggle="tooltip" data-html="true" style="float: right" class="far fa-question-circle"></a>
            </legend>

            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Enable Tape measure edit mode:</small>
                </div>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" id="editModeEnabled">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
            <div class="row align-items-center" style="padding:3px">
                <div class="col-sm">
                    <small>Make tape measure layer visible:</small>
                </div>
                <label class="switch switch-label switch-pill switch-outline-secondary-alt switch-sm ">
                    <input type="checkbox" class="switch-input" id="visible">
                    <span class="switch-slider" data-checked="On" data-unchecked="Off"></span>
                </label>
            </div>
        </fieldset>
    `;
            $("#custom-section").html(this.customFieldset);
        }
    }
    exports.TapeMeasureModeEditorView = TapeMeasureModeEditorView;
});
define("test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorController", ["require", "exports", "test/tests/relution/editor/testMapEditor", "test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorView"], function (require, exports, TestMapEditor_3, TapeMeasureModeEditorView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TapeMeasureModeEditorController extends TestMapEditor_3.TestMapEditor {
        // Construction
        constructor() {
            super(SingleDeviceEditor.Config);
            this.createCustomUi();
        }
        createCustomUi() {
            this.view = new TapeMeasureModeEditorView_1.TapeMeasureModeEditorView();
        }
        // Map configuration
        onConfigMap(options) {
            options.world.building.floor.tapeMeasureLayer.editModeEnabled = this.config.editModeEnabled;
            options.world.building.layerVisibilities.set("tapeMeasure", this.config.visible);
        }
        // Construction: Map
        onMapLoaded() {
            // Nothing to do
        }
        // Construction: UI elements
        initUiSections() {
            this.initConfigurationSection();
        }
        initConfigurationSection() {
            this.initEditModeEnabledSwitch();
            this.initVisibleSwitch();
        }
        initEditModeEnabledSwitch() {
            this.initSwitch("editModeEnabled", this.config.editModeEnabled, (checked) => {
                this.map.setTapeMeasureEditModeEnabled(checked);
            });
        }
        initVisibleSwitch() {
            this.initSwitch("visible", this.config.visible, (checked) => {
                this.map.toggleLayerVisibility("tapeMeasure", checked);
            });
        }
        // Configuration update
        updateConfig(config) {
            config.editModeEnabled = $("#editModeEnabled").prop("checked");
            config.visible = $("#visible").prop("checked");
        }
    }
    exports.TapeMeasureModeEditorController = TapeMeasureModeEditorController;
    var SingleDeviceEditor;
    (function (SingleDeviceEditor) {
        class Config extends TestMapEditor_3.TestMapEditor.Config {
            constructor() {
                super(...arguments);
                this.editModeEnabled = true;
                this.visible = true;
            }
        }
        SingleDeviceEditor.Config = Config;
    })(SingleDeviceEditor = exports.SingleDeviceEditor || (exports.SingleDeviceEditor = {}));
});
define("test/tests/relution/editor/testTapeMeasureMode/testTapeMeasureMode", ["require", "exports", "test/tests/relution/editor/testTapeMeasureMode/TapeMeasureModeEditorController"], function (require, exports, TapeMeasureModeEditorController_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testTapeMeasureMode() {
        new TapeMeasureModeEditorController_1.TapeMeasureModeEditorController();
    }
    exports.default = testTapeMeasureMode;
});
define("test/tests/tile/testPortalLargeScaleMap", ["require", "exports", "src/app/world/WorldMap"], function (require, exports, WorldMap_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapLargeScaleMap() {
        let worldMap = new WorldMap_2.WorldMap();
    }
    exports.default = testPortalFruityMapLargeScaleMap;
});
define("test/tests/tile/testPortalSvgMap", ["require", "exports", "src/app/relution/RelutionMap", "src/app/relution/locale/LocalizationEn", "src/app/portal/PortalMap", "test/utils/HttpUtils", "src/app/relution/model/floor/FloorModelLoader"], function (require, exports, RelutionMap_11, LocalizationEn_11, PortalMap_8, HttpUtils_11, FloorModelLoader_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function testPortalFruityMapSvgMap() {
        let testDataPath = "../../maps/tiger/";
        let floorplanUrl = testDataPath + "img/floorplan.svg";
        let wallplanUrl = testDataPath + "img/wallplan.png";
        let options = initMapOptions();
        let map = new PortalMap_8.PortalMap(options);
        loadFloor(map, testDataPath + "floor.json", floorplanUrl, wallplanUrl, (floor) => {
            loadFruityMap(map, floor, (fruityMap) => {
                // Nothing to do
            });
        });
    }
    exports.default = testPortalFruityMapSvgMap;
    function initMapOptions() {
        let options = new RelutionMap_11.RelutionMap.Options();
        options.parentHtmlElement = document.body;
        options.pathToImages = "../../../img/png/";
        options.canvasWidth = window.innerWidth - 30;
        options.canvasHeight = window.innerHeight - 30;
        options.localization = new LocalizationEn_11.LocalizationEn();
        return options;
    }
    function loadFloor(map, floorModelUrl, floorplanUrl, wallplanUrl, callback) {
        HttpUtils_11.HttpUtils.getJson(floorModelUrl, function (floorObject) {
            let floorModelOptions = {
                jsonObject: floorObject,
                pathToFloorplan: floorplanUrl,
                wallplanUrl: wallplanUrl,
                isPortalMode: false,
            };
            let floorModel = FloorModelLoader_10.FloorModelLoader.loadFloor(floorModelOptions);
            let floor = map.createFloor("floor1", floorModel);
            floor.load(() => {
                callback(floor);
            });
        });
    }
    function loadFruityMap(fruityMap, floor, callback) {
        fruityMap.load(floor, function () {
            window.fruityMap = fruityMap;
            window.addEventListener("beforeunload", function (e) {
                fruityMap.destroy();
            });
            window.addEventListener("resize", () => {
                let newWidth = window.innerWidth - 30;
                let newHeight = window.innerHeight - 30;
                fruityMap.setSize(newWidth, newHeight);
            });
            fruityMap.setDeviceEditModeEnabled(false);
            callback(fruityMap);
        });
    }
});
define("test/utils/LargeScaleBeaconDataGenerator", ["require", "exports", "src/map/utils/Logger", "test/utils/HttpUtils"], function (require, exports, Logger_17, HttpUtils_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class LargeScaleBeaconDataGenerator {
        static generate() {
            // Load base devices object
            let mapName = "mway";
            let testCaseName = "largescaledevices";
            let testDataPath = "../../maps/" + mapName + "/";
            let testCasePath = testDataPath + "data/" + testCaseName + "/";
            HttpUtils_12.HttpUtils.getJson(testCasePath + "base_devices.json", function (baseDevices) {
                let baseDevice = baseDevices[0];
                let devices = LargeScaleBeaconDataGenerator.generateDevices(baseDevice);
                Logger_17.Logger.logDebug(JSON.stringify(devices));
            });
        }
        static generateDevices(baseDevice) {
            let devices = [];
            for (let i = 0; i < this.numberDevices; i++) {
                let device = JSON.parse(JSON.stringify(baseDevice));
                // UUID
                device.uuid = this.generateUUID();
                // Node ID
                device.details.nodeId = i;
                // Position
                let scaleFactorWidth = 2;
                let scaleFactorHeight = 3;
                device.properties.x = (Math.random() / scaleFactorWidth) + (0.5 - ((1.0 / scaleFactorWidth / 2)));
                device.properties.y = (Math.random() / scaleFactorHeight) + (0.5 - ((1.0 / scaleFactorHeight / 2)));
                // Connections
                device.details.connections = LargeScaleBeaconDataGenerator.generateRandomConnections(i);
                devices.push(device);
            }
            return devices;
        }
        static generateRandomConnections(nodeId) {
            let connections = [];
            for (let i = 0; i < LargeScaleBeaconDataGenerator.numberConnections; i++) {
                let target = Math.floor(Math.random() * LargeScaleBeaconDataGenerator.numberDevices);
                let rssi = Math.floor(-((Math.random() * 100) + 30));
                let connection = { rssi: rssi, target: target };
                connections.push(connection);
            }
            return connections;
        }
        static generateUUID() {
            let d = new Date().getTime();
            if (typeof performance !== "undefined" && typeof performance.now === "function") {
                d += performance.now();
            }
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                let r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
    }
    LargeScaleBeaconDataGenerator.numberDevices = 100;
    LargeScaleBeaconDataGenerator.numberConnections = 2;
    exports.LargeScaleBeaconDataGenerator = LargeScaleBeaconDataGenerator;
});
define("test/utils/TestPositionEstimateDataGenerator", ["require", "exports", "src/map/utils/Logger"], function (require, exports, Logger_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class TestPositionEstimateDataGenerator {
        generateData(devicesObject) {
            let devicePositionEstimates = new Array();
            for (let i = 0; i < devicesObject.length; i++) {
                let deviceObject = devicesObject[i];
                if (deviceObject.platform !== "BLENODE") {
                    let devicePositionEstimate = this.generateRectDistributedTrackDataForDevice(deviceObject);
                    devicePositionEstimates.push(devicePositionEstimate);
                }
            }
            let jsonString = JSON.stringify(devicePositionEstimates);
            Logger_18.Logger.logDebug(jsonString);
        }
        generateRectDistributedTrackDataForDevice(deviceObject) {
            let deviceUuid = deviceObject.uuid;
            let deviceEndX = deviceObject.details.positionEstimate.x;
            let deviceEndY = deviceObject.details.positionEstimate.y;
            let startTime = 1480678180;
            let endTime = 1480678190;
            let numLocations = 50;
            let jsonObject = {
                siteUuid: "97f596ea-2321-42d6-8267-c308f08a6bb1",
                deviceUuid: deviceUuid,
                floorId: [],
                x: [],
                y: [],
                accuracy: [],
                deltaTime: [],
                startTimeSec: startTime,
                endTimeSec: endTime,
            };
            for (let i = 0; i < numLocations; i++) {
                let floorId = 1;
                let x = this.getRandomByRect(deviceEndX);
                let y = this.getRandomByRect(deviceEndY);
                let accuracy = 1;
                let deltaTime = ((endTime - startTime) / numLocations) * Math.random();
                jsonObject.floorId.push(floorId);
                jsonObject.x.push(x);
                jsonObject.y.push(y);
                jsonObject.accuracy.push(accuracy);
                jsonObject.deltaTime.push(deltaTime);
            }
            return jsonObject;
        }
        getRandomByRect(mean) {
            let x = (Math.random() - 0.5) * 0.05 + mean;
            return x;
        }
        generateLineSimilarTrackDataForDevice(deviceObject) {
            let deviceUuid = deviceObject.uuid;
            let deviceEndX = deviceObject.details.positionEstimate.x;
            let deviceEndY = deviceObject.details.positionEstimate.y;
            let startTime = 1480678180;
            let endTime = 1480678190;
            let numLocations = 500;
            let jsonObject = {
                siteUuid: "97f596ea-2321-42d6-8267-c308f08a6bb1",
                deviceUuid: deviceUuid,
                floorId: [],
                x: [],
                y: [],
                accuracy: [],
                deltaTime: [],
                startTimeSec: startTime,
                endTimeSec: endTime,
            };
            for (let i = 0; i < numLocations; i++) {
                let floorId = 1;
                let x = 0;
                let y = 0;
                if (i !== numLocations - 1) {
                    x = deviceEndX - ((numLocations - i) * 0.005);
                    y = deviceEndY - (0.01 * Math.random());
                }
                else {
                    x = deviceEndX;
                    y = deviceEndY;
                }
                let accuracy = 1;
                let deltaTime = ((endTime - startTime) / numLocations) * Math.random();
                jsonObject.floorId.push(floorId);
                jsonObject.x.push(x);
                jsonObject.y.push(y);
                jsonObject.accuracy.push(accuracy);
                jsonObject.deltaTime.push(deltaTime);
            }
            return jsonObject;
        }
    }
    exports.TestPositionEstimateDataGenerator = TestPositionEstimateDataGenerator;
});
define("fruitymap", ["require", "exports", "src/index", "pixi.js"], function (require, exports, index_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(index_1);
});
//# sourceMappingURL=fruitymap.js.map